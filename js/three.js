(function() {
    function r(e, n, t) {
        function o(i, f) { if (!n[i]) { if (!e[i]) { var c = "function" == typeof require && require; if (!f && c) return c(i, !0); if (u) return u(i, !0); var a = new Error("Cannot find module '" + i + "'"); throw a.code = "MODULE_NOT_FOUND", a } var p = n[i] = { exports: {} };
                e[i][0].call(p.exports, function(r) { var n = e[i][1][r]; return o(n || r) }, p, p.exports, r, e, n, t) } return n[i].exports } for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]); return o } return r })()({
    1: [function(require, module, exports) {
        window.Threebox = require("./src/Threebox.js"), window.THREE = require("./src/three.js");

    }, { "./src/Threebox.js": 2, "./src/three.js": 23 }],
    2: [function(require, module, exports) {
        const THREE = require("./three.js"),
            CameraSync = require("./camera/CameraSync.js"),
            utils = require("./utils/utils.js"),
            SunCalc = require("./utils/suncalc.js"),
            ThreeboxConstants = require("./utils/constants.js"),
            Objects = require("./objects/objects.js"),
            material = require("./utils/material.js"),
            sphere = require("./objects/sphere.js"),
            extrusion = require("./objects/extrusion.js"),
            label = require("./objects/label.js"),
            tooltip = require("./objects/tooltip.js"),
            loader = require("./objects/loadObj.js"),
            Object3D = require("./objects/Object3D.js"),
            line = require("./objects/line.js"),
            tube = require("./objects/tube.js"),
            LabelRenderer = require("./objects/LabelRenderer.js"),
            BuildingShadows = require("./objects/effects/BuildingShadows.js");

        function Threebox(e, t, i) { this.init(e, t, i) } Threebox.prototype = { repaint: function() { this.map.repaint = !0 }, init: function(e, t, i) { this.options = utils._validate(i || {}, defaultOptions), this.map = e, this.map.tb = this, this.objects = new Objects, this.renderer = new THREE.WebGLRenderer({ alpha: !0, antialias: !0, canvas: e.getCanvas(), context: t }), this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.setSize(this.map.getCanvas().clientWidth, this.map.getCanvas().clientHeight), this.renderer.outputEncoding = THREE.sRGBEncoding, this.renderer.autoClear = !1, this.labelRenderer = new LabelRenderer(this.map), this.scene = new THREE.Scene, this.world = new THREE.Group, this.world.name = "world", this.scene.add(this.world), this.objectsCache = new Map, this.zoomLayers = [], this.fov = this.options.fov, this.orthographic = this.options.orthographic || !1, this.raycaster = new THREE.Raycaster, this.raycaster.layers.set(0), this.mapCenter = this.map.getCenter(), this.mapCenterUnits = utils.projectToWorld([this.mapCenter.lng, this.mapCenter.lat]), this.lightDateTime = new Date, this.lightLng = this.mapCenter.lng, this.lightLat = this.mapCenter.lat, this.sunPosition, this.rotationStep = 5, this.gridStep = 6, this.altitudeStep = .1, this.lights = this.initLights, this.options.defaultLights && this.defaultLights(), this.options.realSunlight && this.realSunlight(this.options.realSunlightHelper), this.enableSelectingFeatures = this.options.enableSelectingFeatures || !1, this.enableSelectingObjects = this.options.enableSelectingObjects || !1, this.enableDraggingObjects = this.options.enableDraggingObjects || !1, this.enableRotatingObjects = this.options.enableRotatingObjects || !1, this.enableTooltips = this.options.enableTooltips || !1, this.multiLayer = this.options.multiLayer || !1, this.map.on("style.load", function() { this.tb.zoomLayers = [], this.tb.options.multiLayer && this.addLayer({ id: "threebox_layer", type: "custom", renderingMode: "3d", map: this, onAdd: function(e, t) {}, render: function(e, t) { this.map.tb.update() } }) }), this.map.on("load", function() { let t;
                    this.selectedObject, this.selectedFeature, this.draggedObject, this.overedObject, this.overedFeature; let i, s = this.getCanvasContainer();
                    this.getCanvasContainer().style.cursor = "default"; let r, o, n, a, h = [];

                    function l(e) { var t = s.getBoundingClientRect(); return { x: e.originalEvent.clientX - t.left - s.clientLeft, y: e.originalEvent.clientY - t.top - s.clientTop } } this.unselectObject = function(e) { e.selected = !1, this.selectedObject = null }, this.unselectFeature = function(e) { void 0 !== e.id && (this.setFeatureState({ source: e.source, sourceLayer: e.sourceLayer, id: e.id }, { select: !1 }), this.removeTooltip(e), (e = this.queryRenderedFeatures({ layers: [e.layer.id], filter: ["==", ["id"], e.id] })[0]) && this.fire("SelectedFeatureChange", { detail: e }), this.selectedFeature = null) }, this.selectFeature = function(e) { this.selectedFeature = e, this.setFeatureState({ source: this.selectedFeature.source, sourceLayer: this.selectedFeature.sourceLayer, id: this.selectedFeature.id }, { select: !0 }), this.selectedFeature = this.queryRenderedFeatures({ layers: [this.selectedFeature.layer.id], filter: ["==", ["id"], this.selectedFeature.id] })[0], this.addTooltip(this.selectedFeature), this.fire("SelectedFeatureChange", { detail: this.selectedFeature }) }, this.unoverFeature = function(t) { this.overedFeature && void 0 !== this.overedFeature && this.overedFeature.id != t && (e.setFeatureState({ source: this.overedFeature.source, sourceLayer: this.overedFeature.sourceLayer, id: this.overedFeature.id }, { hover: !1 }), this.removeTooltip(this.overedFeature), this.overedFeature = null) }, this.addTooltip = function(e) { if (!this.tb.enableTooltips) return; let t = this.tb.getFeatureCenter(e),
                            i = this.tb.tooltip({ text: e.properties.name || e.id || e.type, mapboxStyle: !0, feature: e });
                        i.setCoords(t), this.tb.add(i, e.layer.id), e.tooltip = i, e.tooltip.tooltip.visible = !0 }, this.removeTooltip = function(e) { e.tooltip && (e.tooltip.visibility = !1, this.tb.remove(e.tooltip), e.tooltip = null) }, e.onContextMenu = function(e) { alert("contextMenu") }, this.onClick = function(t) { let i, s = []; if (e.tb.enableSelectingObjects && (s = this.tb.queryRenderedFeatures(t.point)), i = "object" == typeof s[0]) { let e = Threebox.prototype.findParent3DObject(s[0]); if (e) { if (this.selectedFeature && this.unselectFeature(this.selectedFeature), this.selectedObject) { if (this.selectedObject.uuid != e.uuid) this.selectedObject.selected = !1, e.selected = !0, this.selectedObject = e;
                                    else if (this.selectedObject.uuid == e.uuid) return void this.unselectObject(this.selectedObject) } else this.selectedObject = e, this.selectedObject.selected = !0;
                                this.selectedObject.dispatchEvent(new CustomEvent("Wireframed", { detail: this.selectedObject, bubbles: !0, cancelable: !0 })), this.selectedObject.dispatchEvent(new CustomEvent("IsPlayingChanged", { detail: this.selectedObject, bubbles: !0, cancelable: !0 })), this.repaint = !0, t.preventDefault() } } else { let i = []; if (e.tb.enableSelectingFeatures && (i = this.queryRenderedFeatures(t.point)), i.length > 0 && "fill-extrusion" == i[0].layer.type && void 0 !== i[0].id)
                                if (this.selectedObject && this.unselectObject(this.selectedObject), this.selectedFeature) { if (this.selectedFeature.id != i[0].id) this.unselectFeature(this.selectedFeature), this.selectFeature(i[0]);
                                    else if (this.selectedFeature.id == i[0].id) return void this.unselectFeature(this.selectedFeature) } else this.selectFeature(i[0]) } }, this.onMouseMove = function(s) { let h, d = l(s); if (this.getCanvasContainer().style.cursor = "default", s.originalEvent.altKey && this.draggedObject) { if (!e.tb.enableRotatingObjects) return;
                            t = "rotate", this.getCanvasContainer().style.cursor = "move";
                            Math.min(i.x, d.x), Math.max(i.x, d.x), Math.min(i.y, d.y), Math.max(i.y, d.y); let s = { x: 0, y: 0, z: Math.round(a[2] + ~~((d.x - i.x) / this.tb.rotationStep) % 360 * this.tb.rotationStep % 360) }; return this.draggedObject.setRotation(s), void this.draggedObject.addHelp("rot: " + s.z + "&#176;") } if (s.originalEvent.shiftKey && this.draggedObject) { if (!e.tb.enableDraggingObjects) return;
                            t = "translate", this.getCanvasContainer().style.cursor = "move"; let i = s.lngLat,
                                n = [Number((i.lng + r).toFixed(this.tb.gridStep)), Number((i.lat + o).toFixed(this.tb.gridStep)), this.draggedObject.modelHeight]; return this.draggedObject.setCoords(n), void this.draggedObject.addHelp("lng: " + n[0] + "&#176;, lat: " + n[1] + "&#176;") } if (s.originalEvent.ctrlKey && this.draggedObject) { if (!e.tb.enableDraggingObjects) return;
                            t = "altitude", this.getCanvasContainer().style.cursor = "move"; let i = s.point.y * this.tb.altitudeStep,
                                r = [this.draggedObject.coordinates[0], this.draggedObject.coordinates[1], Number((-i - n).toFixed(this.tb.gridStep))]; return this.draggedObject.setCoords(r), void this.draggedObject.addHelp("alt: " + r[2] + "m") } let u = []; if (e.tb.enableSelectingObjects && (u = this.tb.queryRenderedFeatures(s.point)), h = "object" == typeof u[0]) { let e = Threebox.prototype.findParent3DObject(u[0]);
                            e && (this.unoverFeature(this.overedFeature), this.getCanvasContainer().style.cursor = "pointer", this.selectedObject && e.uuid == this.selectedObject.uuid || (this.overedObject && (this.overedObject.over = !1, this.overedObject = null), e.over = !0, this.overedObject = e), this.repaint = !0, s.preventDefault()) } else { this.overedObject && (this.overedObject.over = !1, this.overedObject = null); let t = [];
                            e.tb.enableSelectingFeatures && (t = this.queryRenderedFeatures(s.point)), t.length > 0 && (this.unoverFeature(t[0]), "fill-extrusion" == t[0].layer.type && void 0 !== t[0].id && (this.selectedFeature && this.selectedFeature.id == t[0].id || (this.getCanvasContainer().style.cursor = "pointer", this.overedFeature = t[0], this.setFeatureState({ source: this.overedFeature.source, sourceLayer: this.overedFeature.sourceLayer, id: this.overedFeature.id }, { hover: !0 }), this.overedFeature = e.queryRenderedFeatures({ layers: [this.overedFeature.layer.id], filter: ["==", ["id"], this.overedFeature.id] })[0], this.addTooltip(this.overedFeature)))) } }, this.onMouseDown = function(t) {
                        (t.originalEvent.shiftKey || t.originalEvent.altKey || t.originalEvent.ctrlKey) && 0 === t.originalEvent.button && this.selectedObject && (e.tb.enableDraggingObjects || e.tb.enableRotatingObjects) && (t.preventDefault(), e.getCanvasContainer().style.cursor = "move", e.once("mouseup", this.onMouseUp), this.draggedObject = this.selectedObject, i = l(t), h = this.draggedObject.coordinates, a = utils.degreeify(this.draggedObject.rotation), r = h[0] - t.lngLat.lng, o = h[1] - t.lngLat.lat, n = -this.draggedObject.modelHeight - t.point.y * this.tb.altitudeStep) }, this.onMouseUp = function(e) { this.getCanvasContainer().style.cursor = "default", this.off("mouseup", this.onMouseUp), this.off("mouseout", this.onMouseUp), this.dragPan.enable(), this.draggedObject && (this.draggedObject.dispatchEvent(new CustomEvent("ObjectDragged", { detail: { draggedObject: this.draggedObject, draggedAction: t }, bubbles: !0, cancelable: !0 })), this.draggedObject.removeHelp(), this.draggedObject = null, t = null) }, this.onMouseOut = function(e) { if (this.overedFeature) { let t = this.queryRenderedFeatures(e.point);
                            t.length > 0 && this.overedFeature.id != t[0].id && (this.getCanvasContainer().style.cursor = "default", this.unoverFeature(t[0])) } }, this.onZoomEnd = function(e) { this.tb.zoomLayers.forEach(e => { this.tb.toggleLayer(e) }) }; let d = !1,
                        u = !1,
                        c = 17,
                        g = 91,
                        p = 16,
                        b = 83;
                    dK = 68, this.on("click", this.onClick), this.on("mousemove", this.onMouseMove), this.on("mouseout", this.onMouseOut), this.on("mousedown", this.onMouseDown), this.on("zoom", this.onZoomEnd), document.addEventListener("keydown", function(e) { e.which !== c && e.which !== g || (d = !0), e.which === p && (u = !0); let t = this.selectedObject; if (u && e.which === b && t) { let e = utils.toDecimal; if (t.help) t.removeHelp();
                            else { let i = t.modelSize,
                                    s = 1; "meters" !== t.userData.units && ((s = utils.projectedUnitsPerMeter(t.coordinates[1])) || (s = 1), s = e(s, 7)), t.addHelp("size(m): " + e(i.x / s, 3) + " W, " + e(i.y / s, 3) + " L, " + e(i.z / s, 3) + " H"), this.repaint = !0 } return !1 } }.bind(this), !0), document.addEventListener("keyup", function(e) { e.which != c && e.which != g || (d = !1), e.which === p && (u = !1) }.bind(this)) }) }, get fov() { return this.options.fov }, set fov(e) { this.camera instanceof THREE.PerspectiveCamera && this.options.fov !== e && (this.map.transform.fov = e, this.camera.fov = this.map.transform.fov, this.cameraSync.setupCamera(), this.map.repaint = !0, this.options.fov = e) }, get orthographic() { return this.options.orthographic }, set orthographic(e) { const t = this.map.getCanvas().clientHeight,
                    i = this.map.getCanvas().clientWidth;
                e ? (this.map.transform.fov = 0, this.camera = new THREE.OrthographicCamera(i / -2, i / 2, t / 2, t / -2, 1, 1e21)) : (this.map.transform.fov = this.fov, this.camera = new THREE.PerspectiveCamera(this.map.transform.fov, i / t, 1, 1e21)), this.camera.layers.enable(0), this.camera.layers.enable(1), this.cameraSync = new CameraSync(this.map, this.camera, this.world), this.map.repaint = !0, this.options.orthographic = e }, sphere: function(e) { return this.setDefaultView(e, this.options), sphere(e, this.world) }, line: line, label: label, tooltip: tooltip, tube: function(e) { return this.setDefaultView(e, this.options), tube(e, this.world) }, extrusion: function(e) { return this.setDefaultView(e, this.options), extrusion(e) }, Object3D: function(e) { return this.setDefaultView(e, this.options), Object3D(e) }, loadObj: async function(e, t) { this.setDefaultView(e, this.options); let i = this.objectsCache.get(e.obj);
                i ? i.promise.then(i => { t(i.duplicate(e)) }).catch(t => { this.objectsCache.delete(e.obj), console.error("Could not load model file: " + e.obj) }) : this.objectsCache.set(e.obj, { promise: new Promise(async (i, s) => { loader(e, t, async e => { e.duplicate ? i(e.duplicate()) : s(e) }) }) }) }, material: function(e) { return material(e) }, initLights: { ambientLight: null, dirLight: null, dirLightBack: null, dirLightHelper: null, hemiLight: null, pointLight: null }, utils: utils, SunCalc: SunCalc, Constants: ThreeboxConstants, projectToWorld: function(e) { return this.utils.projectToWorld(e) }, unprojectFromWorld: function(e) { return this.utils.unprojectFromWorld(e) }, projectedUnitsPerMeter: function(e) { return this.utils.projectedUnitsPerMeter(e) }, getFeatureCenter: function(e, t, i) { return utils.getFeatureCenter(e, t, i) }, getObjectHeightOnFloor: function(e, t, i) { return utils.getObjectHeightOnFloor(e, t, i) }, queryRenderedFeatures: function(e) { let t = new THREE.Vector2; return t.x = e.x / this.map.transform.width * 2 - 1, t.y = 1 - e.y / this.map.transform.height * 2, this.raycaster.setFromCamera(t, this.camera), this.raycaster.intersectObjects(this.world.children, !0) }, findParent3DObject: function(e) { var t; return e.object.traverseAncestors(function(e) { e.parent && "Group" == e.parent.type && e.userData.obj && (t = e) }), t }, setLayoutProperty: function(e, t, i) { this.map.setLayoutProperty(e, t, i), null == i || "visibility" !== t || this.world.children.forEach(function(t) { t.layer === e && (t.visibility = i) }) }, setLayerZoomRange: function(e, t, i) { this.map.getLayer(e) && (this.map.setLayerZoomRange(e, t, i), this.zoomLayers.includes(e) || this.zoomLayers.push(e), this.toggleLayer(e)) }, setLayerHeigthProperty: function(e, t) { let i = this.map.getLayer(e); if (i)
                    if ("fill-extrusion" == i.type) { let e = this.map.getStyle().sources[i.source].data;
                        e.features.forEach(function(e) { e.properties.level = t }), this.map.getSource(i.source).setData(e) } else "custom" == i.type && this.world.children.forEach(function(i) { let s = i.userData.feature; if (s && s.layer === e) { let e = this.tb.getFeatureCenter(s, i, t);
                            i.setCoords(e) } }) }, setStyle: function(e, t) { this.clear().then(() => { this.map.setStyle(e, t) }) }, toggleLayer: function(e, t = !0) { let i = this.map.getLayer(e); if (i) { if (!t) return void this.toggle(i.id, !1); let e = this.map.getZoom(); if (i.minzoom && e < i.minzoom) return void this.toggle(i.id, !1); if (i.maxzoom && e >= i.maxzoom) return void this.toggle(i.id, !1);
                    this.toggle(i.id, !0) } }, toggle: function(e, t) { this.setLayoutProperty(e, "visibility", t ? "visible" : "none"), this.labelRenderer.toggleLabels(e, t) }, update: function() { this.map.repaint && (this.map.repaint = !1); var e = Date.now();
                this.objects.animationManager.update(e), this.updateLightHelper(), this.renderer.state.reset(), this.renderer.render(this.scene, this.camera), this.labelRenderer.render(this.scene, this.camera), !1 === this.options.passiveRendering && this.map.triggerRepaint() }, add: function(e, t, i) { if (!this.enableTooltips && e.tooltip && (e.tooltip.visibility = !1), this.world.add(e), t) { e.layer = t, e.source = i; let s = this.map.getLayer(t); if (s) { let t = s.visibility,
                            i = void 0 === t;
                        e.visibility = !(!i && "visible" !== t) } } }, remove: function(e) { this.map.selectedObject && e.uuid == this.map.selectedObject.uuid && this.map.unselectObject(this.map.selectedObject), this.map.draggedObject && e.uuid == this.map.draggedObject.uuid && (this.map.draggedObject = null), e.dispose && e.dispose(), this.world.remove(e), e = null }, clear: async function(e = null, t = !1) { return new Promise((i, s) => { let r = [];
                    this.world.children.forEach(function(e) { r.push(e) }); for (let t = 0; t < r.length; t++) { let i = r[t];
                        i.layer !== e && e || this.remove(i) } t && this.objectsCache.forEach(e => { e.promise.then(e => { e.dispose(), e = null }) }), i("clear") }) }, removeLayer: function(e) { this.clear(e, !0).then(() => { this.map.removeLayer(e) }) }, getSunPosition: function(e, t) { return SunCalc.getPosition(e, t[1], t[0]) }, getSunTimes: function(e, t) { return SunCalc.getTimes(e, t[1], t[0], t[2] ? t[2] : 0) }, setBuildingShadows: function(e) { if (this.map.getLayer(e.buildingsLayerId)) { let t = new BuildingShadows(e, this);
                    this.map.addLayer(t, e.buildingsLayerId) } else console.warn("The layer '" + e.buildingsLayerId + "' does not exist in the map.") }, setSunlight: function(e = new Date, t) { if (!this.lights.dirLight || !this.options.realSunlight) return void console.warn("To use setSunlight it's required to set realSunlight : true in Threebox initial options."); var i = new Date(e.getTime()); if (t ? t.lng && t.lat ? this.mapCenter = t : this.mapCenter = { lng: t[0], lat: t[1] } : this.mapCenter = this.map.getCenter(), this.lightDateTime && this.lightDateTime.getTime() === i.getTime() && this.lightLng === this.mapCenter.lng && this.lightLat === this.mapCenter.lat) return;
                this.lightDateTime = i, this.lightLng = this.mapCenter.lng, this.lightLat = this.mapCenter.lat, this.sunPosition = this.getSunPosition(i, [this.mapCenter.lng, this.mapCenter.lat]); let s = this.sunPosition.altitude,
                    r = Math.PI + this.sunPosition.azimuth,
                    o = ThreeboxConstants.WORLD_SIZE / 2,
                    n = Math.sin(s),
                    a = Math.cos(s),
                    h = Math.cos(r) * a,
                    l = Math.sin(r) * a;
                this.lights.dirLight.position.set(l, h, n), this.lights.dirLight.position.multiplyScalar(o), this.lights.dirLight.intensity = Math.max(n, -.15), this.lights.dirLight.updateMatrixWorld(), this.updateLightHelper(), this.map.loaded() && this.map.setLight({ anchor: "map", position: [1.5, 180 + 180 * this.sunPosition.azimuth / Math.PI, 90 - 180 * this.sunPosition.altitude / Math.PI], "position-transition": { duration: 0 }, color: `hsl(40, ${50*Math.cos(this.sunPosition.altitude)}%, ${96*Math.sin(this.sunPosition.altitude)}%)` }, { duration: 0 }) }, updateLightHelper: function() { this.lights.dirLightHelper && (this.lights.dirLightHelper.position.setFromMatrixPosition(this.lights.dirLight.matrixWorld), this.lights.dirLightHelper.updateMatrix(), this.lights.dirLightHelper.update()) }, dispose: async function() { return console.log(this.memory()), new Promise(e => { e(this.clear(null, !0).then(e => (this.map.remove(), this.map = {}, this.scene.remove(this.world), this.scene.dispose(), this.world.children = [], this.world = null, this.objectsCache.clear(), this.labelRenderer.dispose(), console.log(this.memory()), this.renderer.dispose(), e))) }) }, defaultLights: function() { this.lights.ambientLight = new THREE.AmbientLight(new THREE.Color("hsl(0, 0%, 100%)"), .75), this.scene.add(this.lights.ambientLight), this.lights.dirLightBack = new THREE.DirectionalLight(new THREE.Color("hsl(0, 0%, 100%)"), .25), this.lights.dirLightBack.position.set(30, 100, 100), this.scene.add(this.lights.dirLightBack), this.lights.dirLight = new THREE.DirectionalLight(new THREE.Color("hsl(0, 0%, 100%)"), .25), this.lights.dirLight.position.set(-30, 100, -100), this.scene.add(this.lights.dirLight) }, realSunlight: function(e = !1) { this.renderer.shadowMap.enabled = !0, this.lights.dirLight = new THREE.DirectionalLight(16777215, 1), this.scene.add(this.lights.dirLight), e && (this.lights.dirLightHelper = new THREE.DirectionalLightHelper(this.lights.dirLight, 5), this.scene.add(this.lights.dirLightHelper));
                this.lights.dirLight.castShadow = !0, this.lights.dirLight.shadow.radius = 2, this.lights.dirLight.shadow.mapSize.width = 8192, this.lights.dirLight.shadow.mapSize.height = 8192, this.lights.dirLight.shadow.camera.top = this.lights.dirLight.shadow.camera.right = 1e3, this.lights.dirLight.shadow.camera.bottom = this.lights.dirLight.shadow.camera.left = -1e3, this.lights.dirLight.shadow.camera.near = 1, this.lights.dirLight.shadow.camera.visible = !0, this.lights.dirLight.shadow.camera.far = 4e8, this.lights.hemiLight = new THREE.HemisphereLight(new THREE.Color(16777215), new THREE.Color(16777215), .6), this.lights.hemiLight.color.setHSL(.661, .96, .12), this.lights.hemiLight.groundColor.setHSL(.11, .96, .14), this.lights.hemiLight.position.set(0, 0, 50), this.scene.add(this.lights.hemiLight), this.setSunlight() }, setDefaultView: function(e, t) { e.bbox = e.bbox && t.enableSelectingObjects, e.tooltip = e.tooltip && t.enableTooltips }, memory: function() { return this.renderer.info.memory }, programs: function() { return this.renderer.info.programs.length }, version: "2.1.7" };
        var defaultOptions = { defaultLights: !1, realSunlight: !1, realSunlightHelper: !1, passiveRendering: !0, enableSelectingFeatures: !1, enableSelectingObjects: !1, enableDraggingObjects: !1, enableRotatingObjects: !1, enableTooltips: !1, multiLayer: !1, orthographic: !1, fov: ThreeboxConstants.FOV_DEGREES };
        module.exports = exports = Threebox;

    }, { "./camera/CameraSync.js": 4, "./objects/LabelRenderer.js": 6, "./objects/Object3D.js": 7, "./objects/effects/BuildingShadows.js": 9, "./objects/extrusion.js": 10, "./objects/label.js": 11, "./objects/line.js": 12, "./objects/loadObj.js": 13, "./objects/objects.js": 19, "./objects/sphere.js": 20, "./objects/tooltip.js": 21, "./objects/tube.js": 22, "./three.js": 23, "./utils/constants.js": 24, "./utils/material.js": 25, "./utils/suncalc.js": 26, "./utils/utils.js": 27 }],
    3: [function(require, module, exports) {
        const THREE = require("../three.js"),
            utils = require("../utils/utils.js");

        function AnimationManager(t) { this.map = t, this.enrolledObjects = [], this.previousFrameTime } AnimationManager.prototype = { unenroll: function(t) { this.enrolledObjects.splice(this.enrolledObjects.indexOf(t), 1) }, enroll: function(t) { if (t.clock = new THREE.Clock, t.hasDefaultAnimation = !1, t.defaultAction, t.actions = [], t.mixer, t.animations && t.animations.length > 0) { t.hasDefaultAnimation = !0; let i = t.userData.defaultAnimation ? t.userData.defaultAnimation : 0;
                    t.mixer = new THREE.AnimationMixer(t), e(i) }

                function e(e) { for (let i = 0; i < t.animations.length; i++) { e > t.animations.length && console.log("The animation index " + e + " doesn't exist for this object"); let a = t.animations[i],
                            n = t.mixer.clipAction(a);
                        t.actions.push(n), e === i ? (t.defaultAction = n, n.setEffectiveWeight(1)) : n.setEffectiveWeight(0), n.play() } } let i = !1;
                Object.defineProperty(t, "isPlaying", { get: () => i, set(e) { i != e && (i = e, t.dispatchEvent(new CustomEvent("IsPlayingChanged", { detail: t, bubbles: !0, cancelable: !0 }))) } }), this.enrolledObjects.push(t), t.animationQueue = [], t.set = function(e) { if (e.duration > 0) { let i = { start: Date.now(), expiration: Date.now() + e.duration, endState: {} };
                        utils.extend(e, i); let a = e.coords,
                            n = e.rotation,
                            o = e.scale || e.scaleX || e.scaleY || e.scaleZ; if (n) { let i = t.rotation;
                            e.startRotation = [i.x, i.y, i.z], e.endState.rotation = utils.types.rotation(e.rotation, e.startRotation), e.rotationPerMs = e.endState.rotation.map(function(t, i) { return (t - e.startRotation[i]) / e.duration }) } if (o) { let i = t.scale;
                            e.startScale = [i.x, i.y, i.z], e.endState.scale = utils.types.scale(e.scale, e.startScale), e.scalePerMs = e.endState.scale.map(function(t, i) { return (t - e.startScale[i]) / e.duration }) } a && (e.pathCurve = new THREE.CatmullRomCurve3(utils.lnglatsToWorld([t.coordinates, e.coords]))); let s = { type: "set", parameters: e };
                        this.animationQueue.push(s), tb.map.repaint = !0 } else this.stop(), e.rotation = utils.radify(e.rotation), this._setObject(e); return this }, t.animationMethod = null, t.stop = function(e) { return t.mixer && (t.isPlaying = !1, cancelAnimationFrame(t.animationMethod)), this.animationQueue = [], this }, t.followPath = function(t, e) { let i = { type: "followPath", parameters: utils._validate(t, defaults.followPath) }; return utils.extend(i.parameters, { pathCurve: new THREE.CatmullRomCurve3(utils.lnglatsToWorld(t.path)), start: Date.now(), expiration: Date.now() + i.parameters.duration, cb: e }), this.animationQueue.push(i), tb.map.repaint = !0, this }, t._setObject = function(t) { let e = t.position,
                        i = t.rotation,
                        a = t.scale,
                        n = t.worldCoordinates,
                        o = t.quaternion,
                        s = t.translate; if (e) { this.coordinates = e; let t = utils.projectToWorld(e);
                        this.position.copy(t) } if (s) { this.coordinates = [this.coordinates[0] + s[0], this.coordinates[1] + s[1], this.coordinates[2] + s[2]]; let e = utils.projectToWorld(s);
                        this.translateX(e.x), this.translateY(e.y), this.translateZ(e.z), t.position = this.coordinates } if (i && (this.rotation.set(i[0], i[1], i[2]), t.rotation = new THREE.Vector3(i[0], i[1], i[2])), a && (this.scale.set(a[0], a[1], a[2]), t.scale = this.scale), o && (this.quaternion.setFromAxisAngle(o[0], o[1]), t.rotation = o[0].multiplyScalar(o[1])), n) { this.position.copy(n); let e = utils.unprojectFromWorld(n);
                        this.coordinates = t.position = e } this.updateMatrixWorld(), tb.map.repaint = !0, this.dispatchEvent(new CustomEvent("ObjectChanged", { detail: { object: this, action: { position: t.position, rotation: t.rotation, scale: t.scale } }, bubbles: !0, cancelable: !0 })) }, t.playDefault = function(e) { if (t.mixer && t.hasDefaultAnimation) { let i = { start: Date.now(), expiration: Date.now() + e.duration, endState: {} };
                        utils.extend(e, i), t.mixer.timeScale = e.speed || 1; let a = { type: "playDefault", parameters: e }; return this.animationQueue.push(a), tb.map.repaint = !0, this } }, t.playAnimation = function(i) { t.mixer && (i.animation && e(i.animation), t.playDefault(i)) }, t.pauseAllActions = function() { t.mixer && t.actions.forEach(function(t) { t.paused = !0 }) }, t.unPauseAllActions = function() { t.mixer && t.actions.forEach(function(t) { t.paused = !1 }) }, t.deactivateAllActions = function() { t.mixer && t.actions.forEach(function(t) { t.stop() }) }, t.activateAllActions = function() { t.mixer && t.actions.forEach(function(t) { t.play() }) }, t.idle = function() { return t.mixer && t.mixer.update(.01), tb.map.repaint = !0, this } }, update: function(t) { void 0 === this.previousFrameTime && (this.previousFrameTime = t); if (!this.enrolledObjects) return !1; for (let e = this.enrolledObjects.length - 1; e >= 0; e--) { let i = this.enrolledObjects[e]; if (i.animationQueue && 0 !== i.animationQueue.length)
                        for (let e = i.animationQueue.length - 1; e >= 0; e--) { let a = i.animationQueue[e]; if (!a) continue; let n = a.parameters; if (!n.expiration) return i.animationQueue.splice(e, 1), void(i.animationQueue[e] && (i.animationQueue[e].parameters.start = t)); if (t >= n.expiration) n.expiration = !1, "playDefault" === a.type ? i.stop() : (n.endState && i._setObject(n.endState), void 0 !== n.cb && n.cb());
                            else { let e = (t - n.start) / n.duration; if ("set" === a.type) { let t = {};
                                    n.pathCurve && (t.worldCoordinates = n.pathCurve.getPoint(e)), n.rotationPerMs && (t.rotation = n.startRotation.map(function(t, i) { return t + n.rotationPerMs[i] * e * n.duration })), n.scalePerMs && (t.scale = n.startScale.map(function(t, i) { return t + n.scalePerMs[i] * e * n.duration })), i._setObject(t) } if ("followPath" === a.type) { let t = n.pathCurve.getPointAt(e); if (objectState = { worldCoordinates: t }, n.trackHeading) { let t = n.pathCurve.getTangentAt(e).normalize(),
                                            i = new THREE.Vector3(0, 0, 0),
                                            a = new THREE.Vector3(0, 1, 0);
                                        i.crossVectors(a, t).normalize(); let o = Math.acos(a.dot(t));
                                        objectState.quaternion = [i, o] } i._setObject(objectState) } "playDefault" === a.type && (i.activateAllActions(), i.isPlaying = !0, i.animationMethod = requestAnimationFrame(this.update), i.mixer.update(i.clock.getDelta()), tb.map.repaint = !0) } } } this.previousFrameTime = t } };
        const defaults = { followPath: { path: null, duration: 1e3, trackHeading: !0 } };
        module.exports = exports = AnimationManager;

    }, { "../three.js": 23, "../utils/utils.js": 27 }],
    4: [function(require, module, exports) {
        const THREE = require("../three.js"),
            utils = require("../utils/utils.js"),
            ThreeboxConstants = require("../utils/constants.js");

        function CameraSync(t, a, e) { this.map = t, this.camera = a, this.active = !0, this.camera.matrixAutoUpdate = !1, this.world = e || new THREE.Group, this.world.position.x = this.world.position.y = ThreeboxConstants.WORLD_SIZE / 2, this.world.matrixAutoUpdate = !1, this.state = { translateCenter: (new THREE.Matrix4).makeTranslation(ThreeboxConstants.WORLD_SIZE / 2, -ThreeboxConstants.WORLD_SIZE / 2, 0), worldSizeRatio: ThreeboxConstants.TILE_SIZE / ThreeboxConstants.WORLD_SIZE, worldSize: ThreeboxConstants.TILE_SIZE * this.map.transform.scale }; let i = this;
            this.map.on("move", function() { i.updateCamera() }).on("resize", function() { i.setupCamera() }), this.setupCamera() } CameraSync.prototype = { setupCamera: function() { this.state.fov = this.map.transform._fov; const t = this.map.transform;
                this.camera.aspect = t.width / t.height, this.camera.updateProjectionMatrix(), this.halfFov = this.state.fov / 2; const a = { x: t.width / 2, y: t.height / 2 },
                    e = .5 / Math.tan(this.halfFov) * t.height,
                    i = t._maxPitch * Math.PI / 180;
                this.acuteAngle = Math.PI / 2 - i, this.state.cameraToCenterDistance = e, this.state.offset = a, this.state.cameraTranslateZ = (new THREE.Matrix4).makeTranslation(0, 0, this.state.cameraToCenterDistance), this.state.maxFurthestDistance = .95 * this.state.cameraToCenterDistance * (Math.cos(this.acuteAngle) * Math.sin(this.halfFov) / Math.sin(Math.max(.01, Math.min(Math.PI - .01, this.acuteAngle - this.halfFov))) + 1), this.updateCamera() }, updateCamera: function(t) { if (!this.camera) return void console.log("nocamera"); const a = this.map.transform,
                    e = Math.PI / 2 + a._pitch;
                this.cameraToCenterDistance = .5 / Math.tan(this.halfFov) * a.height, this.state.cameraTranslateZ = (new THREE.Matrix4).makeTranslation(0, 0, this.cameraToCenterDistance); const i = Math.sin(this.halfFov) * this.state.cameraToCenterDistance / Math.sin(Math.PI - e - this.halfFov),
                    s = Math.cos(Math.PI / 2 - a._pitch),
                    r = 1.01 * (s * i + this.state.cameraToCenterDistance),
                    h = a.height / 50,
                    n = Math.max(h * s, h),
                    o = a.height,
                    m = a.width;
                this.camera instanceof THREE.OrthographicCamera ? this.camera.projectionMatrix = utils.makeOrthographicMatrix(m / -2, m / 2, o / 2, o / -2, n, r) : this.camera.projectionMatrix = utils.makePerspectiveMatrix(this.state.fov, m / o, n, r); let c = this.calcCameraMatrix(a._pitch, a.angle);
                this.camera.matrixWorld.copy(c); let l = a.scale * this.state.worldSizeRatio,
                    p = new THREE.Matrix4,
                    u = new THREE.Matrix4,
                    x = new THREE.Matrix4;
                p.makeScale(l, l, l); let T = a.x || a.point.x,
                    M = a.y || a.point.y;
                u.makeTranslation(-T, M, 0), x.makeRotationZ(Math.PI), this.world.matrix = (new THREE.Matrix4).premultiply(x).premultiply(this.state.translateCenter).premultiply(p).premultiply(u) }, calcCameraMatrix(t, a, e) { const i = this.map.transform,
                    s = void 0 === t ? i._pitch : t,
                    r = void 0 === a ? i.angle : a,
                    h = void 0 === e ? this.state.cameraTranslateZ : e; return (new THREE.Matrix4).premultiply(h).premultiply((new THREE.Matrix4).makeRotationX(s)).premultiply((new THREE.Matrix4).makeRotationZ(r)) } }, module.exports = exports = CameraSync;

    }, { "../three.js": 23, "../utils/constants.js": 24, "../utils/utils.js": 27 }],
    5: [function(require, module, exports) {
        const THREE = require("../three.js");
        THREE.CSS2DObject = function(e) { THREE.Object3D.call(this), this.element = e || document.createElement("div"), this.element.style.position = "absolute", this.alwaysVisible = !1, Object.defineProperty(this, "layer", { get() { return this.parent && this.parent.parent ? this.parent.parent.layer : null } }), this.dispose = function() { this.remove(), this.element = null }, this.remove = function() { this.element instanceof Element && null !== this.element.parentNode && this.element.parentNode.removeChild(this.element) }, this.addEventListener("removed", function() { this.remove() }) }, THREE.CSS2DObject.prototype = Object.assign(Object.create(THREE.Object3D.prototype), { constructor: THREE.CSS2DObject, copy: function(e, t) { return THREE.Object3D.prototype.copy.call(this, e, t), this.element = e.element.cloneNode(!0), this } }), THREE.CSS2DRenderer = function() { var e, t, r, n, i = this,
                o = new THREE.Vector3,
                s = new THREE.Matrix4,
                a = new THREE.Matrix4,
                l = { objects: new WeakMap, list: new Map };
            this.cacheList = l.list; var c = document.createElement("div");
            c.style.overflow = "hidden", this.domElement = c, this.getSize = function() { return { width: e, height: t } }, this.setSize = function(i, o) { r = (e = i) / 2, n = (t = o) / 2, c.style.width = i + "px", c.style.height = o + "px" }, this.renderObject = function(e, t, s) { if (e instanceof THREE.CSS2DObject)
                    if (e.visible) { e.onBeforeRender(i, t, s), o.setFromMatrixPosition(e.matrixWorld), o.applyMatrix4(a); var d = e.element,
                            u = "translate(-50%,-50%) translate(" + (o.x * r + r) + "px," + (-o.y * n + n) + "px)";
                        d.style.WebkitTransform = u, d.style.MozTransform = u, d.style.oTransform = u, d.style.transform = u, d.style.display = e.visible && o.z >= -1 && o.z <= 1 ? "" : "none"; var m = { distanceToCameraSquared: h(s, e) };
                        l.objects.set({ key: e.uuid }, m), l.list.set(e.uuid, e), d.parentNode !== c && c.appendChild(d), e.onAfterRender(i, t, s) } else l.objects.delete({ key: e.uuid }), l.list.delete(e.uuid), e.remove(); for (var p = 0, E = e.children.length; p < E; p++) this.renderObject(e.children[p], t, s) }; var d, u, h = (d = new THREE.Vector3, u = new THREE.Vector3, function(e, t) { return d.setFromMatrixPosition(e.matrixWorld), u.setFromMatrixPosition(t.matrixWorld), d.distanceToSquared(u) }),
                m = function(e) { for (var t = function(e) { var t = []; return e.traverse(function(e) { e instanceof THREE.CSS2DObject && t.push(e) }), t }(e).sort(function(e, t) { let r = l.objects.get({ key: e.uuid }),
                                n = l.objects.get({ key: t.uuid }); if (r && n) return r.distanceToCameraSquared - n.distanceToCameraSquared }), r = t.length, n = 0, i = t.length; n < i; n++) t[n].element.style.zIndex = r - n };
            this.render = function(e, t) {!0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), s.copy(t.matrixWorldInverse), a.multiplyMatrices(t.projectionMatrix, s), this.renderObject(e, e, t), m(e) } }, module.exports = exports = { CSS2DRenderer: THREE.CSS2DRenderer, CSS2DObject: THREE.CSS2DObject };

    }, { "../three.js": 23 }],
    6: [function(require, module, exports) {
        const THREE = require("./CSS2DRenderer.js");

        function LabelRenderer(e) { this.map = e, this.renderer = new THREE.CSS2DRenderer, this.renderer.setSize(this.map.getCanvas().clientWidth, this.map.getCanvas().clientHeight), this.renderer.domElement.style.position = "absolute", this.renderer.domElement.id = "labelCanvas", this.renderer.domElement.style.top = 0, this.renderer.domElement.style.zIndex = "0", this.map.getCanvasContainer().appendChild(this.renderer.domElement), this.scene, this.camera, this.dispose = function() { this.map.getCanvasContainer().removeChild(this.renderer.domElement), this.renderer.domElement.remove(), this.renderer = {} }, this.setSize = function(e, t) { this.renderer.setSize(e, t) }, this.map.on("resize", function() { this.renderer.setSize(this.map.getCanvas().clientWidth, this.map.getCanvas().clientHeight) }.bind(this)), this.state = { reset: function() {} }, this.render = async function(e, t) { return this.scene = e, this.camera = t, new Promise(i => { i(this.renderer.render(e, t)) }) }, this.toggleLabels = async function(e, t) { return new Promise(i => { i(this.setVisibility(e, t, this.scene, this.camera, this.renderer)) }) }, this.setVisibility = function(e, t, i, r, s) { this.renderer.cacheList.forEach(function(n) { n.visible != t && n.layer === e && (t && n.alwaysVisible || !t) && (n.visible = t, s.renderObject(n, i, r)) }) } } module.exports = exports = LabelRenderer;

    }, { "./CSS2DRenderer.js": 5 }],
    7: [function(require, module, exports) {
        const Objects = require("./objects.js"),
            utils = require("../utils/utils.js");

        function Object3D(t) { let e = (t = utils._validate(t, Objects.prototype._defaults.Object3D)).obj; const s = utils.types.rotation(t.rotation, [0, 0, 0]),
                o = utils.types.scale(t.scale, [1, 1, 1]);
            e.rotation.set(s[0], s[1], s[2]), e.scale.set(o[0], o[1], o[2]), e.name = "model"; let r = Objects.prototype._makeGroup(e, t); return t.obj.name = "model", Objects.prototype._addMethods(r), r.setAnchor(t.anchor), r.setCenter(t.adjustment), r.raycasted = t.raycasted, r.visibility = !0, r } module.exports = exports = Object3D;

    }, { "../utils/utils.js": 27, "./objects.js": 19 }],
    8: [function(require, module, exports) {
        var mod = {},
            l = void 0,
            aa = mod;

        function r(t, r) { var i, e = t.split("."),
                h = aa;!(e[0] in h) && h.execScript && h.execScript("var " + e[0]); for (; e.length && (i = e.shift());) e.length || r === l ? h = h[i] ? h[i] : h[i] = {} : h[i] = r }
        var t = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array && "undefined" != typeof DataView;

        function v(r) { var i, e, h, s, a, n, f, o, l, u, c = r.length,
                b = 0,
                y = Number.POSITIVE_INFINITY; for (o = 0; o < c; ++o) r[o] > b && (b = r[o]), r[o] < y && (y = r[o]); for (i = 1 << b, e = new(t ? Uint32Array : Array)(i), h = 1, s = 0, a = 2; h <= b;) { for (o = 0; o < c; ++o)
                    if (r[o] === h) { for (n = 0, f = s, l = 0; l < h; ++l) n = n << 1 | 1 & f, f >>= 1; for (u = h << 16 | o, l = n; l < i; l += a) e[l] = u;++s }++ h, s <<= 1, a <<= 1 } return [e, b, y] }

        function w(r, i) { switch (this.g = [], this.h = 32768, this.d = this.f = this.a = this.l = 0, this.input = t ? new Uint8Array(r) : r, this.m = !1, this.i = y, this.r = !1, !i && (i = {}) || (i.index && (this.a = i.index), i.bufferSize && (this.h = i.bufferSize), i.bufferType && (this.i = i.bufferType), i.resize && (this.r = i.resize)), this.i) {
                case A:
                    this.b = 32768, this.c = new(t ? Uint8Array : Array)(32768 + this.h + 258); break;
                case y:
                    this.b = 0, this.c = new(t ? Uint8Array : Array)(this.h), this.e = this.z, this.n = this.v, this.j = this.w; break;
                default:
                    throw Error("invalid inflate mode") } }
        var A = 0,
            y = 1,
            B = { t: A, s: y };
        w.prototype.k = function() { for (; !this.m;) { var r = C(this, 3); switch (1 & r && (this.m = !0), r >>>= 1) {
                    case 0:
                        var i = this.input,
                            e = this.a,
                            h = this.c,
                            s = this.b,
                            a = i.length,
                            n = l,
                            f = h.length,
                            o = l; if (this.d = this.f = 0, e + 1 >= a) throw Error("invalid uncompressed block header: LEN"); if (n = i[e++] | i[e++] << 8, e + 1 >= a) throw Error("invalid uncompressed block header: NLEN"); if (n === ~(i[e++] | i[e++] << 8)) throw Error("invalid uncompressed block header: length verify"); if (e + n > i.length) throw Error("input buffer is broken"); switch (this.i) {
                            case A:
                                for (; s + n > h.length;) { if (n -= o = f - s, t) h.set(i.subarray(e, e + o), s), s += o, e += o;
                                    else
                                        for (; o--;) h[s++] = i[e++];
                                    this.b = s, h = this.e(), s = this.b } break;
                            case y:
                                for (; s + n > h.length;) h = this.e({ p: 2 }); break;
                            default:
                                throw Error("invalid inflate mode") } if (t) h.set(i.subarray(e, e + n), s), s += n, e += n;
                        else
                            for (; n--;) h[s++] = i[e++];
                        this.a = e, this.b = s, this.c = h; break;
                    case 1:
                        this.j(ba, ca); break;
                    case 2:
                        var u, c, b, d, p = C(this, 5) + 257,
                            w = C(this, 5) + 1,
                            g = C(this, 4) + 4,
                            k = new(t ? Uint8Array : Array)(D.length),
                            m = l,
                            U = l,
                            I = l,
                            N = l,
                            P = l; for (P = 0; P < g; ++P) k[D[P]] = C(this, 3); if (!t)
                            for (P = g, g = k.length; P < g; ++P) k[D[P]] = 0; for (u = v(k), m = new(t ? Uint8Array : Array)(p + w), P = 0, d = p + w; P < d;) switch (U = E(this, u), U) {
                            case 16:
                                for (N = 3 + C(this, 2); N--;) m[P++] = I; break;
                            case 17:
                                for (N = 3 + C(this, 3); N--;) m[P++] = 0;
                                I = 0; break;
                            case 18:
                                for (N = 11 + C(this, 7); N--;) m[P++] = 0;
                                I = 0; break;
                            default:
                                I = m[P++] = U } c = v(t ? m.subarray(0, p) : m.slice(0, p)), b = v(t ? m.subarray(p) : m.slice(p)), this.j(c, b); break;
                    default:
                        throw Error("unknown BTYPE: " + r) } } return this.n() };
        var P, fa, G = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
            D = t ? new Uint16Array(G) : G,
            H = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258],
            I = t ? new Uint16Array(H) : H,
            J = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0],
            K = t ? new Uint8Array(J) : J,
            L = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577],
            da = t ? new Uint16Array(L) : L,
            ea = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
            N = t ? new Uint8Array(ea) : ea,
            O = new(t ? Uint8Array : Array)(288);
        for (P = 0, fa = O.length; P < fa; ++P) O[P] = 143 >= P ? 8 : 255 >= P ? 9 : 279 >= P ? 7 : 8;
        var R, ga, ba = v(O),
            Q = new(t ? Uint8Array : Array)(30);
        for (R = 0, ga = Q.length; R < ga; ++R) Q[R] = 5;
        var ca = v(Q);

        function C(t, r) { for (var i, e = t.f, h = t.d, s = t.input, a = t.a, n = s.length; h < r;) { if (a >= n) throw Error("input buffer is broken");
                e |= s[a++] << h, h += 8 } return i = e & (1 << r) - 1, t.f = e >>> r, t.d = h - r, t.a = a, i }

        function E(t, r) { for (var i, e, h = t.f, s = t.d, a = t.input, n = t.a, f = a.length, o = r[0], l = r[1]; s < l && !(n >= f);) h |= a[n++] << s, s += 8; if ((e = (i = o[h & (1 << l) - 1]) >>> 16) > s) throw Error("invalid code length: " + e); return t.f = h >> e, t.d = s - e, t.a = n, 65535 & i }

        function W(t, r) { var i, e; switch (this.input = t, this.a = 0, !r && (r = {}) || (r.index && (this.a = r.index), r.verify && (this.A = r.verify)), i = t[this.a++], e = t[this.a++], 15 & i) {
                case ha:
                    this.method = ha; break;
                default:
                    throw Error("unsupported compression method") } if (0 != ((i << 8) + e) % 31) throw Error("invalid fcheck flag:" + ((i << 8) + e) % 31); if (32 & e) throw Error("fdict flag is not supported");
            this.q = new w(t, { index: this.a, bufferSize: r.bufferSize, bufferType: r.bufferType, resize: r.resize }) } w.prototype.j = function(t, r) { var i = this.c,
                e = this.b;
            this.o = t; for (var h, s, a, n, f = i.length - 258; 256 !== (h = E(this, t));)
                if (256 > h) e >= f && (this.b = e, i = this.e(), e = this.b), i[e++] = h;
                else
                    for (n = I[s = h - 257], 0 < K[s] && (n += C(this, K[s])), h = E(this, r), a = da[h], 0 < N[h] && (a += C(this, N[h])), e >= f && (this.b = e, i = this.e(), e = this.b); n--;) i[e] = i[e++ - a]; for (; 8 <= this.d;) this.d -= 8, this.a--;
            this.b = e }, w.prototype.w = function(t, r) { var i = this.c,
                e = this.b;
            this.o = t; for (var h, s, a, n, f = i.length; 256 !== (h = E(this, t));)
                if (256 > h) e >= f && (f = (i = this.e()).length), i[e++] = h;
                else
                    for (n = I[s = h - 257], 0 < K[s] && (n += C(this, K[s])), h = E(this, r), a = da[h], 0 < N[h] && (a += C(this, N[h])), e + n > f && (f = (i = this.e()).length); n--;) i[e] = i[e++ - a]; for (; 8 <= this.d;) this.d -= 8, this.a--;
            this.b = e }, w.prototype.e = function() { var r, i, e = new(t ? Uint8Array : Array)(this.b - 32768),
                h = this.b - 32768,
                s = this.c; if (t) e.set(s.subarray(32768, e.length));
            else
                for (r = 0, i = e.length; r < i; ++r) e[r] = s[r + 32768]; if (this.g.push(e), this.l += e.length, t) s.set(s.subarray(h, h + 32768));
            else
                for (r = 0; 32768 > r; ++r) s[r] = s[h + r]; return this.b = 32768, s }, w.prototype.z = function(r) { var i, e, h, s = this.input.length / this.a + 1 | 0,
                a = this.input,
                n = this.c; return r && ("number" == typeof r.p && (s = r.p), "number" == typeof r.u && (s += r.u)), 2 > s ? e = (h = (a.length - this.a) / this.o[2] / 2 * 258 | 0) < n.length ? n.length + h : n.length << 1 : e = n.length * s, t ? (i = new Uint8Array(e)).set(n) : i = n, this.c = i }, w.prototype.n = function() { var r, i, e, h, s, a = 0,
                n = this.c,
                f = this.g,
                o = new(t ? Uint8Array : Array)(this.l + (this.b - 32768)); if (0 === f.length) return t ? this.c.subarray(32768, this.b) : this.c.slice(32768, this.b); for (i = 0, e = f.length; i < e; ++i)
                for (h = 0, s = (r = f[i]).length; h < s; ++h) o[a++] = r[h]; for (i = 32768, e = this.b; i < e; ++i) o[a++] = n[i]; return this.g = [], this.buffer = o }, w.prototype.v = function() { var r, i = this.b; return t ? this.r ? (r = new Uint8Array(i)).set(this.c.subarray(0, i)) : r = this.c.subarray(0, i) : (this.c.length > i && (this.c.length = i), r = this.c), this.buffer = r }, W.prototype.k = function() { var t, r, i = this.input; if (t = this.q.k(), this.a = this.q.a, this.A) { r = (i[this.a++] << 24 | i[this.a++] << 16 | i[this.a++] << 8 | i[this.a++]) >>> 0; var e = t; if ("string" == typeof e) { var h, s, a = e.split(""); for (h = 0, s = a.length; h < s; h++) a[h] = (255 & a[h].charCodeAt(0)) >>> 0;
                    e = a } for (var n, f = 1, o = 0, l = e.length, u = 0; 0 < l;) { l -= n = 1024 < l ? 1024 : l;
                    do { o += f += e[u++] } while (--n);
                    f %= 65521, o %= 65521 } if (r !== (o << 16 | f) >>> 0) throw Error("invalid adler-32 checksum") } return t };
        var ha = 8;
        r("Zlib.Inflate", W), r("Zlib.Inflate.prototype.decompress", W.prototype.k);
        var Y, Z, $, ia, X = { ADAPTIVE: B.s, BLOCK: B.t };
        if (Object.keys) Y = Object.keys(X);
        else
            for (Z in Y = [], $ = 0, X) Y[$++] = Z;
        for ($ = 0, ia = Y.length; $ < ia; ++$) r("Zlib.Inflate.BufferType." + (Z = Y[$]), X[Z]);
        var Zlib = mod.Zlib;
        module.exports = exports = Zlib;

    }, {}],
    9: [function(require, module, exports) {
        const SunCalc = require("../../utils/suncalc.js");
        class BuildingShadows { constructor(t, i) { this.id = t.layerId, this.type = "custom", this.renderingMode = "3d", this.opacity = .5, this.buildingsLayerId = t.buildingsLayerId, this.minAltitude = t.minAltitude || .1, this.tb = i } onAdd(t, i) { this.map = t; const e = i.createShader(i.VERTEX_SHADER);
                i.shaderSource(e, "\n\t\t\tuniform mat4 u_matrix;\n\t\t\tuniform float u_height_factor;\n\t\t\tuniform float u_altitude;\n\t\t\tuniform float u_azimuth;\n\t\t\tattribute vec2 a_pos;\n\t\t\tattribute vec4 a_normal_ed;\n\t\t\tattribute lowp vec2 a_base;\n\t\t\tattribute lowp vec2 a_height;\n\t\t\tvoid main() {\n\t\t\t\tfloat base = max(0.0, a_base.x);\n\t\t\t\tfloat height = max(0.0, a_height.x);\n\t\t\t\tfloat t = mod(a_normal_ed.x, 2.0);\n\t\t\t\tvec4 pos = vec4(a_pos, t > 0.0 ? height : base, 1);\n\t\t\t\tfloat len = pos.z * u_height_factor / tan(u_altitude);\n\t\t\t\tpos.x += cos(u_azimuth) * len;\n\t\t\t\tpos.y += sin(u_azimuth) * len;\n\t\t\t\tpos.z = 0.0;\n\t\t\t\tgl_Position = u_matrix * pos;\n\t\t\t}\n\t\t\t"), i.compileShader(e); const r = i.createShader(i.FRAGMENT_SHADER);
                i.shaderSource(r, "\n\t\t\tvoid main() {\n\t\t\t\tgl_FragColor = vec4(0.0, 0.0, 0.0, 0.7);\n\t\t\t}\n\t\t\t"), i.compileShader(r), this.program = i.createProgram(), i.attachShader(this.program, e), i.attachShader(this.program, r), i.linkProgram(this.program), i.validateProgram(this.program), this.uMatrix = i.getUniformLocation(this.program, "u_matrix"), this.uHeightFactor = i.getUniformLocation(this.program, "u_height_factor"), this.uAltitude = i.getUniformLocation(this.program, "u_altitude"), this.uAzimuth = i.getUniformLocation(this.program, "u_azimuth"), this.aPos = i.getAttribLocation(this.program, "a_pos"), this.aNormal = i.getAttribLocation(this.program, "a_normal_ed"), this.aBase = i.getAttribLocation(this.program, "a_base"), this.aHeight = i.getAttribLocation(this.program, "a_height") } render(t, i) { t.useProgram(this.program); const e = this.map.style.sourceCaches.composite,
                    r = e.getVisibleCoordinates().reverse(),
                    a = this.map.getLayer(this.buildingsLayerId),
                    o = this.map.painter.context,
                    { lng: s, lat: n } = this.map.getCenter(),
                    h = this.tb.getSunPosition(this.tb.lightDateTime, [s, n]);
                t.uniform1f(this.uAltitude, h.altitude > this.minAltitude ? h.altitude : 0), t.uniform1f(this.uAzimuth, h.azimuth + 3 * Math.PI / 2), t.enable(t.BLEND), t.blendFunc(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA);
                t.getExtension("EXT_blend_minmax");
                t.disable(t.DEPTH_TEST); for (const i of r) { const r = e.getTile(i),
                        s = r.getBucket(a); if (!s) continue; const [n, h] = s.programConfigurations.programConfigurations[this.buildingsLayerId]._buffers;
                    t.uniformMatrix4fv(this.uMatrix, !1, i.posMatrix), t.uniform1f(this.uHeightFactor, Math.pow(2, i.overscaledZ) / r.tileSize / 8); for (const i of s.segments.get()) { const e = o.currentNumAttributes || 0,
                            r = 2; for (let i = r; i < e; i++) t.disableVertexAttribArray(i); const a = i.vertexOffset || 0;
                        t.enableVertexAttribArray(this.aPos), t.enableVertexAttribArray(this.aNormal), t.enableVertexAttribArray(this.aHeight), t.enableVertexAttribArray(this.aBase), s.layoutVertexBuffer.bind(), t.vertexAttribPointer(this.aPos, 2, t.SHORT, !1, 12, 12 * a), t.vertexAttribPointer(this.aNormal, 4, t.SHORT, !1, 12, 4 + 12 * a), n.bind(), t.vertexAttribPointer(this.aHeight, 1, t.FLOAT, !1, 4, 4 * a), h.bind(), t.vertexAttribPointer(this.aBase, 1, t.FLOAT, !1, 4, 4 * a), s.indexBuffer.bind(), o.currentNumAttributes = r, t.drawElements(t.TRIANGLES, 3 * i.primitiveLength, t.UNSIGNED_SHORT, 3 * i.primitiveOffset * 2) } } } } module.exports = exports = BuildingShadows;

    }, { "../../utils/suncalc.js": 26 }],
    10: [function(require, module, exports) {
        const Objects = require("./objects.js"),
            utils = require("../utils/utils.js"),
            THREE = require("../three.js"),
            Object3D = require("./Object3D.js");

        function extrusion(e) { e = utils._validate(e, Objects.prototype._defaults.extrusion); let t = extrusion.prototype.buildShape(e.coordinates),
                o = extrusion.prototype.buildGeometry(t, e.geometryOptions),
                r = new THREE.Mesh(o, e.materials); return e.obj = r, new Object3D(e) } extrusion.prototype = { buildShape: function(e) { if (e[0] instanceof(THREE.Vector2 || THREE.Vector3)) return new THREE.Shape(e); let t = new THREE.Shape; for (let o = 0; o < e.length; o++) 0 === o ? t = new THREE.Shape(this.buildPoints(e[0], e[0])) : t.holes.push(new THREE.Path(this.buildPoints(e[o], e[0]))); return t }, buildPoints: function(e, t) { const o = []; let r = utils.projectToWorld([t[0][0], t[0][1], 0]); for (let t = 0; t < e.length; t++) { let i = utils.projectToWorld([e[t][0], e[t][1], 0]);
                    o.push(new THREE.Vector2(utils.toDecimal(i.x - r.x, 9), utils.toDecimal(i.y - r.y, 9))) } return o }, buildGeometry: function(e, t) { let o = new THREE.ExtrudeBufferGeometry(e, t); return o.computeBoundingBox(), o } }, module.exports = exports = extrusion;

    }, { "../three.js": 23, "../utils/utils.js": 27, "./Object3D.js": 7, "./objects.js": 19 }],
    11: [function(require, module, exports) {
        const utils = require("../utils/utils.js"),
            Objects = require("./objects.js"),
            CSS2D = require("./CSS2DRenderer.js");

        function Label(e) { e = utils._validate(e, Objects.prototype._defaults.label); let s = Objects.prototype.drawLabelHTML(e.htmlElement, e.cssClass),
                t = new CSS2D.CSS2DObject(s);
            t.name = "label", t.visible = e.alwaysVisible, t.alwaysVisible = e.alwaysVisible; var l = Objects.prototype._makeGroup(t, e); return Objects.prototype._addMethods(l), l.visibility = e.alwaysVisible, l } module.exports = exports = Label;

    }, { "../utils/utils.js": 27, "./CSS2DRenderer.js": 5, "./objects.js": 19 }],
    12: [function(require, module, exports) {
        const THREE = require("../three.js"),
            utils = require("../utils/utils.js"),
            Objects = require("./objects.js");

        function line(t) { t = utils._validate(t, Objects.prototype._defaults.line); var e = utils.lnglatsToWorld(t.geometry),
                n = utils.normalizeVertices(e),
                i = utils.flattenVectors(n.vertices);
            console.log("line", n.vertices); var r = new THREE.LineGeometry; return r.setPositions(i), matLine = new THREE.LineMaterial({ color: t.color, linewidth: t.width, dashed: !1, opacity: t.opacity }), matLine.resolution.set(window.innerWidth, window.innerHeight), matLine.isMaterial = !0, matLine.transparent = !0, matLine.depthWrite = !1, (line = new THREE.Line2(r, matLine)).position.copy(n.position), line.computeLineDistances(), line } module.exports = exports = line, THREE.LineSegmentsGeometry = function() { THREE.InstancedBufferGeometry.call(this), this.type = "LineSegmentsGeometry";
            new THREE.BufferGeometry;
            this.setIndex([0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]), this.setAttribute("position", new THREE.Float32BufferAttribute([-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], 3)), this.setAttribute("uv", new THREE.Float32BufferAttribute([0, 1, 1, 1, 0, .5, 1, .5, 0, .5, 1, .5, 0, 0, 1, 0], 2)) }, THREE.LineSegmentsGeometry.prototype = Object.assign(Object.create(THREE.InstancedBufferGeometry.prototype), { constructor: THREE.LineSegmentsGeometry, isLineSegmentsGeometry: !0, applyMatrix: function(t) { var e = this.attributes.instanceStart,
                    n = this.attributes.instanceEnd; return void 0 !== e && (t.applyToBufferAttribute(e), t.applyToBufferAttribute(n), e.data.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this }, setPositions: function(t) { var e;
                t instanceof Float32Array ? e = t : Array.isArray(t) && (e = new Float32Array(t)); var n = new THREE.InstancedInterleavedBuffer(e, 6, 1); return this.setAttribute("instanceStart", new THREE.InterleavedBufferAttribute(n, 3, 0)), this.setAttribute("instanceEnd", new THREE.InterleavedBufferAttribute(n, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this }, setColors: function(t) { var e;
                t instanceof Float32Array ? e = t : Array.isArray(t) && (e = new Float32Array(t)); var n = new THREE.InstancedInterleavedBuffer(e, 6, 1); return this.setAttribute("instanceColorStart", new THREE.InterleavedBufferAttribute(n, 3, 0)), this.setAttribute("instanceColorEnd", new THREE.InterleavedBufferAttribute(n, 3, 3)), this }, fromWireframeGeometry: function(t) { return this.setPositions(t.attributes.position.array), this }, fromEdgesGeometry: function(t) { return this.setPositions(t.attributes.position.array), this }, fromMesh: function(t) { return this.fromWireframeGeometry(new THREE.WireframeGeometry(t.geometry)), this }, fromLineSegements: function(t) { var e = t.geometry; return e.isGeometry ? this.setPositions(e.vertices) : e.isBufferGeometry && this.setPositions(e.position.array), this }, computeBoundingBox: function() { var t = new THREE.Box3; return function() { null === this.boundingBox && (this.boundingBox = new THREE.Box3); var e = this.attributes.instanceStart,
                        n = this.attributes.instanceEnd;
                    void 0 !== e && void 0 !== n && (this.boundingBox.setFromBufferAttribute(e), t.setFromBufferAttribute(n), this.boundingBox.union(t)) } }(), computeBoundingSphere: function() { var t = new THREE.Vector3; return function() { null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere), null === this.boundingBox && this.computeBoundingBox(); var e = this.attributes.instanceStart,
                        n = this.attributes.instanceEnd; if (void 0 !== e && void 0 !== n) { var i = this.boundingSphere.center;
                        this.boundingBox.getCenter(i); for (var r = 0, o = 0, a = e.count; o < a; o++) t.fromBufferAttribute(e, o), r = Math.max(r, i.distanceToSquared(t)), t.fromBufferAttribute(n, o), r = Math.max(r, i.distanceToSquared(t));
                        this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this) } } }(), toJSON: function() {}, clone: function() {}, copy: function(t) { return this } }), THREE.LineGeometry = function() { THREE.LineSegmentsGeometry.call(this), this.type = "LineGeometry" }, THREE.LineGeometry.prototype = Object.assign(Object.create(THREE.LineSegmentsGeometry.prototype), { constructor: THREE.LineGeometry, isLineGeometry: !0, setPositions: function(t) { for (var e = t.length - 3, n = new Float32Array(2 * e), i = 0; i < e; i += 3) n[2 * i] = t[i], n[2 * i + 1] = t[i + 1], n[2 * i + 2] = t[i + 2], n[2 * i + 3] = t[i + 3], n[2 * i + 4] = t[i + 4], n[2 * i + 5] = t[i + 5]; return THREE.LineSegmentsGeometry.prototype.setPositions.call(this, n), this }, setColors: function(t) { for (var e = t.length - 3, n = new Float32Array(2 * e), i = 0; i < e; i += 3) n[2 * i] = t[i], n[2 * i + 1] = t[i + 1], n[2 * i + 2] = t[i + 2], n[2 * i + 3] = t[i + 3], n[2 * i + 4] = t[i + 4], n[2 * i + 5] = t[i + 5]; return THREE.LineSegmentsGeometry.prototype.setColors.call(this, n), this }, fromLine: function(t) { var e = t.geometry; return e.isGeometry ? this.setPositions(e.vertices) : e.isBufferGeometry && this.setPositions(e.position.array), this }, copy: function(t) { return this } }), THREE.WireframeGeometry2 = function(t) { THREE.LineSegmentsGeometry.call(this), this.type = "WireframeGeometry2", this.fromWireframeGeometry(new THREE.WireframeGeometry(t)) }, THREE.WireframeGeometry2.prototype = Object.assign(Object.create(THREE.LineSegmentsGeometry.prototype), { constructor: THREE.WireframeGeometry2, isWireframeGeometry2: !0, copy: function(t) { return this } }), THREE.UniformsLib.line = { linewidth: { value: 1 }, resolution: { value: new THREE.Vector2(1, 1) }, dashScale: { value: 1 }, dashSize: { value: 1 }, gapSize: { value: 1 } }, THREE.ShaderLib.line = { uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.line]), vertexShader: "\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t\t#include <worldpos_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t", fragmentShader: "\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < 0.5 || vUv.y > 0.5 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tif ( vUv.y < 0.5 || vUv.y > 0.5 ) {\n\n\t\t\t\tfloat a = vUv.x - 0.5;\n\t\t\t\tfloat b = vUv.y - 0.5;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 0.25 ) discard;\n\n\t\t\t}\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, opacity );\n\n\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\n\t\t}\n\t\t" }, THREE.LineMaterial = function(t) { var e = THREE.UniformsUtils.clone(THREE.ShaderLib.line.uniforms);
            e.opacity.value = t.opacity, THREE.ShaderMaterial.call(this, { type: "LineMaterial", uniforms: e, vertexShader: THREE.ShaderLib.line.vertexShader, fragmentShader: THREE.ShaderLib.line.fragmentShader }), this.dashed = !1, Object.defineProperties(this, { color: { enumerable: !0, get: function() { return this.uniforms.diffuse.value }, set: function(t) { this.uniforms.diffuse.value = t } }, linewidth: { enumerable: !0, get: function() { return this.uniforms.linewidth.value }, set: function(t) { this.uniforms.linewidth.value = t } }, dashScale: { enumerable: !0, get: function() { return this.uniforms.dashScale.value }, set: function(t) { this.uniforms.dashScale.value = t } }, dashSize: { enumerable: !0, get: function() { return this.uniforms.dashSize.value }, set: function(t) { this.uniforms.dashSize.value = t } }, gapSize: { enumerable: !0, get: function() { return this.uniforms.gapSize.value }, set: function(t) { this.uniforms.gapSize.value = t } }, resolution: { enumerable: !0, get: function() { return this.uniforms.resolution.value }, set: function(t) { this.uniforms.resolution.value.copy(t) } } }), this.setValues(t) }, THREE.LineMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype), THREE.LineMaterial.prototype.constructor = THREE.LineMaterial, THREE.LineMaterial.prototype.isLineMaterial = !0, THREE.LineMaterial.prototype.copy = function(t) { return THREE.ShaderMaterial.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.resolution = t.resolution, this }, THREE.LineSegments2 = function(t, e) { THREE.Mesh.call(this), this.type = "LineSegments2", this.geometry = void 0 !== t ? t : new THREE.LineSegmentsGeometry, this.material = void 0 !== e ? e : new THREE.LineMaterial({ color: 16777215 * Math.random() }) }, THREE.LineSegments2.prototype = Object.assign(Object.create(THREE.Mesh.prototype), { constructor: THREE.LineSegments2, isLineSegments2: !0, computeLineDistances: function() { var t = new THREE.Vector3,
                    e = new THREE.Vector3; return function() { for (var n = this.geometry, i = n.attributes.instanceStart, r = n.attributes.instanceEnd, o = new Float32Array(2 * i.data.count), a = 0, s = 0, c = i.data.count; a < c; a++, s += 2) t.fromBufferAttribute(i, a), e.fromBufferAttribute(r, a), o[s] = 0 === s ? 0 : o[s - 1], o[s + 1] = o[s] + t.distanceTo(e); var u = new THREE.InstancedInterleavedBuffer(o, 2, 1); return n.setAttribute("instanceDistanceStart", new THREE.InterleavedBufferAttribute(u, 1, 0)), n.setAttribute("instanceDistanceEnd", new THREE.InterleavedBufferAttribute(u, 1, 1)), this } }(), copy: function(t) { return this } }), THREE.Line2 = function(t, e) { THREE.LineSegments2.call(this), this.type = "Line2", this.geometry = void 0 !== t ? t : new THREE.LineGeometry, this.material = void 0 !== e ? e : new THREE.LineMaterial({ color: 16777215 * Math.random() }) }, THREE.Line2.prototype = Object.assign(Object.create(THREE.LineSegments2.prototype), { constructor: THREE.Line2, isLine2: !0, copy: function(t) { return this } }), THREE.Wireframe = function(t, e) { THREE.Mesh.call(this), this.type = "Wireframe", this.geometry = void 0 !== t ? t : new THREE.LineSegmentsGeometry, this.material = void 0 !== e ? e : new THREE.LineMaterial({ color: 16777215 * Math.random() }) }, THREE.Wireframe.prototype = Object.assign(Object.create(THREE.Mesh.prototype), { constructor: THREE.Wireframe, isWireframe: !0, computeLineDistances: function() { var t = new THREE.Vector3,
                    e = new THREE.Vector3; return function() { for (var n = this.geometry, i = n.attributes.instanceStart, r = n.attributes.instanceEnd, o = new Float32Array(2 * i.data.count), a = 0, s = 0, c = i.data.count; a < c; a++, s += 2) t.fromBufferAttribute(i, a), e.fromBufferAttribute(r, a), o[s] = 0 === s ? 0 : o[s - 1], o[s + 1] = o[s] + t.distanceTo(e); var u = new THREE.InstancedInterleavedBuffer(o, 2, 1); return n.setAttribute("instanceDistanceStart", new THREE.InterleavedBufferAttribute(u, 1, 0)), n.setAttribute("instanceDistanceEnd", new THREE.InterleavedBufferAttribute(u, 1, 1)), this } }(), copy: function(t) { return this } });

    }, { "../three.js": 23, "../utils/utils.js": 27, "./objects.js": 19 }],
    13: [function(require, module, exports) {
        const utils = require("../utils/utils.js"),
            Objects = require("./objects.js"),
            OBJLoader = require("./loaders/OBJLoader.js"),
            MTLLoader = require("./loaders/MTLLoader.js"),
            FBXLoader = require("./loaders/FBXLoader.js"),
            GLTFLoader = require("./loaders/GLTFLoader.js"),
            ColladaLoader = require("./loaders/ColladaLoader.js"),
            objLoader = new OBJLoader,
            materialLoader = new MTLLoader,
            gltfLoader = new GLTFLoader,
            fbxLoader = new FBXLoader,
            daeLoader = new ColladaLoader;

        function loadObj(e, a, o) { if (void 0 === e) return console.error("Invalid options provided to loadObj()"); let r; switch ((e = utils._validate(e, Objects.prototype._defaults.loadObj)).type || (e.type = "mtl"), e.type) {
                case "mtl":
                    r = objLoader; break;
                case "gltf":
                case "glb":
                    r = gltfLoader; break;
                case "fbx":
                    r = fbxLoader; break;
                case "dae":
                    r = daeLoader } materialLoader.load(e.mtl, function(t) { t && "mtl" == e.type && (t.preload(), r.setMaterials(t));
                r.load(e.obj, r => { let t = []; switch (e.type) {
                        case "mtl":
                            r = r.children[0]; break;
                        case "gltf":
                        case "glb":
                        case "dae":
                            t = r.animations, r = r.scene; break;
                        case "fbx":
                            t = r.animations } r.animations = t; const l = utils.types.rotation(e.rotation, [0, 0, 0]),
                        s = utils.types.scale(e.scale, [1, 1, 1]);
                    r.rotation.set(l[0], l[1], l[2]), r.scale.set(s[0], s[1], s[2]), e.normalize && function(e) { e.traverse(function(e) { if (e.isMesh) { let a; "MeshStandardMaterial" == e.material.type ? (e.material.metalness && (e.material.metalness *= .1), e.material.glossiness && (e.material.glossiness *= .25), a = new THREE.Color(12, 12, 12)) : "MeshPhongMaterial" == e.material.type && (e.material.shininess = .1, a = new THREE.Color(20, 20, 20)), e.material.specular && e.material.specular.isColor && (e.material.specular = a) } }) }(r), r.name = "model"; let d = Objects.prototype._makeGroup(r, e);
                    Objects.prototype._addMethods(d), d.setAnchor(e.anchor), d.setCenter(e.adjustment), d.raycasted = e.raycasted, o(d), a(d), d.idle() }, () => null, a => { console.error("Could not load model file: " + e.obj + " \n " + a.stack), o("Error loading the model") }) }, () => null, e => { console.warn("No material file found for SymbolLayer3D model " + m) }) } module.exports = exports = loadObj;

    }, { "../utils/utils.js": 27, "./loaders/ColladaLoader.js": 14, "./loaders/FBXLoader.js": 15, "./loaders/GLTFLoader.js": 16, "./loaders/MTLLoader.js": 17, "./loaders/OBJLoader.js": 18, "./objects.js": 19 }],
    14: [function(require, module, exports) {
        const THREE = require("../../three.js");
        THREE.ColladaLoader = function(e) { THREE.Loader.call(this, e) }, THREE.ColladaLoader.prototype = Object.assign(Object.create(THREE.Loader.prototype), { constructor: THREE.ColladaLoader, load: function(e, t, r, a) { var n = this,
                    i = "" === n.path ? THREE.LoaderUtils.extractUrlBase(e) : n.path,
                    s = new THREE.FileLoader(n.manager);
                s.setPath(n.path), s.load(e, function(r) { try { t(n.parse(r, i)) } catch (t) { a ? a(t) : console.error(t), n.manager.itemError(e) } }, r, a) }, options: { set convertUpAxis(e) { console.warn("THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.") } }, parse: function(e, t) {
                function r(e, t) { for (var r = [], a = e.childNodes, n = 0, i = a.length; n < i; n++) { var s = a[n];
                        s.nodeName === t && r.push(s) } return r }

                function a(e) { if (0 === e.length) return []; for (var t = e.trim().split(/\s+/), r = new Array(t.length), a = 0, n = t.length; a < n; a++) r[a] = t[a]; return r }

                function n(e) { if (0 === e.length) return []; for (var t = e.trim().split(/\s+/), r = new Array(t.length), a = 0, n = t.length; a < n; a++) r[a] = parseFloat(t[a]); return r }

                function i(e) { if (0 === e.length) return []; for (var t = e.trim().split(/\s+/), r = new Array(t.length), a = 0, n = t.length; a < n; a++) r[a] = parseInt(t[a]); return r }

                function s(e) { return e.substring(1) }

                function o(e) { return 0 === Object.keys(e).length }

                function c(e) { return void 0 !== e && !0 === e.hasAttribute("meter") ? parseFloat(e.getAttribute("meter")) : 1 }

                function l(e) { return void 0 !== e ? e.textContent : "Y_UP" }

                function d(e, t, a, n) { var i = r(e, t)[0]; if (void 0 !== i)
                        for (var s = r(i, a), o = 0; o < s.length; o++) n(s[o]) }

                function u(e, t) { for (var r in e) { e[r].build = t(e[r]) } }

                function f(e, t) { return void 0 !== e.build ? e.build : (e.build = t(e), e.build) }

                function h(e) { for (var t = { inputs: {} }, r = 0, a = e.childNodes.length; r < a; r++) { var n = e.childNodes[r]; if (1 === n.nodeType) switch (n.nodeName) {
                            case "input":
                                var i = s(n.getAttribute("source")),
                                    o = n.getAttribute("semantic");
                                t.inputs[o] = i } } return t }

                function m(e) { var t = {},
                        r = e.getAttribute("target").split("/"),
                        a = r.shift(),
                        n = r.shift(),
                        i = -1 !== n.indexOf("("),
                        o = -1 !== n.indexOf("."); if (o) r = n.split("."), n = r.shift(), t.member = r.shift();
                    else if (i) { var c = n.split("(");
                        n = c.shift(); for (var l = 0; l < c.length; l++) c[l] = parseInt(c[l].replace(/\)/, ""));
                        t.indices = c } return t.id = a, t.sid = n, t.arraySyntax = i, t.memberSyntax = o, t.sampler = s(e.getAttribute("source")), t }

                function p(e) { var t = [],
                        r = e.channels,
                        a = e.samplers,
                        n = e.sources; for (var i in r)
                        if (r.hasOwnProperty(i)) { var s = r[i],
                                o = a[s.sampler],
                                c = o.inputs.INPUT,
                                l = o.inputs.OUTPUT;
                            N(g(s, n[c], n[l]), t) } return t }

                function v(e) { return f(Ke.animations[e], p) }

                function g(e, t, r) { var a, n, i, s, o, c, l = Ke.nodes[e.id],
                        d = Ie(l.id),
                        u = l.transforms[e.sid],
                        f = l.matrix.clone().transpose(),
                        h = {}; switch (u) {
                        case "matrix":
                            for (i = 0, s = t.array.length; i < s; i++)
                                if (a = t.array[i], n = i * r.stride, void 0 === h[a] && (h[a] = {}), !0 === e.arraySyntax) { var m = r.array[n],
                                        p = e.indices[0] + 4 * e.indices[1];
                                    h[a][p] = m } else
                                    for (o = 0, c = r.stride; o < c; o++) h[a][o] = r.array[n + o]; break;
                        case "translate":
                        case "rotate":
                        case "scale":
                            console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', u) } var v = function(e, t) { var r = []; for (var a in e) r.push({ time: parseFloat(a), value: e[a] });
                        r.sort(function(e, t) { return e.time - t.time }); for (var n = 0; n < 16; n++) T(r, n, t.elements[n]); return r }(h, f); return { name: d.uuid, keyframes: v } } var b = new THREE.Vector3,
                    y = new THREE.Vector3,
                    E = new THREE.Quaternion;

                function N(e, t) { for (var r = e.keyframes, a = e.name, n = [], i = [], s = [], o = [], c = 0, l = r.length; c < l; c++) { var d = r[c],
                            u = d.time,
                            f = d.value;
                        xe.fromArray(f).transpose(), xe.decompose(b, E, y), n.push(u), i.push(b.x, b.y, b.z), s.push(E.x, E.y, E.z, E.w), o.push(y.x, y.y, y.z) } return i.length > 0 && t.push(new THREE.VectorKeyframeTrack(a + ".position", n, i)), s.length > 0 && t.push(new THREE.QuaternionKeyframeTrack(a + ".quaternion", n, s)), o.length > 0 && t.push(new THREE.VectorKeyframeTrack(a + ".scale", n, o)), t }

                function T(e, t, r) { var a, n, i, s = !0; for (n = 0, i = e.length; n < i; n++) void 0 === (a = e[n]).value[t] ? a.value[t] = null : s = !1; if (!0 === s)
                        for (n = 0, i = e.length; n < i; n++)(a = e[n]).value[t] = r;
                    else ! function(e, t) { for (var r, a, n = 0, i = e.length; n < i; n++) { var s = e[n]; if (null === s.value[t]) { if (r = w(e, n, t), a = x(e, n, t), null === r) { s.value[t] = a.value[t]; continue } if (null === a) { s.value[t] = r.value[t]; continue } k(s, r, a, t) } } }(e, t) }

                function w(e, t, r) { for (; t >= 0;) { var a = e[t]; if (null !== a.value[r]) return a;
                        t-- } return null }

                function x(e, t, r) { for (; t < e.length;) { var a = e[t]; if (null !== a.value[r]) return a;
                        t++ } return null }

                function k(e, t, r, a) { r.time - t.time != 0 ? e.value[a] = (e.time - t.time) * (r.value[a] - t.value[a]) / (r.time - t.time) + t.value[a] : e.value[a] = t.value[a] }

                function A(e) { for (var t = [], r = e.name, a = e.end - e.start || -1, n = e.animations, i = 0, s = n.length; i < s; i++)
                        for (var o = v(n[i]), c = 0, l = o.length; c < l; c++) t.push(o[c]); return new THREE.AnimationClip(r, a, t) }

                function R(e) { return f(Ke.clips[e], A) }

                function H(e) { for (var t = { sources: {} }, r = 0, a = e.childNodes.length; r < a; r++) { var i = e.childNodes[r]; if (1 === i.nodeType) switch (i.nodeName) {
                            case "bind_shape_matrix":
                                t.bindShapeMatrix = n(i.textContent); break;
                            case "source":
                                var s = i.getAttribute("id");
                                t.sources[s] = ne(i); break;
                            case "joints":
                                t.joints = C(i); break;
                            case "vertex_weights":
                                t.vertexWeights = _(i) } } return t }

                function C(e) { for (var t = { inputs: {} }, r = 0, a = e.childNodes.length; r < a; r++) { var n = e.childNodes[r]; if (1 === n.nodeType) switch (n.nodeName) {
                            case "input":
                                var i = n.getAttribute("semantic"),
                                    o = s(n.getAttribute("source"));
                                t.inputs[i] = o } } return t }

                function _(e) { for (var t = { inputs: {} }, r = 0, a = e.childNodes.length; r < a; r++) { var n = e.childNodes[r]; if (1 === n.nodeType) switch (n.nodeName) {
                            case "input":
                                var o = n.getAttribute("semantic"),
                                    c = s(n.getAttribute("source")),
                                    l = parseInt(n.getAttribute("offset"));
                                t.inputs[o] = { id: c, offset: l }; break;
                            case "vcount":
                                t.vcount = i(n.textContent); break;
                            case "v":
                                t.v = i(n.textContent) } } return t }

                function M(e) { var t = { id: e.id },
                        r = Ke.geometries[t.id]; return void 0 !== e.skin && (t.skin = function(e) { var t, r, a, n = { joints: [], indices: { array: [], stride: 4 }, weights: { array: [], stride: 4 } },
                            i = e.sources,
                            s = e.vertexWeights,
                            o = s.vcount,
                            c = s.v,
                            l = s.inputs.JOINT.offset,
                            d = s.inputs.WEIGHT.offset,
                            u = e.sources[e.joints.inputs.JOINT],
                            f = e.sources[e.joints.inputs.INV_BIND_MATRIX],
                            h = i[s.inputs.WEIGHT.id].array,
                            m = 0; for (t = 0, a = o.length; t < a; t++) { var p = o[t],
                                v = []; for (r = 0; r < p; r++) { var g = c[m + l],
                                    b = c[m + d],
                                    y = h[b];
                                v.push({ index: g, weight: y }), m += 2 } for (v.sort(w), r = 0; r < 4; r++) { var E = v[r];
                                void 0 !== E ? (n.indices.array.push(E.index), n.weights.array.push(E.weight)) : (n.indices.array.push(0), n.weights.array.push(0)) } } e.bindShapeMatrix ? n.bindMatrix = (new THREE.Matrix4).fromArray(e.bindShapeMatrix).transpose() : n.bindMatrix = (new THREE.Matrix4).identity(); for (t = 0, a = u.array.length; t < a; t++) { var N = u.array[t],
                                T = (new THREE.Matrix4).fromArray(f.array, t * f.stride).transpose();
                            n.joints.push({ name: N, boneInverse: T }) } return n;

                        function w(e, t) { return t.weight - e.weight } }(e.skin), r.sources.skinIndices = t.skin.indices, r.sources.skinWeights = t.skin.weights), t }

                function L(e) { return void 0 !== e.build ? e.build : e.init_from }

                function O(e) { var t = Ke.images[e]; return void 0 !== t ? f(t, L) : (console.warn("THREE.ColladaLoader: Couldn't find image with ID:", e), null) }

                function j(e) { for (var t = { surfaces: {}, samplers: {} }, r = 0, a = e.childNodes.length; r < a; r++) { var n = e.childNodes[r]; if (1 === n.nodeType) switch (n.nodeName) {
                            case "newparam":
                                I(n, t); break;
                            case "technique":
                                t.technique = S(n); break;
                            case "extra":
                                t.extra = z(n) } } return t }

                function I(e, t) { for (var r = e.getAttribute("sid"), a = 0, n = e.childNodes.length; a < n; a++) { var i = e.childNodes[a]; if (1 === i.nodeType) switch (i.nodeName) {
                            case "surface":
                                t.surfaces[r] = q(i); break;
                            case "sampler2D":
                                t.samplers[r] = U(i) } } }

                function q(e) { for (var t = {}, r = 0, a = e.childNodes.length; r < a; r++) { var n = e.childNodes[r]; if (1 === n.nodeType) switch (n.nodeName) {
                            case "init_from":
                                t.init_from = n.textContent } } return t }

                function U(e) { for (var t = {}, r = 0, a = e.childNodes.length; r < a; r++) { var n = e.childNodes[r]; if (1 === n.nodeType) switch (n.nodeName) {
                            case "source":
                                t.source = n.textContent } } return t }

                function S(e) { for (var t = {}, r = 0, a = e.childNodes.length; r < a; r++) { var n = e.childNodes[r]; if (1 === n.nodeType) switch (n.nodeName) {
                            case "constant":
                            case "lambert":
                            case "blinn":
                            case "phong":
                                t.type = n.nodeName, t.parameters = B(n) } } return t }

                function B(e) { for (var t = {}, r = 0, a = e.childNodes.length; r < a; r++) { var n = e.childNodes[r]; if (1 === n.nodeType) switch (n.nodeName) {
                            case "emission":
                            case "diffuse":
                            case "specular":
                            case "bump":
                            case "ambient":
                            case "shininess":
                            case "transparency":
                                t[n.nodeName] = F(n); break;
                            case "transparent":
                                t[n.nodeName] = { opaque: n.getAttribute("opaque"), data: F(n) } } } return t }

                function F(e) { for (var t = {}, r = 0, a = e.childNodes.length; r < a; r++) { var i = e.childNodes[r]; if (1 === i.nodeType) switch (i.nodeName) {
                            case "color":
                                t[i.nodeName] = n(i.textContent); break;
                            case "float":
                                t[i.nodeName] = parseFloat(i.textContent); break;
                            case "texture":
                                t[i.nodeName] = { id: i.getAttribute("texture"), extra: V(i) } } } return t }

                function V(e) { for (var t = { technique: {} }, r = 0, a = e.childNodes.length; r < a; r++) { var n = e.childNodes[r]; if (1 === n.nodeType) switch (n.nodeName) {
                            case "extra":
                                P(n, t) } } return t }

                function P(e, t) { for (var r = 0, a = e.childNodes.length; r < a; r++) { var n = e.childNodes[r]; if (1 === n.nodeType) switch (n.nodeName) {
                            case "technique":
                                D(n, t) } } }

                function D(e, t) { for (var r = 0, a = e.childNodes.length; r < a; r++) { var n = e.childNodes[r]; if (1 === n.nodeType) switch (n.nodeName) {
                            case "repeatU":
                            case "repeatV":
                            case "offsetU":
                            case "offsetV":
                                t.technique[n.nodeName] = parseFloat(n.textContent); break;
                            case "wrapU":
                            case "wrapV":
                                "TRUE" === n.textContent.toUpperCase() ? t.technique[n.nodeName] = 1 : "FALSE" === n.textContent.toUpperCase() ? t.technique[n.nodeName] = 0 : t.technique[n.nodeName] = parseInt(n.textContent) } } }

                function z(e) { for (var t = {}, r = 0, a = e.childNodes.length; r < a; r++) { var n = e.childNodes[r]; if (1 === n.nodeType) switch (n.nodeName) {
                            case "technique":
                                t.technique = W(n) } } return t }

                function W(e) { for (var t = {}, r = 0, a = e.childNodes.length; r < a; r++) { var n = e.childNodes[r]; if (1 === n.nodeType) switch (n.nodeName) {
                            case "double_sided":
                                t[n.nodeName] = parseInt(n.textContent) } } return t }

                function G(e) { return e }

                function J(e) { var t, r, a = (t = e.url, f(Ke.effects[t], G)),
                        n = a.profile.technique,
                        i = a.profile.extra; switch (n.type) {
                        case "phong":
                        case "blinn":
                            r = new THREE.MeshPhongMaterial; break;
                        case "lambert":
                            r = new THREE.MeshLambertMaterial; break;
                        default:
                            r = new THREE.MeshBasicMaterial }

                    function s(e) { var t = a.profile.samplers[e.id],
                            r = null;
                        void 0 !== t ? r = O(a.profile.surfaces[t.source].init_from) : (console.warn("THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530)."), r = O(e.id)); if (null !== r) { var n = function(e) { var t, r = e.slice(2 + (e.lastIndexOf(".") - 1 >>> 0)); switch (r = r.toLowerCase()) {
                                    case "tga":
                                        t = De; break;
                                    default:
                                        t = We } return t }(r); if (void 0 !== n) { var i = n.load(r),
                                    s = e.extra; if (void 0 !== s && void 0 !== s.technique && !1 === o(s.technique)) { var c = s.technique;
                                    i.wrapS = c.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping, i.wrapT = c.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping, i.offset.set(c.offsetU || 0, c.offsetV || 0), i.repeat.set(c.repeatU || 1, c.repeatV || 1) } else i.wrapS = THREE.RepeatWrapping, i.wrapT = THREE.RepeatWrapping; return i } return console.warn("THREE.ColladaLoader: Loader for texture %s not found.", r), null } return console.warn("THREE.ColladaLoader: Couldn't create texture with ID:", e.id), null } r.name = e.name || ""; var c = n.parameters; for (var l in c) { var d = c[l]; switch (l) {
                            case "diffuse":
                                d.color && r.color.fromArray(d.color), d.texture && (r.map = s(d.texture)); break;
                            case "specular":
                                d.color && r.specular && r.specular.fromArray(d.color), d.texture && (r.specularMap = s(d.texture)); break;
                            case "bump":
                                d.texture && (r.normalMap = s(d.texture)); break;
                            case "ambient":
                                d.texture && (r.lightMap = s(d.texture)); break;
                            case "shininess":
                                d.float && r.shininess && (r.shininess = d.float); break;
                            case "emission":
                                d.color && r.emissive && r.emissive.fromArray(d.color), d.texture && (r.emissiveMap = s(d.texture)) } } var u = c.transparent,
                        h = c.transparency; if (void 0 === h && u && (h = { float: 1 }), void 0 === u && h && (u = { opaque: "A_ONE", data: { color: [1, 1, 1, 1] } }), u && h)
                        if (u.data.texture) r.transparent = !0;
                        else { var m = u.data.color; switch (u.opaque) {
                                case "A_ONE":
                                    r.opacity = m[3] * h.float; break;
                                case "RGB_ZERO":
                                    r.opacity = 1 - m[0] * h.float; break;
                                case "A_ZERO":
                                    r.opacity = 1 - m[3] * h.float; break;
                                case "RGB_ONE":
                                    r.opacity = m[0] * h.float; break;
                                default:
                                    console.warn('THREE.ColladaLoader: Invalid opaque type "%s" of transparent tag.', u.opaque) } r.opacity < 1 && (r.transparent = !0) } return void 0 !== i && void 0 !== i.technique && 1 === i.technique.double_sided && (r.side = THREE.DoubleSide), r }

                function X(e) { return f(Ke.materials[e], J) }

                function K(e) { for (var t = 0; t < e.childNodes.length; t++) { var r = e.childNodes[t]; switch (r.nodeName) {
                            case "technique_common":
                                return Z(r) } } return {} }

                function Z(e) { for (var t = {}, r = 0; r < e.childNodes.length; r++) { var a = e.childNodes[r]; switch (a.nodeName) {
                            case "perspective":
                            case "orthographic":
                                t.technique = a.nodeName, t.parameters = Q(a) } } return t }

                function Q(e) { for (var t = {}, r = 0; r < e.childNodes.length; r++) { var a = e.childNodes[r]; switch (a.nodeName) {
                            case "xfov":
                            case "yfov":
                            case "xmag":
                            case "ymag":
                            case "znear":
                            case "zfar":
                            case "aspect_ratio":
                                t[a.nodeName] = parseFloat(a.textContent) } } return t }

                function Y(e) { var t; switch (e.optics.technique) {
                        case "perspective":
                            t = new THREE.PerspectiveCamera(e.optics.parameters.yfov, e.optics.parameters.aspect_ratio, e.optics.parameters.znear, e.optics.parameters.zfar); break;
                        case "orthographic":
                            var r = e.optics.parameters.ymag,
                                a = e.optics.parameters.xmag,
                                n = e.optics.parameters.aspect_ratio;
                            a = void 0 === a ? r * n : a, r = void 0 === r ? a / n : r, a *= .5, r *= .5, t = new THREE.OrthographicCamera(-a, a, r, -r, e.optics.parameters.znear, e.optics.parameters.zfar); break;
                        default:
                            t = new THREE.PerspectiveCamera } return t.name = e.name || "", t }

                function $(e) { var t = Ke.cameras[e]; return void 0 !== t ? f(t, Y) : (console.warn("THREE.ColladaLoader: Couldn't find camera with ID:", e), null) }

                function ee(e) { for (var t = {}, r = 0, a = e.childNodes.length; r < a; r++) { var n = e.childNodes[r]; if (1 === n.nodeType) switch (n.nodeName) {
                            case "directional":
                            case "point":
                            case "spot":
                            case "ambient":
                                t.technique = n.nodeName, t.parameters = te(n) } } return t }

                function te(e) { for (var t = {}, r = 0, a = e.childNodes.length; r < a; r++) { var i = e.childNodes[r]; if (1 === i.nodeType) switch (i.nodeName) {
                            case "color":
                                var s = n(i.textContent);
                                t.color = (new THREE.Color).fromArray(s); break;
                            case "falloff_angle":
                                t.falloffAngle = parseFloat(i.textContent); break;
                            case "quadratic_attenuation":
                                var o = parseFloat(i.textContent);
                                t.distance = o ? Math.sqrt(1 / o) : 0 } } return t }

                function re(e) { var t; switch (e.technique) {
                        case "directional":
                            t = new THREE.DirectionalLight; break;
                        case "point":
                            t = new THREE.PointLight; break;
                        case "spot":
                            t = new THREE.SpotLight; break;
                        case "ambient":
                            t = new THREE.AmbientLight } return e.parameters.color && t.color.copy(e.parameters.color), e.parameters.distance && (t.distance = e.parameters.distance), t }

                function ae(e) { var t = Ke.lights[e]; return void 0 !== t ? f(t, re) : (console.warn("THREE.ColladaLoader: Couldn't find light with ID:", e), null) }

                function ne(e) { for (var t = { array: [], stride: 3 }, i = 0; i < e.childNodes.length; i++) { var s = e.childNodes[i]; if (1 === s.nodeType) switch (s.nodeName) {
                            case "float_array":
                                t.array = n(s.textContent); break;
                            case "Name_array":
                                t.array = a(s.textContent); break;
                            case "technique_common":
                                var o = r(s, "accessor")[0];
                                void 0 !== o && (t.stride = parseInt(o.getAttribute("stride"))) } } return t }

                function ie(e) { for (var t = {}, r = 0; r < e.childNodes.length; r++) { var a = e.childNodes[r];
                        1 === a.nodeType && (t[a.getAttribute("semantic")] = s(a.getAttribute("source"))) } return t }

                function se(e) { for (var t = { type: e.nodeName, material: e.getAttribute("material"), count: parseInt(e.getAttribute("count")), inputs: {}, stride: 0, hasUV: !1 }, r = 0, a = e.childNodes.length; r < a; r++) { var n = e.childNodes[r]; if (1 === n.nodeType) switch (n.nodeName) {
                            case "input":
                                var o = s(n.getAttribute("source")),
                                    c = n.getAttribute("semantic"),
                                    l = parseInt(n.getAttribute("offset")),
                                    d = parseInt(n.getAttribute("set")),
                                    u = d > 0 ? c + d : c;
                                t.inputs[u] = { id: o, offset: l }, t.stride = Math.max(t.stride, l + 1), "TEXCOORD" === c && (t.hasUV = !0); break;
                            case "vcount":
                                t.vcount = i(n.textContent); break;
                            case "p":
                                t.p = i(n.textContent) } } return t }

                function oe(e) { for (var t = 0, r = 0, a = e.length; r < a; r++) {!0 === e[r].hasUV && t++ } t > 0 && t < e.length && (e.uvsNeedsFix = !0) }

                function ce(e) { var t = {},
                        r = e.sources,
                        a = e.vertices,
                        n = e.primitives; if (0 === n.length) return {}; var i = function(e) { for (var t = {}, r = 0; r < e.length; r++) { var a = e[r];
                            void 0 === t[a.type] && (t[a.type] = []), t[a.type].push(a) } return t }(n); for (var s in i) { var o = i[s];
                        oe(o), t[s] = le(o, r, a) } return t }

                function le(e, t, r) { for (var a = {}, n = { array: [], stride: 0 }, i = { array: [], stride: 0 }, s = { array: [], stride: 0 }, o = { array: [], stride: 0 }, c = { array: [], stride: 0 }, l = [], d = 4, u = [], f = 4, h = new THREE.BufferGeometry, m = [], p = 0, v = 0; v < e.length; v++) { var g = e[v],
                            b = g.inputs,
                            y = 0; switch (g.type) {
                            case "lines":
                            case "linestrips":
                                y = 2 * g.count; break;
                            case "triangles":
                                y = 3 * g.count; break;
                            case "polylist":
                                for (var E = 0; E < g.count; E++) { var N = g.vcount[E]; switch (N) {
                                        case 3:
                                            y += 3; break;
                                        case 4:
                                            y += 6; break;
                                        default:
                                            y += 3 * (N - 2) } } break;
                            default:
                                console.warn("THREE.ColladaLoader: Unknow primitive type:", g.type) } for (var T in h.addGroup(p, y, v), p += y, g.material && m.push(g.material), b) { var w = b[T]; switch (T) {
                                case "VERTEX":
                                    for (var x in r) { var k = r[x]; switch (x) {
                                            case "POSITION":
                                                var A = n.array.length; if (de(g, t[k], w.offset, n.array), n.stride = t[k].stride, t.skinWeights && t.skinIndices && (de(g, t.skinIndices, w.offset, l), de(g, t.skinWeights, w.offset, u)), !1 === g.hasUV && !0 === e.uvsNeedsFix) { y = (n.array.length - A) / n.stride; for (var R = 0; R < y; R++) s.array.push(0, 0) } break;
                                            case "NORMAL":
                                                de(g, t[k], w.offset, i.array), i.stride = t[k].stride; break;
                                            case "COLOR":
                                                de(g, t[k], w.offset, c.array), c.stride = t[k].stride; break;
                                            case "TEXCOORD":
                                                de(g, t[k], w.offset, s.array), s.stride = t[k].stride; break;
                                            case "TEXCOORD1":
                                                de(g, t[k], w.offset, o.array), s.stride = t[k].stride; break;
                                            default:
                                                console.warn('THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.', x) } } break;
                                case "NORMAL":
                                    de(g, t[w.id], w.offset, i.array), i.stride = t[w.id].stride; break;
                                case "COLOR":
                                    de(g, t[w.id], w.offset, c.array), c.stride = t[w.id].stride; break;
                                case "TEXCOORD":
                                    de(g, t[w.id], w.offset, s.array), s.stride = t[w.id].stride; break;
                                case "TEXCOORD1":
                                    de(g, t[w.id], w.offset, o.array), o.stride = t[w.id].stride } } } return n.array.length > 0 && h.setAttribute("position", new THREE.Float32BufferAttribute(n.array, n.stride)), i.array.length > 0 && h.setAttribute("normal", new THREE.Float32BufferAttribute(i.array, i.stride)), c.array.length > 0 && h.setAttribute("color", new THREE.Float32BufferAttribute(c.array, c.stride)), s.array.length > 0 && h.setAttribute("uv", new THREE.Float32BufferAttribute(s.array, s.stride)), o.array.length > 0 && h.setAttribute("uv2", new THREE.Float32BufferAttribute(o.array, o.stride)), l.length > 0 && h.setAttribute("skinIndex", new THREE.Float32BufferAttribute(l, d)), u.length > 0 && h.setAttribute("skinWeight", new THREE.Float32BufferAttribute(u, f)), a.data = h, a.type = e[0].type, a.materialKeys = m, a }

                function de(e, t, r, a) { var n = e.p,
                        i = e.stride,
                        s = e.vcount;

                    function o(e) { for (var t = n[e + r] * l, i = t + l; t < i; t++) a.push(c[t]) } var c = t.array,
                        l = t.stride; if (void 0 !== e.vcount)
                        for (var d = 0, u = 0, f = s.length; u < f; u++) { var h = s[u]; if (4 === h) { var m = d + 1 * i,
                                    p = d + 2 * i,
                                    v = d + 3 * i;
                                o(d + 0 * i), o(m), o(v), o(m), o(p), o(v) } else if (3 === h) { m = d + 1 * i, p = d + 2 * i;
                                o(d + 0 * i), o(m), o(p) } else if (h > 4)
                                for (var g = 1, b = h - 2; g <= b; g++) { m = d + i * g, p = d + i * (g + 1);
                                    o(d + 0 * i), o(m), o(p) } d += i * h } else
                            for (u = 0, f = n.length; u < f; u += i) o(u) }

                function ue(e) { return f(Ke.geometries[e], ce) }

                function fe(e) { return void 0 !== e.build ? e.build : e }

                function he(e, t) { for (var r = 0; r < e.childNodes.length; r++) { var a = e.childNodes[r]; if (1 === a.nodeType) switch (a.nodeName) {
                            case "joint":
                                t.joints[a.getAttribute("sid")] = me(a); break;
                            case "link":
                                t.links.push(ve(a)) } } }

                function me(e) { for (var t, r = 0; r < e.childNodes.length; r++) { var a = e.childNodes[r]; if (1 === a.nodeType) switch (a.nodeName) {
                            case "prismatic":
                            case "revolute":
                                t = pe(a) } } return t }

                function pe(e, t) { t = { sid: e.getAttribute("sid"), name: e.getAttribute("name") || "", axis: new THREE.Vector3, limits: { min: 0, max: 0 }, type: e.nodeName, static: !1, zeroPosition: 0, middlePosition: 0 }; for (var r = 0; r < e.childNodes.length; r++) { var a = e.childNodes[r]; if (1 === a.nodeType) switch (a.nodeName) {
                            case "axis":
                                var i = n(a.textContent);
                                t.axis.fromArray(i); break;
                            case "limits":
                                var s = a.getElementsByTagName("max")[0],
                                    o = a.getElementsByTagName("min")[0];
                                t.limits.max = parseFloat(s.textContent), t.limits.min = parseFloat(o.textContent) } } return t.limits.min >= t.limits.max && (t.static = !0), t.middlePosition = (t.limits.min + t.limits.max) / 2, t }

                function ve(e) { for (var t = { sid: e.getAttribute("sid"), name: e.getAttribute("name") || "", attachments: [], transforms: [] }, r = 0; r < e.childNodes.length; r++) { var a = e.childNodes[r]; if (1 === a.nodeType) switch (a.nodeName) {
                            case "attachment_full":
                                t.attachments.push(ge(a)); break;
                            case "matrix":
                            case "translate":
                            case "rotate":
                                t.transforms.push(be(a)) } } return t }

                function ge(e) { for (var t = { joint: e.getAttribute("joint").split("/").pop(), transforms: [], links: [] }, r = 0; r < e.childNodes.length; r++) { var a = e.childNodes[r]; if (1 === a.nodeType) switch (a.nodeName) {
                            case "link":
                                t.links.push(ve(a)); break;
                            case "matrix":
                            case "translate":
                            case "rotate":
                                t.transforms.push(be(a)) } } return t }

                function be(e) { var t = { type: e.nodeName },
                        r = n(e.textContent); switch (t.type) {
                        case "matrix":
                            t.obj = new THREE.Matrix4, t.obj.fromArray(r).transpose(); break;
                        case "translate":
                            t.obj = new THREE.Vector3, t.obj.fromArray(r); break;
                        case "rotate":
                            t.obj = new THREE.Vector3, t.obj.fromArray(r), t.angle = THREE.MathUtils.degToRad(r[3]) } return t }

                function ye(e, t) { for (var r = 0; r < e.childNodes.length; r++) { var a = e.childNodes[r]; if (1 === a.nodeType) switch (a.nodeName) {
                            case "technique_common":
                                Ee(a, t) } } }

                function Ee(e, t) { for (var r = 0; r < e.childNodes.length; r++) { var a = e.childNodes[r]; if (1 === a.nodeType) switch (a.nodeName) {
                            case "inertia":
                                t.inertia = n(a.textContent); break;
                            case "mass":
                                t.mass = n(a.textContent)[0] } } }

                function Ne(e) { for (var t = { target: e.getAttribute("target").split("/").pop() }, r = 0; r < e.childNodes.length; r++) { var a = e.childNodes[r]; if (1 === a.nodeType) switch (a.nodeName) {
                            case "axis":
                                var n = a.getElementsByTagName("param")[0];
                                t.axis = n.textContent; var i = t.axis.split("inst_").pop().split("axis")[0];
                                t.jointIndex = i.substr(0, i.length - 1) } } return t }

                function Te(e) { return void 0 !== e.build ? e.build : e }

                function we(e) { for (var t = [], r = Be.querySelector('[id="' + e.id + '"]'), a = 0; a < r.childNodes.length; a++) { var i = r.childNodes[a]; if (1 === i.nodeType) switch (i.nodeName) {
                            case "matrix":
                                var s = n(i.textContent),
                                    o = (new THREE.Matrix4).fromArray(s).transpose();
                                t.push({ sid: i.getAttribute("sid"), type: i.nodeName, obj: o }); break;
                            case "translate":
                            case "scale":
                                s = n(i.textContent); var c = (new THREE.Vector3).fromArray(s);
                                t.push({ sid: i.getAttribute("sid"), type: i.nodeName, obj: c }); break;
                            case "rotate":
                                s = n(i.textContent), c = (new THREE.Vector3).fromArray(s); var l = THREE.MathUtils.degToRad(s[3]);
                                t.push({ sid: i.getAttribute("sid"), type: i.nodeName, obj: c, angle: l }) } } return t } var xe = new THREE.Matrix4,
                    ke = new THREE.Vector3;

                function Ae(e) { for (var t = { name: e.getAttribute("name") || "", type: e.getAttribute("type"), id: e.getAttribute("id"), sid: e.getAttribute("sid"), matrix: new THREE.Matrix4, nodes: [], instanceCameras: [], instanceControllers: [], instanceLights: [], instanceGeometries: [], instanceNodes: [], transforms: {} }, r = 0; r < e.childNodes.length; r++) { var a = e.childNodes[r]; if (1 === a.nodeType) switch (a.nodeName) {
                            case "node":
                                t.nodes.push(a.getAttribute("id")), Ae(a); break;
                            case "instance_camera":
                                t.instanceCameras.push(s(a.getAttribute("url"))); break;
                            case "instance_controller":
                                t.instanceControllers.push(Re(a)); break;
                            case "instance_light":
                                t.instanceLights.push(s(a.getAttribute("url"))); break;
                            case "instance_geometry":
                                t.instanceGeometries.push(Re(a)); break;
                            case "instance_node":
                                t.instanceNodes.push(s(a.getAttribute("url"))); break;
                            case "matrix":
                                var i = n(a.textContent);
                                t.matrix.multiply(xe.fromArray(i).transpose()), t.transforms[a.getAttribute("sid")] = a.nodeName; break;
                            case "translate":
                                i = n(a.textContent);
                                ke.fromArray(i), t.matrix.multiply(xe.makeTranslation(ke.x, ke.y, ke.z)), t.transforms[a.getAttribute("sid")] = a.nodeName; break;
                            case "rotate":
                                i = n(a.textContent); var o = THREE.MathUtils.degToRad(i[3]);
                                t.matrix.multiply(xe.makeRotationAxis(ke.fromArray(i), o)), t.transforms[a.getAttribute("sid")] = a.nodeName; break;
                            case "scale":
                                i = n(a.textContent);
                                t.matrix.scale(ke.fromArray(i)), t.transforms[a.getAttribute("sid")] = a.nodeName; break;
                            case "extra":
                                break;
                            default:
                                console.log(a) } } return je(t.id) ? console.warn("THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.", t.id) : Ke.nodes[t.id] = t, t }

                function Re(e) { for (var t = { id: s(e.getAttribute("url")), materials: {}, skeletons: [] }, r = 0; r < e.childNodes.length; r++) { var a = e.childNodes[r]; switch (a.nodeName) {
                            case "bind_material":
                                for (var n = a.getElementsByTagName("instance_material"), i = 0; i < n.length; i++) { var o = n[i],
                                        c = o.getAttribute("symbol"),
                                        l = o.getAttribute("target");
                                    t.materials[c] = s(l) } break;
                            case "skeleton":
                                t.skeletons.push(s(a.textContent)) } } return t }

                function He(e, t) { var r, a, n, i = [],
                        s = []; for (r = 0; r < e.length; r++) { var o = e[r]; if (je(o)) Ce(Ie(o), t, i);
                        else if (n = o, void 0 !== Ke.visualScenes[n])
                            for (var c = Ke.visualScenes[o].children, l = 0; l < c.length; l++) { var d = c[l]; if ("JOINT" === d.type) Ce(Ie(d.id), t, i) } else console.error("THREE.ColladaLoader: Unable to find root bone of skeleton with ID:", o) } for (r = 0; r < t.length; r++)
                        for (l = 0; l < i.length; l++)
                            if ((a = i[l]).bone.name === t[r].name) { s[r] = a, a.processed = !0; break } for (r = 0; r < i.length; r++) !1 === (a = i[r]).processed && (s.push(a), a.processed = !0); var u = [],
                        f = []; for (r = 0; r < s.length; r++) a = s[r], u.push(a.bone), f.push(a.boneInverse); return new THREE.Skeleton(u, f) }

                function Ce(e, t, r) { e.traverse(function(e) { if (!0 === e.isBone) { for (var a, n = 0; n < t.length; n++) { var i = t[n]; if (i.name === e.name) { a = i.boneInverse; break } } void 0 === a && (a = new THREE.Matrix4), r.push({ bone: e, boneInverse: a, processed: !1 }) } }) }

                function _e(e) { for (var t, r = [], a = e.matrix, n = e.nodes, i = e.type, s = e.instanceCameras, o = e.instanceControllers, c = e.instanceLights, l = e.instanceGeometries, d = e.instanceNodes, u = 0, h = n.length; u < h; u++) r.push(Ie(n[u])); for (u = 0, h = s.length; u < h; u++) { var m = $(s[u]);
                        null !== m && r.push(m.clone()) } for (u = 0, h = o.length; u < h; u++)
                        for (var p = o[u], v = (t = p.id, f(Ke.controllers[t], M)), g = Oe(ue(v.id), p.materials), b = He(p.skeletons, v.skin.joints), y = 0, E = g.length; y < E; y++) { var N;
                            (N = g[y]).isSkinnedMesh && (N.bind(b, v.skin.bindMatrix), N.normalizeSkinWeights()), r.push(N) }
                    for (u = 0, h = c.length; u < h; u++) { var T = ae(c[u]);
                        null !== T && r.push(T.clone()) } for (u = 0, h = l.length; u < h; u++)
                        for (y = 0, E = (g = Oe(ue((p = l[u]).id), p.materials)).length; y < E; y++) r.push(g[y]); for (u = 0, h = d.length; u < h; u++) r.push(Ie(d[u]).clone()); if (0 === n.length && 1 === r.length) N = r[0];
                    else { N = "JOINT" === i ? new THREE.Bone : new THREE.Group; for (u = 0; u < r.length; u++) N.add(r[u]) } return N.name = "JOINT" === i ? e.sid : e.name, N.matrix.copy(a), N.matrix.decompose(N.position, N.quaternion, N.scale), N } var Me = new THREE.MeshBasicMaterial({ color: 16711935 });

                function Le(e, t) { for (var r = [], a = 0, n = e.length; a < n; a++) { var i = t[e[a]];
                        void 0 === i ? (console.warn("THREE.ColladaLoader: Material with key %s not found. Apply fallback material.", e[a]), r.push(Me)) : r.push(X(i)) } return r }

                function Oe(e, t) { var r = []; for (var a in e) { var n = e[a],
                            i = Le(n.materialKeys, t);
                        0 === i.length && ("lines" === a || "linestrips" === a ? i.push(new THREE.LineBasicMaterial) : i.push(new THREE.MeshPhongMaterial)); var s = void 0 !== n.data.attributes.skinIndex; if (s)
                            for (var o = 0, c = i.length; o < c; o++) i[o].skinning = !0; var l, d = 1 === i.length ? i[0] : i; switch (a) {
                            case "lines":
                                l = new THREE.LineSegments(n.data, d); break;
                            case "linestrips":
                                l = new THREE.Line(n.data, d); break;
                            case "triangles":
                            case "polylist":
                                l = s ? new THREE.SkinnedMesh(n.data, d) : new THREE.Mesh(n.data, d) } r.push(l) } return r }

                function je(e) { return void 0 !== Ke.nodes[e] }

                function Ie(e) { return f(Ke.nodes[e], _e) }

                function qe(e) { var t = new THREE.Group;
                    t.name = e.name; for (var r = e.children, a = 0; a < r.length; a++) { var n = r[a];
                        t.add(Ie(n.id)) } return t }

                function Ue(e) { return f(Ke.visualScenes[e], qe) } if (0 === e.length) return { scene: new THREE.Scene }; var Se = (new DOMParser).parseFromString(e, "application/xml"),
                    Be = r(Se, "COLLADA")[0],
                    Fe = Se.getElementsByTagName("parsererror")[0]; if (void 0 !== Fe) { var Ve, Pe = r(Fe, "div")[0]; return Ve = Pe ? Pe.textContent : function(e) { for (var t = "", r = [e]; r.length;) { var a = r.shift();
                            a.nodeType === Node.TEXT_NODE ? t += a.textContent : (t += "\n", r.push.apply(r, a.childNodes)) } return t.trim() }(Fe), console.error("THREE.ColladaLoader: Failed to parse collada file.\n", Ve), null } Be.getAttribute("version"); var De, ze = function(e) { return { unit: c(r(e, "unit")[0]), upAxis: l(r(e, "up_axis")[0]) } }(r(Be, "asset")[0]),
                    We = new THREE.TextureLoader(this.manager);
                We.setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin), THREE.TGALoader && (De = new THREE.TGALoader(this.manager)).setPath(this.resourcePath || t); var Ge = [],
                    Je = {},
                    Xe = 0,
                    Ke = { animations: {}, clips: {}, controllers: {}, images: {}, effects: {}, materials: {}, cameras: {}, lights: {}, geometries: {}, nodes: {}, visualScenes: {}, kinematicsModels: {}, physicsModels: {}, kinematicsScenes: {} };
                d(Be, "library_animations", "animation", function e(t) { for (var r = { sources: {}, samplers: {}, channels: {} }, a = !1, n = 0, i = t.childNodes.length; n < i; n++) { var s, o = t.childNodes[n]; if (1 === o.nodeType) switch (o.nodeName) {
                                case "source":
                                    s = o.getAttribute("id"), r.sources[s] = ne(o); break;
                                case "sampler":
                                    s = o.getAttribute("id"), r.samplers[s] = h(o); break;
                                case "channel":
                                    s = o.getAttribute("target"), r.channels[s] = m(o); break;
                                case "animation":
                                    e(o), a = !0; break;
                                default:
                                    console.log(o) } }!1 === a && (Ke.animations[t.getAttribute("id") || THREE.MathUtils.generateUUID()] = r) }), d(Be, "library_animation_clips", "animation_clip", function(e) { for (var t = { name: e.getAttribute("id") || "default", start: parseFloat(e.getAttribute("start") || 0), end: parseFloat(e.getAttribute("end") || 0), animations: [] }, r = 0, a = e.childNodes.length; r < a; r++) { var n = e.childNodes[r]; if (1 === n.nodeType) switch (n.nodeName) {
                                case "instance_animation":
                                    t.animations.push(s(n.getAttribute("url"))) } } Ke.clips[e.getAttribute("id")] = t }), d(Be, "library_controllers", "controller", function(e) { for (var t = {}, r = 0, a = e.childNodes.length; r < a; r++) { var n = e.childNodes[r]; if (1 === n.nodeType) switch (n.nodeName) {
                                case "skin":
                                    t.id = s(n.getAttribute("source")), t.skin = H(n); break;
                                case "morph":
                                    t.id = s(n.getAttribute("source")), console.warn("THREE.ColladaLoader: Morph target animation not supported yet.") } } Ke.controllers[e.getAttribute("id")] = t }), d(Be, "library_images", "image", function(e) { var t = { init_from: r(e, "init_from")[0].textContent };
                        Ke.images[e.getAttribute("id")] = t }), d(Be, "library_effects", "effect", function(e) { for (var t = {}, r = 0, a = e.childNodes.length; r < a; r++) { var n = e.childNodes[r]; if (1 === n.nodeType) switch (n.nodeName) {
                                case "profile_COMMON":
                                    t.profile = j(n) } } Ke.effects[e.getAttribute("id")] = t }), d(Be, "library_materials", "material", function(e) { for (var t = { name: e.getAttribute("name") }, r = 0, a = e.childNodes.length; r < a; r++) { var n = e.childNodes[r]; if (1 === n.nodeType) switch (n.nodeName) {
                                case "instance_effect":
                                    t.url = s(n.getAttribute("url")) } } Ke.materials[e.getAttribute("id")] = t }), d(Be, "library_cameras", "camera", function(e) { for (var t = { name: e.getAttribute("name") }, r = 0, a = e.childNodes.length; r < a; r++) { var n = e.childNodes[r]; if (1 === n.nodeType) switch (n.nodeName) {
                                case "optics":
                                    t.optics = K(n) } } Ke.cameras[e.getAttribute("id")] = t }), d(Be, "library_lights", "light", function(e) { for (var t = {}, r = 0, a = e.childNodes.length; r < a; r++) { var n = e.childNodes[r]; if (1 === n.nodeType) switch (n.nodeName) {
                                case "technique_common":
                                    t = ee(n) } } Ke.lights[e.getAttribute("id")] = t }), d(Be, "library_geometries", "geometry", function(e) { var t = { name: e.getAttribute("name"), sources: {}, vertices: {}, primitives: [] },
                            a = r(e, "mesh")[0]; if (void 0 !== a) { for (var n = 0; n < a.childNodes.length; n++) { var i = a.childNodes[n]; if (1 === i.nodeType) { var s = i.getAttribute("id"); switch (i.nodeName) {
                                        case "source":
                                            t.sources[s] = ne(i); break;
                                        case "vertices":
                                            t.vertices = ie(i); break;
                                        case "polygons":
                                            console.warn("THREE.ColladaLoader: Unsupported primitive type: ", i.nodeName); break;
                                        case "lines":
                                        case "linestrips":
                                        case "polylist":
                                        case "triangles":
                                            t.primitives.push(se(i)); break;
                                        default:
                                            console.log(i) } } } Ke.geometries[e.getAttribute("id")] = t } }), d(Be, "library_nodes", "node", Ae), d(Be, "library_visual_scenes", "visual_scene", function(e) { var t = { name: e.getAttribute("name"), children: [] };! function(e) { for (var t = e.getElementsByTagName("node"), r = 0; r < t.length; r++) { var a = t[r];!1 === a.hasAttribute("id") && a.setAttribute("id", "three_default_" + Xe++) } }(e); for (var a = r(e, "node"), n = 0; n < a.length; n++) t.children.push(Ae(a[n]));
                        Ke.visualScenes[e.getAttribute("id")] = t }), d(Be, "library_kinematics_models", "kinematics_model", function(e) { for (var t = { name: e.getAttribute("name") || "", joints: {}, links: [] }, r = 0; r < e.childNodes.length; r++) { var a = e.childNodes[r]; if (1 === a.nodeType) switch (a.nodeName) {
                                case "technique_common":
                                    he(a, t) } } Ke.kinematicsModels[e.getAttribute("id")] = t }), d(Be, "library_physics_models", "physics_model", function(e) { for (var t = { name: e.getAttribute("name") || "", rigidBodies: {} }, r = 0; r < e.childNodes.length; r++) { var a = e.childNodes[r]; if (1 === a.nodeType) switch (a.nodeName) {
                                case "rigid_body":
                                    t.rigidBodies[a.getAttribute("name")] = {}, ye(a, t.rigidBodies[a.getAttribute("name")]) } } Ke.physicsModels[e.getAttribute("id")] = t }), d(Be, "scene", "instance_kinematics_scene", function(e) { for (var t = { bindJointAxis: [] }, r = 0; r < e.childNodes.length; r++) { var a = e.childNodes[r]; if (1 === a.nodeType) switch (a.nodeName) {
                                case "bind_joint_axis":
                                    t.bindJointAxis.push(Ne(a)) } } Ke.kinematicsScenes[s(e.getAttribute("url"))] = t }), u(Ke.animations, p), u(Ke.clips, A), u(Ke.controllers, M), u(Ke.images, L), u(Ke.effects, G), u(Ke.materials, J), u(Ke.cameras, Y), u(Ke.lights, re), u(Ke.geometries, ce), u(Ke.visualScenes, qe),
                    function() { var e = Ke.clips; if (!0 === o(e)) { if (!1 === o(Ke.animations)) { var t = []; for (var r in Ke.animations)
                                    for (var a = v(r), n = 0, i = a.length; n < i; n++) t.push(a[n]);
                                Ge.push(new THREE.AnimationClip("default", -1, t)) } } else
                            for (var r in e) Ge.push(R(r)) }(),
                    function() { var e = Object.keys(Ke.kinematicsModels)[0],
                            t = Object.keys(Ke.kinematicsScenes)[0],
                            r = Object.keys(Ke.visualScenes)[0]; if (void 0 !== e && void 0 !== t) { for (var a, n = (a = e, f(Ke.kinematicsModels[a], fe)), i = function(e) { return f(Ke.kinematicsScenes[e], Te) }(t), s = Ue(r), o = i.bindJointAxis, c = {}, l = 0, d = o.length; l < d; l++) { var u = o[l],
                                    h = Be.querySelector('[sid="' + u.target + '"]'); if (h) { var m = h.parentElement;
                                    v(u.jointIndex, m) } } var p = new THREE.Matrix4;
                            Je = { joints: n && n.joints, getJointValue: function(e) { var t = c[e]; if (t) return t.position;
                                    console.warn("THREE.ColladaLoader: Joint " + e + " doesn't exist.") }, setJointValue: function(e, t) { var r = c[e]; if (r) { var a = r.joint; if (t > a.limits.max || t < a.limits.min) console.warn("THREE.ColladaLoader: Joint " + e + " value " + t + " outside of limits (min: " + a.limits.min + ", max: " + a.limits.max + ").");
                                        else if (a.static) console.warn("THREE.ColladaLoader: Joint " + e + " is static.");
                                        else { var n = r.object,
                                                i = a.axis,
                                                s = r.transforms;
                                            xe.identity(); for (var o = 0; o < s.length; o++) { var l = s[o]; if (l.sid && -1 !== l.sid.indexOf(e)) switch (a.type) {
                                                    case "revolute":
                                                        xe.multiply(p.makeRotationAxis(i, THREE.MathUtils.degToRad(t))); break;
                                                    case "prismatic":
                                                        xe.multiply(p.makeTranslation(i.x * t, i.y * t, i.z * t)); break;
                                                    default:
                                                        console.warn("THREE.ColladaLoader: Unknown joint type: " + a.type) } else switch (l.type) {
                                                    case "matrix":
                                                        xe.multiply(l.obj); break;
                                                    case "translate":
                                                        xe.multiply(p.makeTranslation(l.obj.x, l.obj.y, l.obj.z)); break;
                                                    case "scale":
                                                        xe.scale(l.obj); break;
                                                    case "rotate":
                                                        xe.multiply(p.makeRotationAxis(l.obj, l.angle)) } } n.matrix.copy(xe), n.matrix.decompose(n.position, n.quaternion, n.scale), c[e].position = t } } else console.log("THREE.ColladaLoader: " + e + " does not exist.") } } }

                        function v(e, t) { var r = t.getAttribute("name"),
                                a = n.joints[e];
                            s.traverse(function(n) { n.name === r && (c[e] = { object: n, transforms: we(t), joint: a, position: a.zeroPosition }) }) } }(); var Ze = function(e) { return Ue(s(r(e, "instance_visual_scene")[0].getAttribute("url"))) }(r(Be, "scene")[0]); return "Z_UP" === ze.upAxis && Ze.quaternion.setFromEuler(new THREE.Euler(-Math.PI / 2, 0, 0)), Ze.scale.multiplyScalar(ze.unit), { animations: Ge, kinematics: Je, library: Ke, scene: Ze } } }), module.exports = exports = THREE.ColladaLoader;

    }, { "../../three.js": 23 }],
    15: [function(require, module, exports) {
        const THREE = require("../../three.js"),
            Zlib = require("../Zlib.Inflate.js");
        THREE.FBXLoader = function() { var e, t, r;

            function a(e) { THREE.Loader.call(this, e) }

            function n(e, t) { this.textureLoader = e, this.manager = t }

            function i() {}

            function o() {}

            function s() {}

            function u() {}

            function l(e, t) { this.dv = new DataView(e), this.offset = 0, this.littleEndian = void 0 === t || t }

            function c() {}

            function p(e) { var t = e.match(/FBXVersion: (\d+)/); if (t) return parseInt(t[1]); throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.") }

            function h(e) { return e / 46186158e3 } a.prototype = Object.assign(Object.create(THREE.Loader.prototype), { constructor: a, load: function(e, t, r, a) { var n = this,
                        i = "" === n.path ? THREE.LoaderUtils.extractUrlBase(e) : n.path,
                        o = new THREE.FileLoader(this.manager);
                    o.setPath(n.path), o.setResponseType("arraybuffer"), o.load(e, function(r) { try { t(n.parse(r, i)) } catch (t) { a ? a(t) : console.error(t), n.manager.itemError(e) } }, r, a) }, parse: function(t, r) { if (o = "Kaydara FBX Binary  \0", (i = t).byteLength >= o.length && o === T(i, 0, o.length)) e = (new u).parse(t);
                    else { var a = T(t); if (! function(e) { var t = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"],
                                    r = 0;

                                function a(t) { var a = e[t - 1]; return e = e.slice(r + t), r++, a } for (var n = 0; n < t.length; ++n) { var i = a(1); if (i === t[n]) return !1 } return !0 }(a)) throw new Error("THREE.FBXLoader: Unknown format."); if (p(a) < 7e3) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + p(a));
                        e = (new s).parse(a) } var i, o; return new n(new THREE.TextureLoader(this.manager).setPath(this.resourcePath || r).setCrossOrigin(this.crossOrigin), this.manager).parse(e) } }), n.prototype = { constructor: n, parse: function() { t = this.parseConnections(); var e = this.parseImages(),
                        a = this.parseTextures(e),
                        n = this.parseMaterials(a),
                        o = this.parseDeformers(),
                        s = (new i).parse(o); return this.parseScene(o, s, n), r }, parseConnections: function() { var t = new Map; "Connections" in e && e.Connections.connections.forEach(function(e) { var r = e[0],
                            a = e[1],
                            n = e[2];
                        t.has(r) || t.set(r, { parents: [], children: [] }); var i = { ID: a, relationship: n };
                        t.get(r).parents.push(i), t.has(a) || t.set(a, { parents: [], children: [] }); var o = { ID: r, relationship: n };
                        t.get(a).children.push(o) }); return t }, parseImages: function() { var t = {},
                        r = {}; if ("Video" in e.Objects) { var a = e.Objects.Video; for (var n in a) { var i = a[n]; if (t[l = parseInt(n)] = i.RelativeFilename || i.Filename, "Content" in i) { var o = i.Content instanceof ArrayBuffer && i.Content.byteLength > 0,
                                    s = "string" == typeof i.Content && "" !== i.Content; if (o || s) { var u = this.parseImage(a[n]);
                                    r[i.RelativeFilename || i.Filename] = u } } } } for (var l in t) { var c = t[l];
                        void 0 !== r[c] ? t[l] = r[c] : t[l] = t[l].split("\\").pop() } return t }, parseImage: function(e) { var t, r = e.Content,
                        a = e.RelativeFilename || e.Filename,
                        n = a.slice(a.lastIndexOf(".") + 1).toLowerCase(); switch (n) {
                        case "bmp":
                            t = "image/bmp"; break;
                        case "jpg":
                        case "jpeg":
                            t = "image/jpeg"; break;
                        case "png":
                            t = "image/png"; break;
                        case "tif":
                            t = "image/tiff"; break;
                        case "tga":
                            null === this.manager.getHandler(".tga") && console.warn("FBXLoader: TGA loader not found, skipping ", a), t = "image/tga"; break;
                        default:
                            return void console.warn('FBXLoader: Image type "' + n + '" is not supported.') } if ("string" == typeof r) return "data:" + t + ";base64," + r; var i = new Uint8Array(r); return window.URL.createObjectURL(new Blob([i], { type: t })) }, parseTextures: function(t) { var r = new Map; if ("Texture" in e.Objects) { var a = e.Objects.Texture; for (var n in a) { var i = this.parseTexture(a[n], t);
                            r.set(parseInt(n), i) } } return r }, parseTexture: function(e, t) { var r = this.loadTexture(e, t);
                    r.ID = e.id, r.name = e.attrName; var a = e.WrapModeU,
                        n = e.WrapModeV,
                        i = void 0 !== a ? a.value : 0,
                        o = void 0 !== n ? n.value : 0; if (r.wrapS = 0 === i ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping, r.wrapT = 0 === o ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping, "Scaling" in e) { var s = e.Scaling.value;
                        r.repeat.x = s[0], r.repeat.y = s[1] } return r }, loadTexture: function(e, r) { var a, n, i = this.textureLoader.path,
                        o = t.get(e.id).children;
                    void 0 !== o && o.length > 0 && void 0 !== r[o[0].ID] && (0 !== (a = r[o[0].ID]).indexOf("blob:") && 0 !== a.indexOf("data:") || this.textureLoader.setPath(void 0)); var s = e.FileName.slice(-3).toLowerCase(); if ("tga" === s) { var u = this.manager.getHandler(".tga");
                        null === u ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename), n = new THREE.Texture) : n = u.load(a) } else "psd" === s ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", e.RelativeFilename), n = new THREE.Texture) : n = this.textureLoader.load(a); return this.textureLoader.setPath(i), n }, parseMaterials: function(t) { var r = new Map; if ("Material" in e.Objects) { var a = e.Objects.Material; for (var n in a) { var i = this.parseMaterial(a[n], t);
                            null !== i && r.set(parseInt(n), i) } } return r }, parseMaterial: function(e, r) { var a = e.id,
                        n = e.attrName,
                        i = e.ShadingModel; if ("object" == typeof i && (i = i.value), !t.has(a)) return null; var o, s = this.parseParameters(e, r, a); switch (i.toLowerCase()) {
                        case "phong":
                            o = new THREE.MeshPhongMaterial; break;
                        case "lambert":
                            o = new THREE.MeshLambertMaterial; break;
                        default:
                            console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', i), o = new THREE.MeshPhongMaterial } return o.setValues(s), o.name = n, o }, parseParameters: function(e, r, a) { var n = {};
                    e.BumpFactor && (n.bumpScale = e.BumpFactor.value), e.Diffuse ? n.color = (new THREE.Color).fromArray(e.Diffuse.value) : e.DiffuseColor && "Color" === e.DiffuseColor.type && (n.color = (new THREE.Color).fromArray(e.DiffuseColor.value)), e.DisplacementFactor && (n.displacementScale = e.DisplacementFactor.value), e.Emissive ? n.emissive = (new THREE.Color).fromArray(e.Emissive.value) : e.EmissiveColor && "Color" === e.EmissiveColor.type && (n.emissive = (new THREE.Color).fromArray(e.EmissiveColor.value)), e.EmissiveFactor && (n.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (n.opacity = parseFloat(e.Opacity.value)), n.opacity < 1 && (n.transparent = !0), e.ReflectionFactor && (n.reflectivity = e.ReflectionFactor.value), e.Shininess && (n.shininess = e.Shininess.value), e.Specular ? n.specular = (new THREE.Color).fromArray(e.Specular.value) : e.SpecularColor && "Color" === e.SpecularColor.type && (n.specular = (new THREE.Color).fromArray(e.SpecularColor.value)); var i = this; return t.get(a).children.forEach(function(e) { var t = e.relationship; switch (t) {
                            case "Bump":
                                n.bumpMap = i.getTexture(r, e.ID); break;
                            case "Maya|TEX_ao_map":
                                n.aoMap = i.getTexture(r, e.ID); break;
                            case "DiffuseColor":
                            case "Maya|TEX_color_map":
                                n.map = i.getTexture(r, e.ID), n.map.encoding = THREE.sRGBEncoding; break;
                            case "DisplacementColor":
                                n.displacementMap = i.getTexture(r, e.ID); break;
                            case "EmissiveColor":
                                n.emissiveMap = i.getTexture(r, e.ID), n.emissiveMap.encoding = THREE.sRGBEncoding; break;
                            case "NormalMap":
                            case "Maya|TEX_normal_map":
                                n.normalMap = i.getTexture(r, e.ID); break;
                            case "ReflectionColor":
                                n.envMap = i.getTexture(r, e.ID), n.envMap.mapping = THREE.EquirectangularReflectionMapping, n.envMap.encoding = THREE.sRGBEncoding; break;
                            case "SpecularColor":
                                n.specularMap = i.getTexture(r, e.ID), n.specularMap.encoding = THREE.sRGBEncoding; break;
                            case "TransparentColor":
                            case "TransparencyFactor":
                                n.alphaMap = i.getTexture(r, e.ID), n.transparent = !0; break;
                            case "AmbientColor":
                            case "ShininessExponent":
                            case "SpecularFactor":
                            case "VectorDisplacementColor":
                            default:
                                console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", t) } }), n }, getTexture: function(r, a) { return "LayeredTexture" in e.Objects && a in e.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), a = t.get(a).children[0].ID), r.get(a) }, parseDeformers: function() { var r = {},
                        a = {}; if ("Deformer" in e.Objects) { var n = e.Objects.Deformer; for (var i in n) { var o = n[i],
                                s = t.get(parseInt(i)); if ("Skin" === o.attrType) { var u = this.parseSkeleton(s, n);
                                u.ID = i, s.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), u.geometryID = s.parents[0].ID, r[i] = u } else if ("BlendShape" === o.attrType) { var l = { id: i };
                                l.rawTargets = this.parseMorphTargets(s, n), l.id = i, s.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), a[i] = l } } } return { skeletons: r, morphTargets: a } }, parseSkeleton: function(e, t) { var r = []; return e.children.forEach(function(e) { var a = t[e.ID]; if ("Cluster" === a.attrType) { var n = { ID: e.ID, indices: [], weights: [], transformLink: (new THREE.Matrix4).fromArray(a.TransformLink.a) }; "Indexes" in a && (n.indices = a.Indexes.a, n.weights = a.Weights.a), r.push(n) } }), { rawBones: r, bones: [] } }, parseMorphTargets: function(e, r) { for (var a = [], n = 0; n < e.children.length; n++) { var i = e.children[n],
                            o = r[i.ID],
                            s = { name: o.attrName, initialWeight: o.DeformPercent, id: o.id, fullWeights: o.FullWeights.a }; if ("BlendShapeChannel" !== o.attrType) return;
                        s.geoID = t.get(parseInt(i.ID)).children.filter(function(e) { return void 0 === e.relationship })[0].ID, a.push(s) } return a }, parseScene: function(a, n, i) { r = new THREE.Group; var s = this.parseModels(a.skeletons, n, i),
                        u = e.Objects.Model,
                        l = this;
                    s.forEach(function(e) { var a = u[e.ID];
                        l.setLookAtProperties(e, a), t.get(e.ID).parents.forEach(function(t) { var r = s.get(t.ID);
                            void 0 !== r && r.add(e) }), null === e.parent && r.add(e) }), this.bindSkeleton(a.skeletons, n, s), this.createAmbientLight(), this.setupMorphMaterials(), r.traverse(function(e) { if (e.userData.transformData) { e.parent && (e.userData.transformData.parentMatrixWorld = e.parent.matrix); var t = g(e.userData.transformData);
                            e.applyMatrix4(t) } }); var c = (new o).parse();
                    1 === r.children.length && r.children[0].isGroup && (r.children[0].animations = c, r = r.children[0]), r.animations = c }, parseModels: function(r, a, n) { var i = new Map,
                        o = e.Objects.Model; for (var s in o) { var u = parseInt(s),
                            l = o[s],
                            c = t.get(u),
                            p = this.buildSkeleton(c, r, u, l.attrName); if (!p) { switch (l.attrType) {
                                case "Camera":
                                    p = this.createCamera(c); break;
                                case "Light":
                                    p = this.createLight(c); break;
                                case "Mesh":
                                    p = this.createMesh(c, a, n); break;
                                case "NurbsCurve":
                                    p = this.createCurve(c, a); break;
                                case "LimbNode":
                                case "Root":
                                    p = new THREE.Bone; break;
                                case "Null":
                                default:
                                    p = new THREE.Group } p.name = l.attrName ? THREE.PropertyBinding.sanitizeNodeName(l.attrName) : "", p.ID = u } this.getTransformData(p, l), i.set(u, p) } return i }, buildSkeleton: function(e, t, r, a) { var n = null; return e.parents.forEach(function(e) { for (var i in t) { var o = t[i];
                            o.rawBones.forEach(function(t, i) { if (t.ID === e.ID) { var s = n;
                                    (n = new THREE.Bone).matrixWorld.copy(t.transformLink), n.name = a ? THREE.PropertyBinding.sanitizeNodeName(a) : "", n.ID = r, o.bones[i] = n, null !== s && n.add(s) } }) } }), n }, createCamera: function(t) { var r, a; if (t.children.forEach(function(t) { var r = e.Objects.NodeAttribute[t.ID];
                            void 0 !== r && (a = r) }), void 0 === a) r = new THREE.Object3D;
                    else { var n = 0;
                        void 0 !== a.CameraProjectionType && 1 === a.CameraProjectionType.value && (n = 1); var i = 1;
                        void 0 !== a.NearPlane && (i = a.NearPlane.value / 1e3); var o = 1e3;
                        void 0 !== a.FarPlane && (o = a.FarPlane.value / 1e3); var s = window.innerWidth,
                            u = window.innerHeight;
                        void 0 !== a.AspectWidth && void 0 !== a.AspectHeight && (s = a.AspectWidth.value, u = a.AspectHeight.value); var l = s / u,
                            c = 45;
                        void 0 !== a.FieldOfView && (c = a.FieldOfView.value); var p = a.FocalLength ? a.FocalLength.value : null; switch (n) {
                            case 0:
                                r = new THREE.PerspectiveCamera(c, l, i, o), null !== p && r.setFocalLength(p); break;
                            case 1:
                                r = new THREE.OrthographicCamera(-s / 2, s / 2, u / 2, -u / 2, i, o); break;
                            default:
                                console.warn("THREE.FBXLoader: Unknown camera type " + n + "."), r = new THREE.Object3D } } return r }, createLight: function(t) { var r, a; if (t.children.forEach(function(t) { var r = e.Objects.NodeAttribute[t.ID];
                            void 0 !== r && (a = r) }), void 0 === a) r = new THREE.Object3D;
                    else { var n;
                        n = void 0 === a.LightType ? 0 : a.LightType.value; var i = 16777215;
                        void 0 !== a.Color && (i = (new THREE.Color).fromArray(a.Color.value)); var o = void 0 === a.Intensity ? 1 : a.Intensity.value / 100;
                        void 0 !== a.CastLightOnObject && 0 === a.CastLightOnObject.value && (o = 0); var s = 0;
                        void 0 !== a.FarAttenuationEnd && (s = void 0 !== a.EnableFarAttenuation && 0 === a.EnableFarAttenuation.value ? 0 : a.FarAttenuationEnd.value); switch (n) {
                            case 0:
                                r = new THREE.PointLight(i, o, s, 1); break;
                            case 1:
                                r = new THREE.DirectionalLight(i, o); break;
                            case 2:
                                var u = Math.PI / 3;
                                void 0 !== a.InnerAngle && (u = THREE.MathUtils.degToRad(a.InnerAngle.value)); var l = 0;
                                void 0 !== a.OuterAngle && (l = THREE.MathUtils.degToRad(a.OuterAngle.value), l = Math.max(l, 1)), r = new THREE.SpotLight(i, o, s, u, l, 1); break;
                            default:
                                console.warn("THREE.FBXLoader: Unknown light type " + a.LightType.value + ", defaulting to a THREE.PointLight."), r = new THREE.PointLight(i, o) } void 0 !== a.CastShadows && 1 === a.CastShadows.value && (r.castShadow = !0) } return r }, createMesh: function(e, t, r) { var a, n = null,
                        i = null,
                        o = []; return e.children.forEach(function(e) { t.has(e.ID) && (n = t.get(e.ID)), r.has(e.ID) && o.push(r.get(e.ID)) }), o.length > 1 ? i = o : o.length > 0 ? i = o[0] : (i = new THREE.MeshPhongMaterial({ color: 13421772 }), o.push(i)), "color" in n.attributes && o.forEach(function(e) { e.vertexColors = !0 }), n.FBX_Deformer ? (o.forEach(function(e) { e.skinning = !0 }), (a = new THREE.SkinnedMesh(n, i)).normalizeSkinWeights()) : a = new THREE.Mesh(n, i), a }, createCurve: function(e, t) { var r = e.children.reduce(function(e, r) { return t.has(r.ID) && (e = t.get(r.ID)), e }, null),
                        a = new THREE.LineBasicMaterial({ color: 3342591, linewidth: 1 }); return new THREE.Line(r, a) }, getTransformData: function(e, t) { var r = {}; "InheritType" in t && (r.inheritType = parseInt(t.InheritType.value)), r.eulerOrder = "RotationOrder" in t ? E(t.RotationOrder.value) : "ZYX", "Lcl_Translation" in t && (r.translation = t.Lcl_Translation.value), "PreRotation" in t && (r.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (r.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (r.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (r.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (r.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (r.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (r.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (r.rotationPivot = t.RotationPivot.value), e.userData.transformData = r }, setLookAtProperties: function(a, n) { "LookAtProperty" in n && t.get(a.ID).children.forEach(function(t) { if ("LookAtProperty" === t.relationship) { var n = e.Objects.Model[t.ID]; if ("Lcl_Translation" in n) { var i = n.Lcl_Translation.value;
                                void 0 !== a.target ? (a.target.position.fromArray(i), r.add(a.target)) : a.lookAt((new THREE.Vector3).fromArray(i)) } } }) }, bindSkeleton: function(e, r, a) { var n = this.parsePoseNodes(); for (var i in e) { var o = e[i];
                        t.get(parseInt(o.ID)).parents.forEach(function(e) { if (r.has(e.ID)) { var i = e.ID;
                                t.get(i).parents.forEach(function(e) { a.has(e.ID) && a.get(e.ID).bind(new THREE.Skeleton(o.bones), n[e.ID]) }) } }) } }, parsePoseNodes: function() { var t = {}; if ("Pose" in e.Objects) { var r = e.Objects.Pose; for (var a in r)
                            if ("BindPose" === r[a].attrType) { var n = r[a].PoseNode;
                                Array.isArray(n) ? n.forEach(function(e) { t[e.Node] = (new THREE.Matrix4).fromArray(e.Matrix.a) }) : t[n.Node] = (new THREE.Matrix4).fromArray(n.Matrix.a) } } return t }, createAmbientLight: function() { if ("GlobalSettings" in e && "AmbientColor" in e.GlobalSettings) { var t = e.GlobalSettings.AmbientColor.value,
                            a = t[0],
                            n = t[1],
                            i = t[2]; if (0 !== a || 0 !== n || 0 !== i) { var o = new THREE.Color(a, n, i);
                            r.add(new THREE.AmbientLight(o, 1)) } } }, setupMorphMaterials: function() { var e = this;
                    r.traverse(function(t) { t.isMesh && t.geometry.morphAttributes.position && t.geometry.morphAttributes.position.length && (Array.isArray(t.material) ? t.material.forEach(function(r, a) { e.setupMorphMaterial(t, r, a) }) : e.setupMorphMaterial(t, t.material)) }) }, setupMorphMaterial: function(e, t, a) { var n = e.uuid,
                        i = t.uuid,
                        o = !1; if (r.traverse(function(e) { e.isMesh && (Array.isArray(e.material) ? e.material.forEach(function(t) { t.uuid === i && e.uuid !== n && (o = !0) }) : e.material.uuid === i && e.uuid !== n && (o = !0)) }), !0 === o) { var s = t.clone();
                        s.morphTargets = !0, void 0 === a ? e.material = s : e.material[a] = s } else t.morphTargets = !0 } }, i.prototype = { constructor: i, parse: function(r) { var a = new Map; if ("Geometry" in e.Objects) { var n = e.Objects.Geometry; for (var i in n) { var o = t.get(parseInt(i)),
                                s = this.parseGeometry(o, n[i], r);
                            a.set(parseInt(i), s) } } return a }, parseGeometry: function(e, t, r) { switch (t.attrType) {
                        case "Mesh":
                            return this.parseMeshGeometry(e, t, r);
                        case "NurbsCurve":
                            return this.parseNurbsGeometry(t) } }, parseMeshGeometry: function(t, r, a) { var n = a.skeletons,
                        i = [],
                        o = t.parents.map(function(t) { return e.Objects.Model[t.ID] }); if (0 !== o.length) { var s = t.children.reduce(function(e, t) { return void 0 !== n[t.ID] && (e = n[t.ID]), e }, null);
                        t.children.forEach(function(e) { void 0 !== a.morphTargets[e.ID] && i.push(a.morphTargets[e.ID]) }); var u = o[0],
                            l = {}; "RotationOrder" in u && (l.eulerOrder = E(u.RotationOrder.value)), "InheritType" in u && (l.inheritType = parseInt(u.InheritType.value)), "GeometricTranslation" in u && (l.translation = u.GeometricTranslation.value), "GeometricRotation" in u && (l.rotation = u.GeometricRotation.value), "GeometricScaling" in u && (l.scale = u.GeometricScaling.value); var c = g(l); return this.genGeometry(r, s, i, c) } }, genGeometry: function(e, t, r, a) { var n = new THREE.BufferGeometry;
                    e.attrName && (n.name = e.attrName); var i = this.parseGeoNode(e, t),
                        o = this.genBuffers(i),
                        s = new THREE.Float32BufferAttribute(o.vertex, 3); if (s.applyMatrix4(a), n.setAttribute("position", s), o.colors.length > 0 && n.setAttribute("color", new THREE.Float32BufferAttribute(o.colors, 3)), t && (n.setAttribute("skinIndex", new THREE.Uint16BufferAttribute(o.weightsIndices, 4)), n.setAttribute("skinWeight", new THREE.Float32BufferAttribute(o.vertexWeights, 4)), n.FBX_Deformer = t), o.normal.length > 0) { var u = (new THREE.Matrix3).getNormalMatrix(a),
                            l = new THREE.Float32BufferAttribute(o.normal, 3);
                        l.applyNormalMatrix(u), n.setAttribute("normal", l) } if (o.uvs.forEach(function(e, t) { var r = "uv" + (t + 1).toString();
                            0 === t && (r = "uv"), n.setAttribute(r, new THREE.Float32BufferAttribute(o.uvs[t], 2)) }), i.material && "AllSame" !== i.material.mappingType) { var c = o.materialIndex[0],
                            p = 0; if (o.materialIndex.forEach(function(e, t) { e !== c && (n.addGroup(p, t - p, c), c = e, p = t) }), n.groups.length > 0) { var h = n.groups[n.groups.length - 1],
                                f = h.start + h.count;
                            f !== o.materialIndex.length && n.addGroup(f, o.materialIndex.length - f, c) } 0 === n.groups.length && n.addGroup(0, o.materialIndex.length, o.materialIndex[0]) } return this.addMorphTargets(n, e, r, a), n }, parseGeoNode: function(e, t) { var r = {}; if (r.vertexPositions = void 0 !== e.Vertices ? e.Vertices.a : [], r.vertexIndices = void 0 !== e.PolygonVertexIndex ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (r.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (r.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (r.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) { r.uv = []; for (var a = 0; e.LayerElementUV[a];) r.uv.push(this.parseUVs(e.LayerElementUV[a])), a++ } return r.weightTable = {}, null !== t && (r.skeleton = t, t.rawBones.forEach(function(e, t) { e.indices.forEach(function(a, n) { void 0 === r.weightTable[a] && (r.weightTable[a] = []), r.weightTable[a].push({ id: t, weight: e.weights[n] }) }) })), r }, genBuffers: function(e) { var t = { vertex: [], normal: [], colors: [], uvs: [], materialIndex: [], vertexWeights: [], weightsIndices: [] },
                        r = 0,
                        a = 0,
                        n = !1,
                        i = [],
                        o = [],
                        s = [],
                        u = [],
                        l = [],
                        c = [],
                        p = this; return e.vertexIndices.forEach(function(h, f) { var v = !1;
                        h < 0 && (h ^= -1, v = !0); var m = [],
                            g = []; if (i.push(3 * h, 3 * h + 1, 3 * h + 2), e.color) { var E = d(f, r, h, e.color);
                            s.push(E[0], E[1], E[2]) } if (e.skeleton) { if (void 0 !== e.weightTable[h] && e.weightTable[h].forEach(function(e) { g.push(e.weight), m.push(e.id) }), g.length > 4) { n || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), n = !0); var y = [0, 0, 0, 0],
                                    T = [0, 0, 0, 0];
                                g.forEach(function(e, t) { var r = e,
                                        a = m[t];
                                    T.forEach(function(e, t, n) { if (r > e) { n[t] = r, r = e; var i = y[t];
                                            y[t] = a, a = i } }) }), m = y, g = T } for (; g.length < 4;) g.push(0), m.push(0); for (var R = 0; R < 4; ++R) l.push(g[R]), c.push(m[R]) } if (e.normal) { E = d(f, r, h, e.normal);
                            o.push(E[0], E[1], E[2]) } if (e.material && "AllSame" !== e.material.mappingType) var w = d(f, r, h, e.material)[0];
                        e.uv && e.uv.forEach(function(e, t) { var a = d(f, r, h, e);
                            void 0 === u[t] && (u[t] = []), u[t].push(a[0]), u[t].push(a[1]) }), a++, v && (p.genFace(t, e, i, w, o, s, u, l, c, a), r++, a = 0, i = [], o = [], s = [], u = [], l = [], c = []) }), t }, genFace: function(e, t, r, a, n, i, o, s, u, l) { for (var c = 2; c < l; c++) e.vertex.push(t.vertexPositions[r[0]]), e.vertex.push(t.vertexPositions[r[1]]), e.vertex.push(t.vertexPositions[r[2]]), e.vertex.push(t.vertexPositions[r[3 * (c - 1)]]), e.vertex.push(t.vertexPositions[r[3 * (c - 1) + 1]]), e.vertex.push(t.vertexPositions[r[3 * (c - 1) + 2]]), e.vertex.push(t.vertexPositions[r[3 * c]]), e.vertex.push(t.vertexPositions[r[3 * c + 1]]), e.vertex.push(t.vertexPositions[r[3 * c + 2]]), t.skeleton && (e.vertexWeights.push(s[0]), e.vertexWeights.push(s[1]), e.vertexWeights.push(s[2]), e.vertexWeights.push(s[3]), e.vertexWeights.push(s[4 * (c - 1)]), e.vertexWeights.push(s[4 * (c - 1) + 1]), e.vertexWeights.push(s[4 * (c - 1) + 2]), e.vertexWeights.push(s[4 * (c - 1) + 3]), e.vertexWeights.push(s[4 * c]), e.vertexWeights.push(s[4 * c + 1]), e.vertexWeights.push(s[4 * c + 2]), e.vertexWeights.push(s[4 * c + 3]), e.weightsIndices.push(u[0]), e.weightsIndices.push(u[1]), e.weightsIndices.push(u[2]), e.weightsIndices.push(u[3]), e.weightsIndices.push(u[4 * (c - 1)]), e.weightsIndices.push(u[4 * (c - 1) + 1]), e.weightsIndices.push(u[4 * (c - 1) + 2]), e.weightsIndices.push(u[4 * (c - 1) + 3]), e.weightsIndices.push(u[4 * c]), e.weightsIndices.push(u[4 * c + 1]), e.weightsIndices.push(u[4 * c + 2]), e.weightsIndices.push(u[4 * c + 3])), t.color && (e.colors.push(i[0]), e.colors.push(i[1]), e.colors.push(i[2]), e.colors.push(i[3 * (c - 1)]), e.colors.push(i[3 * (c - 1) + 1]), e.colors.push(i[3 * (c - 1) + 2]), e.colors.push(i[3 * c]), e.colors.push(i[3 * c + 1]), e.colors.push(i[3 * c + 2])), t.material && "AllSame" !== t.material.mappingType && (e.materialIndex.push(a), e.materialIndex.push(a), e.materialIndex.push(a)), t.normal && (e.normal.push(n[0]), e.normal.push(n[1]), e.normal.push(n[2]), e.normal.push(n[3 * (c - 1)]), e.normal.push(n[3 * (c - 1) + 1]), e.normal.push(n[3 * (c - 1) + 2]), e.normal.push(n[3 * c]), e.normal.push(n[3 * c + 1]), e.normal.push(n[3 * c + 2])), t.uv && t.uv.forEach(function(t, r) { void 0 === e.uvs[r] && (e.uvs[r] = []), e.uvs[r].push(o[r][0]), e.uvs[r].push(o[r][1]), e.uvs[r].push(o[r][2 * (c - 1)]), e.uvs[r].push(o[r][2 * (c - 1) + 1]), e.uvs[r].push(o[r][2 * c]), e.uvs[r].push(o[r][2 * c + 1]) }) }, addMorphTargets: function(t, r, a, n) { if (0 !== a.length) { t.morphTargetsRelative = !0, t.morphAttributes.position = []; var i = this;
                        a.forEach(function(a) { a.rawTargets.forEach(function(a) { var o = e.Objects.Geometry[a.geoID];
                                void 0 !== o && i.genMorphGeometry(t, r, o, n, a.name) }) }) } }, genMorphGeometry: function(e, t, r, a, n) { for (var i = void 0 !== t.PolygonVertexIndex ? t.PolygonVertexIndex.a : [], o = void 0 !== r.Vertices ? r.Vertices.a : [], s = void 0 !== r.Indexes ? r.Indexes.a : [], u = 3 * e.attributes.position.count, l = new Float32Array(u), c = 0; c < s.length; c++) { var p = 3 * s[c];
                        l[p] = o[3 * c], l[p + 1] = o[3 * c + 1], l[p + 2] = o[3 * c + 2] } var h = { vertexIndices: i, vertexPositions: l },
                        f = this.genBuffers(h),
                        d = new THREE.Float32BufferAttribute(f.vertex, 3);
                    d.name = n || r.attrName, d.applyMatrix4(a), e.morphAttributes.position.push(d) }, parseNormals: function(e) { var t = e.MappingInformationType,
                        r = e.ReferenceInformationType,
                        a = e.Normals.a,
                        n = []; return "IndexToDirect" === r && ("NormalIndex" in e ? n = e.NormalIndex.a : "NormalsIndex" in e && (n = e.NormalsIndex.a)), { dataSize: 3, buffer: a, indices: n, mappingType: t, referenceType: r } }, parseUVs: function(e) { var t = e.MappingInformationType,
                        r = e.ReferenceInformationType,
                        a = e.UV.a,
                        n = []; return "IndexToDirect" === r && (n = e.UVIndex.a), { dataSize: 2, buffer: a, indices: n, mappingType: t, referenceType: r } }, parseVertexColors: function(e) { var t = e.MappingInformationType,
                        r = e.ReferenceInformationType,
                        a = e.Colors.a,
                        n = []; return "IndexToDirect" === r && (n = e.ColorIndex.a), { dataSize: 4, buffer: a, indices: n, mappingType: t, referenceType: r } }, parseMaterialIndices: function(e) { var t = e.MappingInformationType,
                        r = e.ReferenceInformationType; if ("NoMappingInformation" === t) return { dataSize: 1, buffer: [0], indices: [0], mappingType: "AllSame", referenceType: r }; for (var a = e.Materials.a, n = [], i = 0; i < a.length; ++i) n.push(i); return { dataSize: 1, buffer: a, indices: n, mappingType: t, referenceType: r } }, parseNurbsGeometry: function(e) { if (void 0 === THREE.NURBSCurve) return console.error("THREE.FBXLoader: The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."), new THREE.BufferGeometry; var t = parseInt(e.Order); if (isNaN(t)) return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new THREE.BufferGeometry; for (var r, a, n = t - 1, i = e.KnotVector.a, o = [], s = e.Points.a, u = 0, l = s.length; u < l; u += 4) o.push((new THREE.Vector4).fromArray(s, u)); if ("Closed" === e.Form) o.push(o[0]);
                    else if ("Periodic" === e.Form) { r = n, a = i.length - 1 - r; for (u = 0; u < n; ++u) o.push(o[u]) } var c = new THREE.NURBSCurve(n, i, o, r, a).getPoints(7 * o.length),
                        p = new Float32Array(3 * c.length);
                    c.forEach(function(e, t) { e.toArray(p, 3 * t) }); var h = new THREE.BufferGeometry; return h.setAttribute("position", new THREE.BufferAttribute(p, 3)), h } }, o.prototype = { constructor: o, parse: function() { var e = [],
                        t = this.parseClips(); if (void 0 !== t)
                        for (var r in t) { var a = t[r],
                                n = this.addClip(a);
                            e.push(n) }
                    return e }, parseClips: function() { if (void 0 !== e.Objects.AnimationCurve) { var t = this.parseAnimationCurveNodes();
                        this.parseAnimationCurves(t); var r = this.parseAnimationLayers(t); return this.parseAnimStacks(r) } }, parseAnimationCurveNodes: function() { var t = e.Objects.AnimationCurveNode,
                        r = new Map; for (var a in t) { var n = t[a]; if (null !== n.attrName.match(/S|R|T|DeformPercent/)) { var i = { id: n.id, attr: n.attrName, curves: {} };
                            r.set(i.id, i) } } return r }, parseAnimationCurves: function(r) { var a = e.Objects.AnimationCurve; for (var n in a) { var i = { id: a[n].id, times: a[n].KeyTime.a.map(h), values: a[n].KeyValueFloat.a },
                            o = t.get(i.id); if (void 0 !== o) { var s = o.parents[0].ID,
                                u = o.parents[0].relationship;
                            u.match(/X/) ? r.get(s).curves.x = i : u.match(/Y/) ? r.get(s).curves.y = i : u.match(/Z/) ? r.get(s).curves.z = i : u.match(/d|DeformPercent/) && r.has(s) && (r.get(s).curves.morph = i) } } }, parseAnimationLayers: function(a) { var n = e.Objects.AnimationLayer,
                        i = new Map; for (var o in n) { var s = [],
                            u = t.get(parseInt(o)); if (void 0 !== u) u.children.forEach(function(n, i) { if (a.has(n.ID)) { var o = a.get(n.ID); if (void 0 !== o.curves.x || void 0 !== o.curves.y || void 0 !== o.curves.z) { if (void 0 === s[i])
                                        if (void 0 !== (f = t.get(n.ID).parents.filter(function(e) { return void 0 !== e.relationship })[0].ID)) { if (void 0 === (l = e.Objects.Model[f.toString()])) return void console.warn("THREE.FBXLoader: Encountered a unused curve.", n); var u = { modelName: l.attrName ? THREE.PropertyBinding.sanitizeNodeName(l.attrName) : "", ID: l.id, initialPosition: [0, 0, 0], initialRotation: [0, 0, 0], initialScale: [1, 1, 1] };
                                            r.traverse(function(e) { e.ID === l.id && (u.transform = e.matrix, e.userData.transformData && (u.eulerOrder = e.userData.transformData.eulerOrder)) }), u.transform || (u.transform = new THREE.Matrix4), "PreRotation" in l && (u.preRotation = l.PreRotation.value), "PostRotation" in l && (u.postRotation = l.PostRotation.value), s[i] = u } s[i] && (s[i][o.attr] = o) } else if (void 0 !== o.curves.morph) { if (void 0 === s[i]) { var l, c = t.get(n.ID).parents.filter(function(e) { return void 0 !== e.relationship })[0].ID,
                                            p = t.get(c).parents[0].ID,
                                            h = t.get(p).parents[0].ID,
                                            f = t.get(h).parents[0].ID;
                                        u = { modelName: (l = e.Objects.Model[f]).attrName ? THREE.PropertyBinding.sanitizeNodeName(l.attrName) : "", morphName: e.Objects.Deformer[c].attrName };
                                        s[i] = u } s[i][o.attr] = o } } }), i.set(parseInt(o), s) } return i }, parseAnimStacks: function(r) { var a = e.Objects.AnimationStack,
                        n = {}; for (var i in a) { var o = t.get(parseInt(i)).children;
                        o.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers."); var s = r.get(o[0].ID);
                        n[i] = { name: a[i].attrName, layer: s } } return n }, addClip: function(e) { var t = [],
                        r = this; return e.layer.forEach(function(e) { t = t.concat(r.generateTracks(e)) }), new THREE.AnimationClip(e.name, -1, t) }, generateTracks: function(e) { var t = [],
                        r = new THREE.Vector3,
                        a = new THREE.Quaternion,
                        n = new THREE.Vector3; if (e.transform && e.transform.decompose(r, a, n), r = r.toArray(), a = (new THREE.Euler).setFromQuaternion(a, e.eulerOrder).toArray(), n = n.toArray(), void 0 !== e.T && Object.keys(e.T.curves).length > 0) { var i = this.generateVectorTrack(e.modelName, e.T.curves, r, "position");
                        void 0 !== i && t.push(i) } if (void 0 !== e.R && Object.keys(e.R.curves).length > 0) { var o = this.generateRotationTrack(e.modelName, e.R.curves, a, e.preRotation, e.postRotation, e.eulerOrder);
                        void 0 !== o && t.push(o) } if (void 0 !== e.S && Object.keys(e.S.curves).length > 0) { var s = this.generateVectorTrack(e.modelName, e.S.curves, n, "scale");
                        void 0 !== s && t.push(s) } if (void 0 !== e.DeformPercent) { var u = this.generateMorphTrack(e);
                        void 0 !== u && t.push(u) } return t }, generateVectorTrack: function(e, t, r, a) { var n = this.getTimesForAllAxes(t),
                        i = this.getKeyframeTrackValues(n, t, r); return new THREE.VectorKeyframeTrack(e + "." + a, n, i) }, generateRotationTrack: function(e, t, r, a, n, i) { void 0 !== t.x && (this.interpolateRotations(t.x), t.x.values = t.x.values.map(THREE.MathUtils.degToRad)), void 0 !== t.y && (this.interpolateRotations(t.y), t.y.values = t.y.values.map(THREE.MathUtils.degToRad)), void 0 !== t.z && (this.interpolateRotations(t.z), t.z.values = t.z.values.map(THREE.MathUtils.degToRad)); var o = this.getTimesForAllAxes(t),
                        s = this.getKeyframeTrackValues(o, t, r);
                    void 0 !== a && ((a = a.map(THREE.MathUtils.degToRad)).push(i), a = (new THREE.Euler).fromArray(a), a = (new THREE.Quaternion).setFromEuler(a)), void 0 !== n && ((n = n.map(THREE.MathUtils.degToRad)).push(i), n = (new THREE.Euler).fromArray(n), n = (new THREE.Quaternion).setFromEuler(n).inverse()); for (var u = new THREE.Quaternion, l = new THREE.Euler, c = [], p = 0; p < s.length; p += 3) l.set(s[p], s[p + 1], s[p + 2], i), u.setFromEuler(l), void 0 !== a && u.premultiply(a), void 0 !== n && u.multiply(n), u.toArray(c, p / 3 * 4); return new THREE.QuaternionKeyframeTrack(e + ".quaternion", o, c) }, generateMorphTrack: function(e) { var t = e.DeformPercent.curves.morph,
                        a = t.values.map(function(e) { return e / 100 }),
                        n = r.getObjectByName(e.modelName).morphTargetDictionary[e.morphName]; return new THREE.NumberKeyframeTrack(e.modelName + ".morphTargetInfluences[" + n + "]", t.times, a) }, getTimesForAllAxes: function(e) { var t = []; return void 0 !== e.x && (t = t.concat(e.x.times)), void 0 !== e.y && (t = t.concat(e.y.times)), void 0 !== e.z && (t = t.concat(e.z.times)), t = t.sort(function(e, t) { return e - t }).filter(function(e, t, r) { return r.indexOf(e) == t }) }, getKeyframeTrackValues: function(e, t, r) { var a = r,
                        n = [],
                        i = -1,
                        o = -1,
                        s = -1; return e.forEach(function(e) { if (t.x && (i = t.x.times.indexOf(e)), t.y && (o = t.y.times.indexOf(e)), t.z && (s = t.z.times.indexOf(e)), -1 !== i) { var r = t.x.values[i];
                            n.push(r), a[0] = r } else n.push(a[0]); if (-1 !== o) { var u = t.y.values[o];
                            n.push(u), a[1] = u } else n.push(a[1]); if (-1 !== s) { var l = t.z.values[s];
                            n.push(l), a[2] = l } else n.push(a[2]) }), n }, interpolateRotations: function(e) { for (var t = 1; t < e.values.length; t++) { var r = e.values[t - 1],
                            a = e.values[t] - r,
                            n = Math.abs(a); if (n >= 180) { for (var i = n / 180, o = a / i, s = r + o, u = e.times[t - 1], l = (e.times[t] - u) / i, c = u + l, p = [], h = []; c < e.times[t];) p.push(c), c += l, h.push(s), s += o;
                            e.times = R(e.times, t, p), e.values = R(e.values, t, h) } } } }, s.prototype = { constructor: s, getPrevNode: function() { return this.nodeStack[this.currentIndent - 2] }, getCurrentNode: function() { return this.nodeStack[this.currentIndent - 1] }, getCurrentProp: function() { return this.currentProp }, pushStack: function(e) { this.nodeStack.push(e), this.currentIndent += 1 }, popStack: function() { this.nodeStack.pop(), this.currentIndent -= 1 }, setCurrentProp: function(e, t) { this.currentProp = e, this.currentPropName = t }, parse: function(e) { this.currentIndent = 0, this.allNodes = new c, this.nodeStack = [], this.currentProp = [], this.currentPropName = ""; var t = this,
                        r = e.split(/[\r\n]+/); return r.forEach(function(e, a) { var n = e.match(/^[\s\t]*;/),
                            i = e.match(/^[\s\t]*$/); if (!n && !i) { var o = e.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""),
                                s = e.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"),
                                u = e.match("^\\t{" + (t.currentIndent - 1) + "}}");
                            o ? t.parseNodeBegin(e, o) : s ? t.parseNodeProperty(e, s, r[++a]) : u ? t.popStack() : e.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(e) } }), this.allNodes }, parseNodeBegin: function(e, t) { var r = t[1].trim().replace(/^"/, "").replace(/"$/, ""),
                        a = t[2].split(",").map(function(e) { return e.trim().replace(/^"/, "").replace(/"$/, "") }),
                        n = { name: r },
                        i = this.parseNodeAttr(a),
                        o = this.getCurrentNode();
                    0 === this.currentIndent ? this.allNodes.add(r, n) : r in o ? ("PoseNode" === r ? o.PoseNode.push(n) : void 0 !== o[r].id && (o[r] = {}, o[r][o[r].id] = o[r]), "" !== i.id && (o[r][i.id] = n)) : "number" == typeof i.id ? (o[r] = {}, o[r][i.id] = n) : "Properties70" !== r && (o[r] = "PoseNode" === r ? [n] : n), "number" == typeof i.id && (n.id = i.id), "" !== i.name && (n.attrName = i.name), "" !== i.type && (n.attrType = i.type), this.pushStack(n) }, parseNodeAttr: function(e) { var t = e[0]; "" !== e[0] && (t = parseInt(e[0]), isNaN(t) && (t = e[0])); var r = "",
                        a = ""; return e.length > 1 && (r = e[1].replace(/^(\w+)::/, ""), a = e[2]), { id: t, name: r, type: a } }, parseNodeProperty: function(e, t, r) { var a = t[1].replace(/^"/, "").replace(/"$/, "").trim(),
                        n = t[2].replace(/^"/, "").replace(/"$/, "").trim(); "Content" === a && "," === n && (n = r.replace(/"/g, "").replace(/,$/, "").trim()); var i = this.getCurrentNode(); if ("Properties70" !== i.name) { if ("C" === a) { var o = n.split(",").slice(1),
                                s = parseInt(o[0]),
                                u = parseInt(o[1]),
                                l = n.split(",").slice(3);
                            a = "connections",
                                function(e, t) { for (var r = 0, a = e.length, n = t.length; r < n; r++, a++) e[a] = t[r] }(n = [s, u], l = l.map(function(e) { return e.trim().replace(/^"/, "") })), void 0 === i[a] && (i[a] = []) } "Node" === a && (i.id = n), a in i && Array.isArray(i[a]) ? i[a].push(n) : "a" !== a ? i[a] = n : i.a = n, this.setCurrentProp(i, a), "a" === a && "," !== n.slice(-1) && (i.a = y(n)) } else this.parseNodeSpecialProperty(e, a, n) }, parseNodePropertyContinued: function(e) { var t = this.getCurrentNode();
                    t.a += e, "," !== e.slice(-1) && (t.a = y(t.a)) }, parseNodeSpecialProperty: function(e, t, r) { var a = r.split('",').map(function(e) { return e.trim().replace(/^\"/, "").replace(/\s/, "_") }),
                        n = a[0],
                        i = a[1],
                        o = a[2],
                        s = a[3],
                        u = a[4]; switch (i) {
                        case "int":
                        case "enum":
                        case "bool":
                        case "ULongLong":
                        case "double":
                        case "Number":
                        case "FieldOfView":
                            u = parseFloat(u); break;
                        case "Color":
                        case "ColorRGB":
                        case "Vector3D":
                        case "Lcl_Translation":
                        case "Lcl_Rotation":
                        case "Lcl_Scaling":
                            u = y(u) } this.getPrevNode()[n] = { type: i, type2: o, flag: s, value: u }, this.setCurrentProp(this.getPrevNode(), n) } }, u.prototype = { constructor: u, parse: function(e) { var t = new l(e);
                    t.skip(23); for (var r = t.getUint32(), a = new c; !this.endOfContent(t);) { var n = this.parseNode(t, r);
                        null !== n && a.add(n.name, n) } return a }, endOfContent: function(e) { return e.size() % 16 == 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size() }, parseNode: function(e, t) { var r = {},
                        a = t >= 7500 ? e.getUint64() : e.getUint32(),
                        n = t >= 7500 ? e.getUint64() : e.getUint32();
                    t >= 7500 ? e.getUint64() : e.getUint32(); var i = e.getUint8(),
                        o = e.getString(i); if (0 === a) return null; for (var s = [], u = 0; u < n; u++) s.push(this.parseProperty(e)); var l = s.length > 0 ? s[0] : "",
                        c = s.length > 1 ? s[1] : "",
                        p = s.length > 2 ? s[2] : ""; for (r.singleProperty = 1 === n && e.getOffset() === a; a > e.getOffset();) { var h = this.parseNode(e, t);
                        null !== h && this.parseSubNode(o, r, h) } return r.propertyList = s, "number" == typeof l && (r.id = l), "" !== c && (r.attrName = c), "" !== p && (r.attrType = p), "" !== o && (r.name = o), r }, parseSubNode: function(e, t, r) { if (!0 === r.singleProperty) { var a = r.propertyList[0];
                        Array.isArray(a) ? (t[r.name] = r, r.a = a) : t[r.name] = a } else if ("Connections" === e && "C" === r.name) { var n = [];
                        r.propertyList.forEach(function(e, t) { 0 !== t && n.push(e) }), void 0 === t.connections && (t.connections = []), t.connections.push(n) } else if ("Properties70" === r.name) { Object.keys(r).forEach(function(e) { t[e] = r[e] }) } else if ("Properties70" === e && "P" === r.name) { var i, o = r.propertyList[0],
                            s = r.propertyList[1],
                            u = r.propertyList[2],
                            l = r.propertyList[3];
                        0 === o.indexOf("Lcl ") && (o = o.replace("Lcl ", "Lcl_")), 0 === s.indexOf("Lcl ") && (s = s.replace("Lcl ", "Lcl_")), i = "Color" === s || "ColorRGB" === s || "Vector" === s || "Vector3D" === s || 0 === s.indexOf("Lcl_") ? [r.propertyList[4], r.propertyList[5], r.propertyList[6]] : r.propertyList[4], t[o] = { type: s, type2: u, flag: l, value: i } } else void 0 === t[r.name] ? "number" == typeof r.id ? (t[r.name] = {}, t[r.name][r.id] = r) : t[r.name] = r : "PoseNode" === r.name ? (Array.isArray(t[r.name]) || (t[r.name] = [t[r.name]]), t[r.name].push(r)) : void 0 === t[r.name][r.id] && (t[r.name][r.id] = r) }, parseProperty: function(e) { var t = e.getString(1); switch (t) {
                        case "C":
                            return e.getBoolean();
                        case "D":
                            return e.getFloat64();
                        case "F":
                            return e.getFloat32();
                        case "I":
                            return e.getInt32();
                        case "L":
                            return e.getInt64();
                        case "R":
                            var r = e.getUint32(); return e.getArrayBuffer(r);
                        case "S":
                            r = e.getUint32(); return e.getString(r);
                        case "Y":
                            return e.getInt16();
                        case "b":
                        case "c":
                        case "d":
                        case "f":
                        case "i":
                        case "l":
                            var a = e.getUint32(),
                                n = e.getUint32(),
                                i = e.getUint32(); if (0 === n) switch (t) {
                                case "b":
                                case "c":
                                    return e.getBooleanArray(a);
                                case "d":
                                    return e.getFloat64Array(a);
                                case "f":
                                    return e.getFloat32Array(a);
                                case "i":
                                    return e.getInt32Array(a);
                                case "l":
                                    return e.getInt64Array(a) } void 0 === Zlib && console.error("THREE.FBXLoader: External library Inflate.min.js required, obtain or import from https://github.com/imaya/zlib.js"); var o = new l(new Zlib.Inflate(new Uint8Array(e.getArrayBuffer(i))).decompress().buffer); switch (t) {
                                case "b":
                                case "c":
                                    return o.getBooleanArray(a);
                                case "d":
                                    return o.getFloat64Array(a);
                                case "f":
                                    return o.getFloat32Array(a);
                                case "i":
                                    return o.getInt32Array(a);
                                case "l":
                                    return o.getInt64Array(a) }
                        default:
                            throw new Error("THREE.FBXLoader: Unknown property type " + t) } } }, l.prototype = { constructor: l, getOffset: function() { return this.offset }, size: function() { return this.dv.buffer.byteLength }, skip: function(e) { this.offset += e }, getBoolean: function() { return 1 == (1 & this.getUint8()) }, getBooleanArray: function(e) { for (var t = [], r = 0; r < e; r++) t.push(this.getBoolean()); return t }, getUint8: function() { var e = this.dv.getUint8(this.offset); return this.offset += 1, e }, getInt16: function() { var e = this.dv.getInt16(this.offset, this.littleEndian); return this.offset += 2, e }, getInt32: function() { var e = this.dv.getInt32(this.offset, this.littleEndian); return this.offset += 4, e }, getInt32Array: function(e) { for (var t = [], r = 0; r < e; r++) t.push(this.getInt32()); return t }, getUint32: function() { var e = this.dv.getUint32(this.offset, this.littleEndian); return this.offset += 4, e }, getInt64: function() { var e, t; return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), 2147483648 & t ? (t = 4294967295 & ~t, 4294967295 === (e = 4294967295 & ~e) && (t = t + 1 & 4294967295), -(4294967296 * t + (e = e + 1 & 4294967295))) : 4294967296 * t + e }, getInt64Array: function(e) { for (var t = [], r = 0; r < e; r++) t.push(this.getInt64()); return t }, getUint64: function() { var e, t; return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), 4294967296 * t + e }, getFloat32: function() { var e = this.dv.getFloat32(this.offset, this.littleEndian); return this.offset += 4, e }, getFloat32Array: function(e) { for (var t = [], r = 0; r < e; r++) t.push(this.getFloat32()); return t }, getFloat64: function() { var e = this.dv.getFloat64(this.offset, this.littleEndian); return this.offset += 8, e }, getFloat64Array: function(e) { for (var t = [], r = 0; r < e; r++) t.push(this.getFloat64()); return t }, getArrayBuffer: function(e) { var t = this.dv.buffer.slice(this.offset, this.offset + e); return this.offset += e, t }, getString: function(e) { for (var t = [], r = 0; r < e; r++) t[r] = this.getUint8(); var a = t.indexOf(0); return a >= 0 && (t = t.slice(0, a)), THREE.LoaderUtils.decodeText(new Uint8Array(t)) } }, c.prototype = { constructor: c, add: function(e, t) { this[e] = t } }; var f = [];

            function d(e, t, r, a) { var n; switch (a.mappingType) {
                    case "ByPolygonVertex":
                        n = e; break;
                    case "ByPolygon":
                        n = t; break;
                    case "ByVertice":
                        n = r; break;
                    case "AllSame":
                        n = a.indices[0]; break;
                    default:
                        console.warn("THREE.FBXLoader: unknown attribute mapping type " + a.mappingType) } "IndexToDirect" === a.referenceType && (n = a.indices[n]); var i = n * a.dataSize,
                    o = i + a.dataSize; return function(e, t, r, a) { for (var n = r, i = 0; n < a; n++, i++) e[i] = t[n]; return e }(f, a.buffer, i, o) } var v = new THREE.Euler,
                m = new THREE.Vector3;

            function g(e) { var t, r = new THREE.Matrix4,
                    a = new THREE.Matrix4,
                    n = new THREE.Matrix4,
                    i = new THREE.Matrix4,
                    o = new THREE.Matrix4,
                    s = new THREE.Matrix4,
                    u = new THREE.Matrix4,
                    l = new THREE.Matrix4,
                    c = new THREE.Matrix4,
                    p = new THREE.Matrix4,
                    h = new THREE.Matrix4,
                    f = e.inheritType ? e.inheritType : 0;
                (e.translation && r.setPosition(m.fromArray(e.translation)), e.preRotation) && ((t = e.preRotation.map(THREE.MathUtils.degToRad)).push(e.eulerOrder), a.makeRotationFromEuler(v.fromArray(t)));
                e.rotation && ((t = e.rotation.map(THREE.MathUtils.degToRad)).push(e.eulerOrder), n.makeRotationFromEuler(v.fromArray(t)));
                e.postRotation && ((t = e.postRotation.map(THREE.MathUtils.degToRad)).push(e.eulerOrder), i.makeRotationFromEuler(v.fromArray(t)));
                e.scale && o.scale(m.fromArray(e.scale)), e.scalingOffset && u.setPosition(m.fromArray(e.scalingOffset)), e.scalingPivot && s.setPosition(m.fromArray(e.scalingPivot)), e.rotationOffset && l.setPosition(m.fromArray(e.rotationOffset)), e.rotationPivot && c.setPosition(m.fromArray(e.rotationPivot)), e.parentMatrixWorld && (p = e.parentMatrixWorld); var d = a.multiply(n).multiply(i),
                    g = new THREE.Matrix4;
                p.extractRotation(g), (new THREE.Matrix4).copyPosition(p); var E = new THREE.Matrix4;
                E.getInverse(g).multiply(p); var y = new THREE.Matrix4; if (0 === f) y.copy(g).multiply(d).multiply(E).multiply(o);
                else if (1 === f) y.copy(g).multiply(E).multiply(d).multiply(o);
                else { var T = (new THREE.Matrix4).getInverse(o),
                        R = (new THREE.Matrix4).multiply(E).multiply(T);
                    y.copy(g).multiply(d).multiply(R).multiply(o) } var w = (new THREE.Matrix4).getInverse(c),
                    I = (new THREE.Matrix4).getInverse(s),
                    x = new THREE.Matrix4;
                x.copy(r).multiply(l).multiply(c).multiply(a).multiply(n).multiply(i).multiply(w).multiply(u).multiply(s).multiply(o).multiply(I); var b = (new THREE.Matrix4).copyPosition(x),
                    H = (new THREE.Matrix4).copy(p).multiply(b); return h.copyPosition(H), x = (new THREE.Matrix4).multiply(h).multiply(y) }

            function E(e) { var t = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"]; return 6 === (e = e || 0) ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), t[0]) : t[e] }

            function y(e) { return e.split(",").map(function(e) { return parseFloat(e) }) }

            function T(e, t, r) { return void 0 === t && (t = 0), void 0 === r && (r = e.byteLength), THREE.LoaderUtils.decodeText(new Uint8Array(e, t, r)) }

            function R(e, t, r) { return e.slice(0, t).concat(r).concat(e.slice(t)) } return a }(), module.exports = exports = THREE.FBXLoader;

    }, { "../../three.js": 23, "../Zlib.Inflate.js": 8 }],
    16: [function(require, module, exports) {
        const THREE = require("../../three.js");
        THREE.GLTFLoader = function() {
            function e(e) { THREE.Loader.call(this, e), this.dracoLoader = null, this.ddsLoader = null, this.pluginCallbacks = [], this.register(function(e) { return new i(e) }) }

            function t() { var e = {}; return { get: function(t) { return e[t] }, add: function(t, r) { e[t] = r }, remove: function(t) { delete e[t] }, removeAll: function() { e = {} } } } e.prototype = Object.assign(Object.create(THREE.Loader.prototype), { constructor: e, load: function(e, t, r, a) { var s, n = this;
                    s = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : THREE.LoaderUtils.extractUrlBase(e), n.manager.itemStart(e); var i = function(t) { a ? a(t) : console.error(t), n.manager.itemError(e), n.manager.itemEnd(e) },
                        o = new THREE.FileLoader(n.manager);
                    o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), "use-credentials" === n.crossOrigin && o.setWithCredentials(!0), o.load(e, function(r) { try { n.parse(r, s, function(r) { t(r), n.manager.itemEnd(e) }, i) } catch (e) { i(e) } }, r, i) }, setDRACOLoader: function(e) { return this.dracoLoader = e, this }, setDDSLoader: function(e) { return this.ddsLoader = e, this }, register: function(e) { return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this }, unregister: function(e) { return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this }, parse: function(e, t, i, l) { var c, d = {},
                        g = {}; if ("string" == typeof e) c = e;
                    else if (THREE.LoaderUtils.decodeText(new Uint8Array(e, 0, 4)) === o) { try { d[r.KHR_BINARY_GLTF] = new u(e) } catch (e) { return void(l && l(e)) } c = d[r.KHR_BINARY_GLTF].content } else c = THREE.LoaderUtils.decodeText(new Uint8Array(e)); var E = JSON.parse(c); if (void 0 === E.asset || E.asset.version[0] < 2) l && l(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
                    else { var T = new k(E, { path: t || this.resourcePath || "", crossOrigin: this.crossOrigin, manager: this.manager });
                        T.fileLoader.setRequestHeader(this.requestHeader); for (var v = 0; v < this.pluginCallbacks.length; v++) { var R = this.pluginCallbacks[v](T);
                            g[R.name] = R, d[R.name] = !0 } if (E.extensionsUsed)
                            for (v = 0; v < E.extensionsUsed.length; ++v) { var M = E.extensionsUsed[v],
                                    y = E.extensionsRequired || []; switch (M) {
                                    case r.KHR_LIGHTS_PUNCTUAL:
                                        d[M] = new s(E); break;
                                    case r.KHR_MATERIALS_UNLIT:
                                        d[M] = new n; break;
                                    case r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                                        d[M] = new m; break;
                                    case r.KHR_DRACO_MESH_COMPRESSION:
                                        d[M] = new p(E, this.dracoLoader); break;
                                    case r.MSFT_TEXTURE_DDS:
                                        d[M] = new a(this.ddsLoader); break;
                                    case r.KHR_TEXTURE_TRANSFORM:
                                        d[M] = new h; break;
                                    case r.KHR_MESH_QUANTIZATION:
                                        d[M] = new f; break;
                                    default:
                                        y.indexOf(M) >= 0 && void 0 === g[M] && console.warn('THREE.GLTFLoader: Unknown extension "' + M + '".') } } T.setExtensions(d), T.setPlugins(g), T.parse(i, l) } } }); var r = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", MSFT_TEXTURE_DDS: "MSFT_texture_dds" };

            function a(e) { if (!e) throw new Error("THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader");
                this.name = r.MSFT_TEXTURE_DDS, this.ddsLoader = e }

            function s(e) { this.name = r.KHR_LIGHTS_PUNCTUAL; var t = e.extensions && e.extensions[r.KHR_LIGHTS_PUNCTUAL] || {};
                this.lightDefs = t.lights || [] }

            function n() { this.name = r.KHR_MATERIALS_UNLIT }

            function i(e) { this.parser = e, this.name = r.KHR_MATERIALS_CLEARCOAT } s.prototype.loadLight = function(e) { var t, r = this.lightDefs[e],
                    a = new THREE.Color(16777215);
                void 0 !== r.color && a.fromArray(r.color); var s = void 0 !== r.range ? r.range : 0; switch (r.type) {
                    case "directional":
                        (t = new THREE.DirectionalLight(a)).target.position.set(0, 0, -1), t.add(t.target); break;
                    case "point":
                        (t = new THREE.PointLight(a)).distance = s; break;
                    case "spot":
                        (t = new THREE.SpotLight(a)).distance = s, r.spot = r.spot || {}, r.spot.innerConeAngle = void 0 !== r.spot.innerConeAngle ? r.spot.innerConeAngle : 0, r.spot.outerConeAngle = void 0 !== r.spot.outerConeAngle ? r.spot.outerConeAngle : Math.PI / 4, t.angle = r.spot.outerConeAngle, t.penumbra = 1 - r.spot.innerConeAngle / r.spot.outerConeAngle, t.target.position.set(0, 0, -1), t.add(t.target); break;
                    default:
                        throw new Error('THREE.GLTFLoader: Unexpected light type, "' + r.type + '".') } return t.position.set(0, 0, 0), t.decay = 2, void 0 !== r.intensity && (t.intensity = r.intensity), t.name = r.name || "light_" + e, Promise.resolve(t) }, n.prototype.getMaterialType = function() { return THREE.MeshBasicMaterial }, n.prototype.extendParams = function(e, t, r) { var a = [];
                e.color = new THREE.Color(1, 1, 1), e.opacity = 1; var s = t.pbrMetallicRoughness; if (s) { if (Array.isArray(s.baseColorFactor)) { var n = s.baseColorFactor;
                        e.color.fromArray(n), e.opacity = n[3] } void 0 !== s.baseColorTexture && a.push(r.assignTexture(e, "map", s.baseColorTexture)) } return Promise.all(a) }, i.prototype.getMaterialType = function() { return THREE.MeshPhysicalMaterial }, i.prototype.extendMaterialParams = function(e, t) { var r = this.parser,
                    a = r.json.materials[e]; if (!a.extensions || !a.extensions[this.name]) return Promise.resolve(); var s = [],
                    n = a.extensions[this.name]; if (void 0 !== n.clearcoatFactor && (t.clearcoat = n.clearcoatFactor), void 0 !== n.clearcoatTexture && s.push(r.assignTexture(t, "clearcoatMap", n.clearcoatTexture)), void 0 !== n.clearcoatRoughnessFactor && (t.clearcoatRoughness = n.clearcoatRoughnessFactor), void 0 !== n.clearcoatRoughnessTexture && s.push(r.assignTexture(t, "clearcoatRoughnessMap", n.clearcoatRoughnessTexture)), void 0 !== n.clearcoatNormalTexture && (s.push(r.assignTexture(t, "clearcoatNormalMap", n.clearcoatNormalTexture)), void 0 !== n.clearcoatNormalTexture.scale)) { var i = n.clearcoatNormalTexture.scale;
                    t.clearcoatNormalScale = new THREE.Vector2(i, i) } return Promise.all(s) }; var o = "glTF",
                l = 12,
                c = { JSON: 1313821514, BIN: 5130562 };

            function u(e) { this.name = r.KHR_BINARY_GLTF, this.content = null, this.body = null; var t = new DataView(e, 0, l); if (this.header = { magic: THREE.LoaderUtils.decodeText(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, !0), length: t.getUint32(8, !0) }, this.header.magic !== o) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header."); if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected."); for (var a = new DataView(e, l), s = 0; s < a.byteLength;) { var n = a.getUint32(s, !0);
                    s += 4; var i = a.getUint32(s, !0); if (s += 4, i === c.JSON) { var u = new Uint8Array(e, l + s, n);
                        this.content = THREE.LoaderUtils.decodeText(u) } else if (i === c.BIN) { var p = l + s;
                        this.body = e.slice(p, p + n) } s += n } if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.") }

            function p(e, t) { if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                this.name = r.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload() }

            function h() { this.name = r.KHR_TEXTURE_TRANSFORM }

            function d(e) { THREE.MeshStandardMaterial.call(this), this.isGLTFSpecularGlossinessMaterial = !0; var t = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"),
                    r = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"),
                    a = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"),
                    s = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"),
                    n = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb;", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor.rgb;"].join("\n"),
                    i = { specular: { value: (new THREE.Color).setHex(16777215) }, glossiness: { value: 1 }, specularMap: { value: null }, glossinessMap: { value: null } };
                this._extraUniforms = i, this.onBeforeCompile = function(e) { for (var o in i) e.uniforms[o] = i[o];
                    e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;"), e.fragmentShader = e.fragmentShader.replace("uniform float metalness;", "uniform float glossiness;"), e.fragmentShader = e.fragmentShader.replace("#include <roughnessmap_pars_fragment>", t), e.fragmentShader = e.fragmentShader.replace("#include <metalnessmap_pars_fragment>", r), e.fragmentShader = e.fragmentShader.replace("#include <roughnessmap_fragment>", a), e.fragmentShader = e.fragmentShader.replace("#include <metalnessmap_fragment>", s), e.fragmentShader = e.fragmentShader.replace("#include <lights_physical_fragment>", n) }, Object.defineProperties(this, { specular: { get: function() { return i.specular.value }, set: function(e) { i.specular.value = e } }, specularMap: { get: function() { return i.specularMap.value }, set: function(e) { i.specularMap.value = e } }, glossiness: { get: function() { return i.glossiness.value }, set: function(e) { i.glossiness.value = e } }, glossinessMap: { get: function() { return i.glossinessMap.value }, set: function(e) { i.glossinessMap.value = e, e ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_ROUGHNESSMAP = "") : (delete this.defines.USE_ROUGHNESSMAP, delete this.defines.USE_GLOSSINESSMAP) } } }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e) }

            function m() { return { name: r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, specularGlossinessParams: ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"], getMaterialType: function() { return d }, extendParams: function(e, t, r) { var a = t.extensions[this.name];
                        e.color = new THREE.Color(1, 1, 1), e.opacity = 1; var s = []; if (Array.isArray(a.diffuseFactor)) { var n = a.diffuseFactor;
                            e.color.fromArray(n), e.opacity = n[3] } if (void 0 !== a.diffuseTexture && s.push(r.assignTexture(e, "map", a.diffuseTexture)), e.emissive = new THREE.Color(0, 0, 0), e.glossiness = void 0 !== a.glossinessFactor ? a.glossinessFactor : 1, e.specular = new THREE.Color(1, 1, 1), Array.isArray(a.specularFactor) && e.specular.fromArray(a.specularFactor), void 0 !== a.specularGlossinessTexture) { var i = a.specularGlossinessTexture;
                            s.push(r.assignTexture(e, "glossinessMap", i)), s.push(r.assignTexture(e, "specularMap", i)) } return Promise.all(s) }, createMaterial: function(e) { var t = new d(e); return t.fog = !0, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = 1, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, t.normalMapType = THREE.TangentSpaceNormalMap, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = .98, t } } }

            function f() { this.name = r.KHR_MESH_QUANTIZATION }

            function g(e, t, r, a) { THREE.Interpolant.call(this, e, t, r, a) } p.prototype.decodePrimitive = function(e, t) { var r = this.json,
                    a = this.dracoLoader,
                    s = e.extensions[this.name].bufferView,
                    n = e.extensions[this.name].attributes,
                    i = {},
                    o = {},
                    l = {}; for (var c in n) { var u = w[c] || c.toLowerCase();
                    i[u] = n[c] } for (c in e.attributes) { u = w[c] || c.toLowerCase(); if (void 0 !== n[c]) { var p = r.accessors[e.attributes[c]],
                            h = x[p.componentType];
                        l[u] = h, o[u] = !0 === p.normalized } } return t.getDependency("bufferView", s).then(function(e) { return new Promise(function(t) { a.decodeDracoFile(e, function(e) { for (var r in e.attributes) { var a = e.attributes[r],
                                    s = o[r];
                                void 0 !== s && (a.normalized = s) } t(e) }, i, l) }) }) }, h.prototype.extendTexture = function(e, t) { return e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), e.needsUpdate = !0, e }, d.prototype = Object.create(THREE.MeshStandardMaterial.prototype), d.prototype.constructor = d, d.prototype.copy = function(e) { return THREE.MeshStandardMaterial.prototype.copy.call(this, e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this }, g.prototype = Object.create(THREE.Interpolant.prototype), g.prototype.constructor = g, g.prototype.copySampleValue_ = function(e) { for (var t = this.resultBuffer, r = this.sampleValues, a = this.valueSize, s = e * a * 3 + a, n = 0; n !== a; n++) t[n] = r[s + n]; return t }, g.prototype.beforeStart_ = g.prototype.copySampleValue_, g.prototype.afterEnd_ = g.prototype.copySampleValue_, g.prototype.interpolate_ = function(e, t, r, a) { for (var s = this.resultBuffer, n = this.sampleValues, i = this.valueSize, o = 2 * i, l = 3 * i, c = a - t, u = (r - t) / c, p = u * u, h = p * u, d = e * l, m = d - l, f = -2 * h + 3 * p, g = h - p, E = 1 - f, T = g - p + u, v = 0; v !== i; v++) { var R = n[m + v + i],
                        M = n[m + v + o] * c,
                        y = n[d + v + i],
                        S = n[d + v] * c;
                    s[v] = E * R + T * M + f * y + g * S } return s }; var E = 0,
                T = 1,
                v = 2,
                R = 3,
                M = 4,
                y = 5,
                S = 6,
                x = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array },
                H = { 9728: THREE.NearestFilter, 9729: THREE.LinearFilter, 9984: THREE.NearestMipmapNearestFilter, 9985: THREE.LinearMipmapNearestFilter, 9986: THREE.NearestMipmapLinearFilter, 9987: THREE.LinearMipmapLinearFilter },
                L = { 33071: THREE.ClampToEdgeWrapping, 33648: THREE.MirroredRepeatWrapping, 10497: THREE.RepeatWrapping },
                _ = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
                w = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" },
                A = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" },
                b = { CUBICSPLINE: void 0, LINEAR: THREE.InterpolateLinear, STEP: THREE.InterpolateDiscrete },
                I = "OPAQUE",
                P = "MASK",
                O = "BLEND",
                C = { "image/png": THREE.RGBAFormat, "image/jpeg": THREE.RGBFormat };

            function F(e, t) { return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) ? e : /^data:.*,.*$/i.test(e) ? e : /^blob:.*$/i.test(e) ? e : t + e) }

            function N(e, t, r) { for (var a in r.extensions) void 0 === e[a] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[a] = r.extensions[a]) }

            function U(e, t) { void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras)) }

            function D(e, t) { if (e.updateMorphTargets(), void 0 !== t.weights)
                    for (var r = 0, a = t.weights.length; r < a; r++) e.morphTargetInfluences[r] = t.weights[r]; if (t.extras && Array.isArray(t.extras.targetNames)) { var s = t.extras.targetNames; if (e.morphTargetInfluences.length === s.length) { e.morphTargetDictionary = {}; for (r = 0, a = s.length; r < a; r++) e.morphTargetDictionary[s[r]] = r } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.") } }

            function G(e) { for (var t = "", r = Object.keys(e).sort(), a = 0, s = r.length; a < s; a++) t += r[a] + ":" + e[r[a]] + ";"; return t }

            function k(e, r) { this.json = e || {}, this.extensions = {}, this.plugins = {}, this.options = r || {}, this.cache = new t, this.associations = new Map, this.primitiveCache = {}, this.useImageBitmap = "undefined" != typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent), this.useImageBitmap ? this.textureLoader = new THREE.ImageBitmapLoader(this.options.manager) : this.textureLoader = new THREE.TextureLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.fileLoader = new THREE.FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0) }

            function B(e, t, r) { var a = t.attributes,
                    s = [];

                function n(t, a) { return r.getDependency("accessor", t).then(function(t) { e.setAttribute(a, t) }) } for (var i in a) { var o = w[i] || i.toLowerCase();
                    o in e.attributes || s.push(n(a[i], o)) } if (void 0 !== t.indices && !e.index) { var l = r.getDependency("accessor", t.indices).then(function(t) { e.setIndex(t) });
                    s.push(l) } return U(e, t),
                    function(e, t, r) { var a = t.attributes,
                            s = new THREE.Box3; if (void 0 !== a.POSITION) { var n = (h = r.json.accessors[a.POSITION]).min,
                                i = h.max; if (void 0 !== n && void 0 !== i) { s.set(new THREE.Vector3(n[0], n[1], n[2]), new THREE.Vector3(i[0], i[1], i[2])); var o = t.targets; if (void 0 !== o) { for (var l = new THREE.Vector3, c = new THREE.Vector3, u = 0, p = o.length; u < p; u++) { var h, d = o[u]; if (void 0 !== d.POSITION) n = (h = r.json.accessors[d.POSITION]).min, i = h.max, void 0 !== n && void 0 !== i ? (c.setX(Math.max(Math.abs(n[0]), Math.abs(i[0]))), c.setY(Math.max(Math.abs(n[1]), Math.abs(i[1]))), c.setZ(Math.max(Math.abs(n[2]), Math.abs(i[2]))), l.max(c)) : console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.") } s.expandByVector(l) } e.boundingBox = s; var m = new THREE.Sphere;
                                s.getCenter(m.center), m.radius = s.min.distanceTo(s.max) / 2, e.boundingSphere = m } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.") } }(e, t, r), Promise.all(s).then(function() { return void 0 !== t.targets ? function(e, t, r) { for (var a = !1, s = !1, n = 0, i = t.length; n < i && (void 0 !== (c = t[n]).POSITION && (a = !0), void 0 !== c.NORMAL && (s = !0), !a || !s); n++); if (!a && !s) return Promise.resolve(e); var o = [],
                                l = []; for (n = 0, i = t.length; n < i; n++) { var c = t[n]; if (a) { var u = void 0 !== c.POSITION ? r.getDependency("accessor", c.POSITION) : e.attributes.position;
                                    o.push(u) } s && (u = void 0 !== c.NORMAL ? r.getDependency("accessor", c.NORMAL) : e.attributes.normal, l.push(u)) } return Promise.all([Promise.all(o), Promise.all(l)]).then(function(t) { var r = t[0],
                                    n = t[1]; return a && (e.morphAttributes.position = r), s && (e.morphAttributes.normal = n), e.morphTargetsRelative = !0, e }) }(e, t.targets, r) : e }) }

            function j(e, t) { var r = e.getIndex(); if (null === r) { var a = [],
                        s = e.getAttribute("position"); if (void 0 === s) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e; for (var n = 0; n < s.count; n++) a.push(n);
                    e.setIndex(a), r = e.getIndex() } var i = r.count - 2,
                    o = []; if (t === THREE.TriangleFanDrawMode)
                    for (n = 1; n <= i; n++) o.push(r.getX(0)), o.push(r.getX(n)), o.push(r.getX(n + 1));
                else
                    for (n = 0; n < i; n++) n % 2 == 0 ? (o.push(r.getX(n)), o.push(r.getX(n + 1)), o.push(r.getX(n + 2))) : (o.push(r.getX(n + 2)), o.push(r.getX(n + 1)), o.push(r.getX(n)));
                o.length / 3 !== i && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."); var l = e.clone(); return l.setIndex(o), l } return k.prototype.setExtensions = function(e) { this.extensions = e }, k.prototype.setPlugins = function(e) { this.plugins = e }, k.prototype.parse = function(e, t) { var r = this,
                    a = this.json,
                    s = this.extensions;
                this.cache.removeAll(), this.markDefs(), Promise.all([this.getDependencies("scene"), this.getDependencies("animation"), this.getDependencies("camera")]).then(function(t) { var n = { scene: t[0][a.scene || 0], scenes: t[0], animations: t[1], cameras: t[2], asset: a.asset, parser: r, userData: {} };
                    N(s, n, a), U(n, a), e(n) }).catch(t) }, k.prototype.markDefs = function() { for (var e = this.json.nodes || [], t = this.json.skins || [], r = this.json.meshes || [], a = {}, s = {}, n = 0, i = t.length; n < i; n++)
                    for (var o = t[n].joints, l = 0, c = o.length; l < c; l++) e[o[l]].isBone = !0; for (var u = 0, p = e.length; u < p; u++) { var h = e[u];
                    void 0 !== h.mesh && (void 0 === a[h.mesh] && (a[h.mesh] = s[h.mesh] = 0), a[h.mesh]++, void 0 !== h.skin && (r[h.mesh].isSkinnedMesh = !0)) } this.json.meshReferences = a, this.json.meshUses = s }, k.prototype._invokeOne = function(e) { var t = Object.values(this.plugins);
                t.push(this); for (var r = 0; r < t.length; r++) { var a = e(t[r]); if (a) return a } }, k.prototype._invokeAll = function(e) { var t = Object.values(this.plugins);
                t.unshift(this); for (var r = [], a = 0; a < t.length; a++) r.push(e(t[a])); return Promise.all(r) }, k.prototype.getDependency = function(e, t) { var a = e + ":" + t,
                    s = this.cache.get(a); if (!s) { switch (e) {
                        case "scene":
                            s = this.loadScene(t); break;
                        case "node":
                            s = this.loadNode(t); break;
                        case "mesh":
                            s = this._invokeOne(function(e) { return e.loadMesh && e.loadMesh(t) }); break;
                        case "accessor":
                            s = this.loadAccessor(t); break;
                        case "bufferView":
                            s = this._invokeOne(function(e) { return e.loadBufferView && e.loadBufferView(t) }); break;
                        case "buffer":
                            s = this.loadBuffer(t); break;
                        case "material":
                            s = this._invokeOne(function(e) { return e.loadMaterial && e.loadMaterial(t) }); break;
                        case "texture":
                            s = this.loadTexture(t); break;
                        case "skin":
                            s = this.loadSkin(t); break;
                        case "animation":
                            s = this.loadAnimation(t); break;
                        case "camera":
                            s = this.loadCamera(t); break;
                        case "light":
                            s = this.extensions[r.KHR_LIGHTS_PUNCTUAL].loadLight(t); break;
                        default:
                            throw new Error("Unknown type: " + e) } this.cache.add(a, s) } return s }, k.prototype.getDependencies = function(e) { var t = this.cache.get(e); if (!t) { var r = this,
                        a = this.json[e + ("mesh" === e ? "es" : "s")] || [];
                    t = Promise.all(a.map(function(t, a) { return r.getDependency(e, a) })), this.cache.add(e, t) } return t }, k.prototype.loadBuffer = function(e) { var t = this.json.buffers[e],
                    a = this.fileLoader; if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported."); if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[r.KHR_BINARY_GLTF].body); var s = this.options; return new Promise(function(e, r) { a.load(F(t.uri, s.path), e, void 0, function() { r(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')) }) }) }, k.prototype.loadBufferView = function(e) { var t = this.json.bufferViews[e]; return this.getDependency("buffer", t.buffer).then(function(e) { var r = t.byteLength || 0,
                        a = t.byteOffset || 0; return e.slice(a, a + r) }) }, k.prototype.loadAccessor = function(e) { var t = this,
                    r = this.json,
                    a = this.json.accessors[e]; if (void 0 === a.bufferView && void 0 === a.sparse) return Promise.resolve(null); var s = []; return void 0 !== a.bufferView ? s.push(this.getDependency("bufferView", a.bufferView)) : s.push(null), void 0 !== a.sparse && (s.push(this.getDependency("bufferView", a.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", a.sparse.values.bufferView))), Promise.all(s).then(function(e) { var s, n, i = e[0],
                        o = _[a.type],
                        l = x[a.componentType],
                        c = l.BYTES_PER_ELEMENT,
                        u = c * o,
                        p = a.byteOffset || 0,
                        h = void 0 !== a.bufferView ? r.bufferViews[a.bufferView].byteStride : void 0,
                        d = !0 === a.normalized; if (h && h !== u) { var m = Math.floor(p / h),
                            f = "InterleavedBuffer:" + a.bufferView + ":" + a.componentType + ":" + m + ":" + a.count,
                            g = t.cache.get(f);
                        g || (s = new l(i, m * h, a.count * h / c), g = new THREE.InterleavedBuffer(s, h / c), t.cache.add(f, g)), n = new THREE.InterleavedBufferAttribute(g, o, p % h / c, d) } else s = null === i ? new l(a.count * o) : new l(i, p, a.count * o), n = new THREE.BufferAttribute(s, o, d); if (void 0 !== a.sparse) { var E = _.SCALAR,
                            T = x[a.sparse.indices.componentType],
                            v = a.sparse.indices.byteOffset || 0,
                            R = a.sparse.values.byteOffset || 0,
                            M = new T(e[1], v, a.sparse.count * E),
                            y = new l(e[2], R, a.sparse.count * o);
                        null !== i && (n = new THREE.BufferAttribute(n.array.slice(), n.itemSize, n.normalized)); for (var S = 0, H = M.length; S < H; S++) { var L = M[S]; if (n.setX(L, y[S * o]), o >= 2 && n.setY(L, y[S * o + 1]), o >= 3 && n.setZ(L, y[S * o + 2]), o >= 4 && n.setW(L, y[S * o + 3]), o >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.") } } return n }) }, k.prototype.loadTexture = function(e) { var t, a = this,
                    s = this.json,
                    n = this.options,
                    i = this.useImageBitmap,
                    o = this.textureLoader,
                    l = self.URL || self.webkitURL,
                    c = s.textures[e],
                    u = c.extensions || {},
                    p = (t = u[r.MSFT_TEXTURE_DDS] ? s.images[u[r.MSFT_TEXTURE_DDS].source] : s.images[c.source]).uri,
                    h = !1; return void 0 !== t.bufferView && (p = a.getDependency("bufferView", t.bufferView).then(function(e) { h = !0; var r = new Blob([e], { type: t.mimeType }); return p = l.createObjectURL(r) })), Promise.resolve(p).then(function(e) { var t = n.manager.getHandler(e); return t || (t = u[r.MSFT_TEXTURE_DDS] ? a.extensions[r.MSFT_TEXTURE_DDS].ddsLoader : o), new Promise(function(r, a) { var s = r;
                        i && (s = function(e) { r(new THREE.CanvasTexture(e)) }), t.load(F(e, n.path), s, void 0, a) }) }).then(function(r) {!0 === h && l.revokeObjectURL(p), r.flipY = !1, c.name && (r.name = c.name), t.mimeType in C && (r.format = C[t.mimeType]); var n = (s.samplers || {})[c.sampler] || {}; return r.magFilter = H[n.magFilter] || THREE.LinearFilter, r.minFilter = H[n.minFilter] || THREE.LinearMipmapLinearFilter, r.wrapS = L[n.wrapS] || THREE.RepeatWrapping, r.wrapT = L[n.wrapT] || THREE.RepeatWrapping, a.associations.set(r, { type: "textures", index: e }), r }) }, k.prototype.assignTexture = function(e, t, a) { var s = this; return this.getDependency("texture", a.index).then(function(n) { if (!n.isCompressedTexture) switch (t) {
                        case "aoMap":
                        case "emissiveMap":
                        case "metalnessMap":
                        case "normalMap":
                        case "roughnessMap":
                            n.format = THREE.RGBFormat }
                    if (void 0 === a.texCoord || 0 == a.texCoord || "aoMap" === t && 1 == a.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + a.texCoord + " for texture " + t + " not yet supported."), s.extensions[r.KHR_TEXTURE_TRANSFORM]) { var i = void 0 !== a.extensions ? a.extensions[r.KHR_TEXTURE_TRANSFORM] : void 0; if (i) { var o = s.associations.get(n);
                            n = s.extensions[r.KHR_TEXTURE_TRANSFORM].extendTexture(n, i), s.associations.set(n, o) } } e[t] = n }) }, k.prototype.assignFinalMaterial = function(e) { var t = e.geometry,
                    r = e.material,
                    a = void 0 !== t.attributes.tangent,
                    s = void 0 !== t.attributes.color,
                    n = void 0 === t.attributes.normal,
                    i = !0 === e.isSkinnedMesh,
                    o = Object.keys(t.morphAttributes).length > 0,
                    l = o && void 0 !== t.morphAttributes.normal; if (e.isPoints) { var c = "PointsMaterial:" + r.uuid,
                        u = this.cache.get(c);
                    u || (u = new THREE.PointsMaterial, THREE.Material.prototype.copy.call(u, r), u.color.copy(r.color), u.map = r.map, u.sizeAttenuation = !1, this.cache.add(c, u)), r = u } else if (e.isLine) { c = "LineBasicMaterial:" + r.uuid; var p = this.cache.get(c);
                    p || (p = new THREE.LineBasicMaterial, THREE.Material.prototype.copy.call(p, r), p.color.copy(r.color), this.cache.add(c, p)), r = p } if (a || s || n || i || o) { c = "ClonedMaterial:" + r.uuid + ":";
                    r.isGLTFSpecularGlossinessMaterial && (c += "specular-glossiness:"), i && (c += "skinning:"), a && (c += "vertex-tangents:"), s && (c += "vertex-colors:"), n && (c += "flat-shading:"), o && (c += "morph-targets:"), l && (c += "morph-normals:"); var h = this.cache.get(c);
                    h || (h = r.clone(), i && (h.skinning = !0), a && (h.vertexTangents = !0), s && (h.vertexColors = !0), n && (h.flatShading = !0), o && (h.morphTargets = !0), l && (h.morphNormals = !0), this.cache.add(c, h), this.associations.set(h, this.associations.get(r))), r = h } r.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv), r.normalScale && !a && (r.normalScale.y = -r.normalScale.y), r.clearcoatNormalScale && !a && (r.clearcoatNormalScale.y = -r.clearcoatNormalScale.y), e.material = r }, k.prototype.getMaterialType = function() { return THREE.MeshStandardMaterial }, k.prototype.loadMaterial = function(e) { var t, a = this,
                    s = this.json,
                    n = this.extensions,
                    i = s.materials[e],
                    o = {},
                    l = i.extensions || {},
                    c = []; if (l[r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) { var u = n[r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                    t = u.getMaterialType(), c.push(u.extendParams(o, i, a)) } else if (l[r.KHR_MATERIALS_UNLIT]) { var p = n[r.KHR_MATERIALS_UNLIT];
                    t = p.getMaterialType(), c.push(p.extendParams(o, i, a)) } else { var h = i.pbrMetallicRoughness || {}; if (o.color = new THREE.Color(1, 1, 1), o.opacity = 1, Array.isArray(h.baseColorFactor)) { var m = h.baseColorFactor;
                        o.color.fromArray(m), o.opacity = m[3] } void 0 !== h.baseColorTexture && c.push(a.assignTexture(o, "map", h.baseColorTexture)), o.metalness = void 0 !== h.metallicFactor ? h.metallicFactor : 1, o.roughness = void 0 !== h.roughnessFactor ? h.roughnessFactor : 1, void 0 !== h.metallicRoughnessTexture && (c.push(a.assignTexture(o, "metalnessMap", h.metallicRoughnessTexture)), c.push(a.assignTexture(o, "roughnessMap", h.metallicRoughnessTexture))), t = this._invokeOne(function(t) { return t.getMaterialType && t.getMaterialType(e) }), c.push(this._invokeAll(function(t) { return t.extendMaterialParams && t.extendMaterialParams(e, o) })) }!0 === i.doubleSided && (o.side = THREE.DoubleSide); var f = i.alphaMode || I; return f === O ? (o.transparent = !0, o.depthWrite = !1) : (o.transparent = !1, f === P && (o.alphaTest = void 0 !== i.alphaCutoff ? i.alphaCutoff : .5)), void 0 !== i.normalTexture && t !== THREE.MeshBasicMaterial && (c.push(a.assignTexture(o, "normalMap", i.normalTexture)), o.normalScale = new THREE.Vector2(1, 1), void 0 !== i.normalTexture.scale && o.normalScale.set(i.normalTexture.scale, i.normalTexture.scale)), void 0 !== i.occlusionTexture && t !== THREE.MeshBasicMaterial && (c.push(a.assignTexture(o, "aoMap", i.occlusionTexture)), void 0 !== i.occlusionTexture.strength && (o.aoMapIntensity = i.occlusionTexture.strength)), void 0 !== i.emissiveFactor && t !== THREE.MeshBasicMaterial && (o.emissive = (new THREE.Color).fromArray(i.emissiveFactor)), void 0 !== i.emissiveTexture && t !== THREE.MeshBasicMaterial && c.push(a.assignTexture(o, "emissiveMap", i.emissiveTexture)), Promise.all(c).then(function() { var s; return s = t === d ? n[r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(o) : new t(o), i.name && (s.name = i.name), s.map && (s.map.encoding = THREE.sRGBEncoding), s.emissiveMap && (s.emissiveMap.encoding = THREE.sRGBEncoding), U(s, i), a.associations.set(s, { type: "materials", index: e }), i.extensions && N(n, s, i), s }) }, k.prototype.loadGeometries = function(e) { var t = this,
                    a = this.extensions,
                    s = this.primitiveCache;

                function n(e) { return a[r.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then(function(r) { return B(r, e, t) }) } for (var i, o, l = [], c = 0, u = e.length; c < u; c++) { var p, h = e[c],
                        d = (o = void 0, (o = (i = h).extensions && i.extensions[r.KHR_DRACO_MESH_COMPRESSION]) ? "draco:" + o.bufferView + ":" + o.indices + ":" + G(o.attributes) : i.indices + ":" + G(i.attributes) + ":" + i.mode),
                        m = s[d]; if (m) l.push(m.promise);
                    else p = h.extensions && h.extensions[r.KHR_DRACO_MESH_COMPRESSION] ? n(h) : B(new THREE.BufferGeometry, h, t), s[d] = { primitive: h, promise: p }, l.push(p) } return Promise.all(l) }, k.prototype.loadMesh = function(e) { for (var t, r = this, a = this.json.meshes[e], s = a.primitives, n = [], i = 0, o = s.length; i < o; i++) { var l = void 0 === s[i].material ? (void 0 === (t = this.cache).DefaultMaterial && (t.DefaultMaterial = new THREE.MeshStandardMaterial({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: THREE.FrontSide })), t.DefaultMaterial) : this.getDependency("material", s[i].material);
                    n.push(l) } return n.push(r.loadGeometries(s)), Promise.all(n).then(function(t) { for (var n = t.slice(0, t.length - 1), i = t[t.length - 1], o = [], l = 0, c = i.length; l < c; l++) { var u, p = i[l],
                            h = s[l],
                            d = n[l]; if (h.mode === M || h.mode === y || h.mode === S || void 0 === h.mode) !0 !== (u = !0 === a.isSkinnedMesh ? new THREE.SkinnedMesh(p, d) : new THREE.Mesh(p, d)).isSkinnedMesh || u.geometry.attributes.skinWeight.normalized || u.normalizeSkinWeights(), h.mode === y ? u.geometry = j(u.geometry, THREE.TriangleStripDrawMode) : h.mode === S && (u.geometry = j(u.geometry, THREE.TriangleFanDrawMode));
                        else if (h.mode === T) u = new THREE.LineSegments(p, d);
                        else if (h.mode === R) u = new THREE.Line(p, d);
                        else if (h.mode === v) u = new THREE.LineLoop(p, d);
                        else { if (h.mode !== E) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + h.mode);
                            u = new THREE.Points(p, d) } Object.keys(u.geometry.morphAttributes).length > 0 && D(u, a), u.name = a.name || "mesh_" + e, i.length > 1 && (u.name += "_" + l), U(u, a), r.assignFinalMaterial(u), o.push(u) } if (1 === o.length) return o[0]; var m = new THREE.Group; for (l = 0, c = o.length; l < c; l++) m.add(o[l]); return m }) }, k.prototype.loadCamera = function(e) { var t, r = this.json.cameras[e],
                    a = r[r.type]; if (a) return "perspective" === r.type ? t = new THREE.PerspectiveCamera(THREE.MathUtils.radToDeg(a.yfov), a.aspectRatio || 1, a.znear || 1, a.zfar || 2e6) : "orthographic" === r.type && (t = new THREE.OrthographicCamera(-a.xmag, a.xmag, a.ymag, -a.ymag, a.znear, a.zfar)), r.name && (t.name = r.name), U(t, r), Promise.resolve(t);
                console.warn("THREE.GLTFLoader: Missing camera parameters.") }, k.prototype.loadSkin = function(e) { var t = this.json.skins[e],
                    r = { joints: t.joints }; return void 0 === t.inverseBindMatrices ? Promise.resolve(r) : this.getDependency("accessor", t.inverseBindMatrices).then(function(e) { return r.inverseBindMatrices = e, r }) }, k.prototype.loadAnimation = function(e) { for (var t = this.json.animations[e], r = [], a = [], s = [], n = [], i = [], o = 0, l = t.channels.length; o < l; o++) { var c = t.channels[o],
                        u = t.samplers[c.sampler],
                        p = c.target,
                        h = void 0 !== p.node ? p.node : p.id,
                        d = void 0 !== t.parameters ? t.parameters[u.input] : u.input,
                        m = void 0 !== t.parameters ? t.parameters[u.output] : u.output;
                    r.push(this.getDependency("node", h)), a.push(this.getDependency("accessor", d)), s.push(this.getDependency("accessor", m)), n.push(u), i.push(p) } return Promise.all([Promise.all(r), Promise.all(a), Promise.all(s), Promise.all(n), Promise.all(i)]).then(function(r) { for (var a = r[0], s = r[1], n = r[2], i = r[3], o = r[4], l = [], c = 0, u = a.length; c < u; c++) { var p = a[c],
                            h = s[c],
                            d = n[c],
                            m = i[c],
                            f = o[c]; if (void 0 !== p) { var E; switch (p.updateMatrix(), p.matrixAutoUpdate = !0, A[f.path]) {
                                case A.weights:
                                    E = THREE.NumberKeyframeTrack; break;
                                case A.rotation:
                                    E = THREE.QuaternionKeyframeTrack; break;
                                case A.position:
                                case A.scale:
                                default:
                                    E = THREE.VectorKeyframeTrack } var T = p.name ? p.name : p.uuid,
                                v = void 0 !== m.interpolation ? b[m.interpolation] : THREE.InterpolateLinear,
                                R = [];
                            A[f.path] === A.weights ? p.traverse(function(e) {!0 === e.isMesh && e.morphTargetInfluences && R.push(e.name ? e.name : e.uuid) }) : R.push(T); var M = d.array; if (d.normalized) { var y; if (M.constructor === Int8Array) y = 1 / 127;
                                else if (M.constructor === Uint8Array) y = 1 / 255;
                                else if (M.constructor == Int16Array) y = 1 / 32767;
                                else { if (M.constructor !== Uint16Array) throw new Error("THREE.GLTFLoader: Unsupported output accessor component type.");
                                    y = 1 / 65535 } for (var S = new Float32Array(M.length), x = 0, H = M.length; x < H; x++) S[x] = M[x] * y;
                                M = S } for (x = 0, H = R.length; x < H; x++) { var L = new E(R[x] + "." + A[f.path], h.array, M, v); "CUBICSPLINE" === m.interpolation && (L.createInterpolant = function(e) { return new g(this.times, this.values, this.getValueSize() / 3, e) }, L.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), l.push(L) } } } var _ = t.name ? t.name : "animation_" + e; return new THREE.AnimationClip(_, void 0, l) }) }, k.prototype.loadNode = function(e) { var t, a = this.json,
                    s = this.extensions,
                    n = this,
                    i = a.meshReferences,
                    o = a.meshUses,
                    l = a.nodes[e]; return (t = [], void 0 !== l.mesh && t.push(n.getDependency("mesh", l.mesh).then(function(e) { var t; if (i[l.mesh] > 1) { var r = o[l.mesh]++;
                        (t = e.clone()).name += "_instance_" + r } else t = e; return void 0 !== l.weights && t.traverse(function(e) { if (e.isMesh)
                            for (var t = 0, r = l.weights.length; t < r; t++) e.morphTargetInfluences[t] = l.weights[t] }), t })), void 0 !== l.camera && t.push(n.getDependency("camera", l.camera)), l.extensions && l.extensions[r.KHR_LIGHTS_PUNCTUAL] && void 0 !== l.extensions[r.KHR_LIGHTS_PUNCTUAL].light && t.push(n.getDependency("light", l.extensions[r.KHR_LIGHTS_PUNCTUAL].light)), Promise.all(t)).then(function(t) { var r; if ((r = !0 === l.isBone ? new THREE.Bone : t.length > 1 ? new THREE.Group : 1 === t.length ? t[0] : new THREE.Object3D) !== t[0])
                        for (var a = 0, i = t.length; a < i; a++) r.add(t[a]); if (l.name && (r.userData.name = l.name, r.name = THREE.PropertyBinding.sanitizeNodeName(l.name)), U(r, l), l.extensions && N(s, r, l), void 0 !== l.matrix) { var o = new THREE.Matrix4;
                        o.fromArray(l.matrix), r.applyMatrix4(o) } else void 0 !== l.translation && r.position.fromArray(l.translation), void 0 !== l.rotation && r.quaternion.fromArray(l.rotation), void 0 !== l.scale && r.scale.fromArray(l.scale); return n.associations.set(r, { type: "nodes", index: e }), r }) }, k.prototype.loadScene = function() {
                function e(t, r, a, s) { var n = a.nodes[t]; return s.getDependency("node", t).then(function(e) { return void 0 === n.skin ? e : s.getDependency("skin", n.skin).then(function(e) { for (var r = [], a = 0, n = (t = e).joints.length; a < n; a++) r.push(s.getDependency("node", t.joints[a])); return Promise.all(r) }).then(function(r) { return e.traverse(function(e) { if (e.isMesh) { for (var a = [], s = [], n = 0, i = r.length; n < i; n++) { var o = r[n]; if (o) { a.push(o); var l = new THREE.Matrix4;
                                            void 0 !== t.inverseBindMatrices && l.fromArray(t.inverseBindMatrices.array, 16 * n), s.push(l) } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[n]) } e.bind(new THREE.Skeleton(a, s), e.matrixWorld) } }), e }); var t }).then(function(t) { r.add(t); var i = []; if (n.children)
                            for (var o = n.children, l = 0, c = o.length; l < c; l++) { var u = o[l];
                                i.push(e(u, t, a, s)) }
                        return Promise.all(i) }) } return function(t) { var r = this.json,
                        a = this.extensions,
                        s = this.json.scenes[t],
                        n = new THREE.Group;
                    s.name && (n.name = s.name), U(n, s), s.extensions && N(a, n, s); for (var i = s.nodes || [], o = [], l = 0, c = i.length; l < c; l++) o.push(e(i[l], n, r, this)); return Promise.all(o).then(function() { return n }) } }(), e }(), module.exports = exports = THREE.GLTFLoader;

    }, { "../../three.js": 23 }],
    17: [function(require, module, exports) {
        const THREE = require("../../three.js"),
            MTLLoader = function(a) { this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager };
        THREE.MTLLoader = function(a) { THREE.Loader.call(this, a) }, THREE.MTLLoader.prototype = Object.assign(Object.create(THREE.Loader.prototype), { constructor: THREE.MTLLoader, load: function(a, r, t, e) { var s = this,
                    i = "" === this.path ? THREE.LoaderUtils.extractUrlBase(a || "") : this.path,
                    o = new THREE.FileLoader(this.manager);
                o.setPath(this.path), o.load(a, function(t) { try { r(s.parse(t, i)) } catch (r) { e ? e(r) : console.error(r), s.manager.itemError(a) } }, t, e) }, setMaterialOptions: function(a) { return this.materialOptions = a, this }, parse: function(a, r) { for (var t = a.split("\n"), e = {}, s = /\s+/, i = {}, o = 0; o < t.length; o++) { var n = t[o]; if (0 !== (n = n.trim()).length && "#" !== n.charAt(0)) { var p = n.indexOf(" "),
                            l = p >= 0 ? n.substring(0, p) : n;
                        l = l.toLowerCase(); var c = p >= 0 ? n.substring(p + 1) : ""; if (c = c.trim(), "newmtl" === l) e = { name: c }, i[c] = e;
                        else if ("ka" === l || "kd" === l || "ks" === l || "ke" === l) { var h = c.split(s, 3);
                            e[l] = [parseFloat(h[0]), parseFloat(h[1]), parseFloat(h[2])] } else e[l] = c } } var m = new THREE.MTLLoader.MaterialCreator(this.resourcePath || r, this.materialOptions); return m.setCrossOrigin(this.crossOrigin), m.setManager(this.manager), m.setMaterials(i), m } }), THREE.MTLLoader.MaterialCreator = function(a, r) { this.baseUrl = a || "", this.options = r, this.materialsInfo = {}, this.materials = {}, this.materialsArray = [], this.nameLookup = {}, this.side = this.options && this.options.side ? this.options.side : THREE.FrontSide, this.wrap = this.options && this.options.wrap ? this.options.wrap : THREE.RepeatWrapping }, THREE.MTLLoader.MaterialCreator.prototype = { constructor: THREE.MTLLoader.MaterialCreator, crossOrigin: "anonymous", setCrossOrigin: function(a) { return this.crossOrigin = a, this }, setManager: function(a) { this.manager = a }, setMaterials: function(a) { this.materialsInfo = this.convert(a), this.materials = {}, this.materialsArray = [], this.nameLookup = {} }, convert: function(a) { if (!this.options) return a; var r = {}; for (var t in a) { var e = a[t],
                        s = {}; for (var i in r[t] = s, e) { var o = !0,
                            n = e[i],
                            p = i.toLowerCase(); switch (p) {
                            case "kd":
                            case "ka":
                            case "ks":
                                this.options && this.options.normalizeRGB && (n = [n[0] / 255, n[1] / 255, n[2] / 255]), this.options && this.options.ignoreZeroRGBs && 0 === n[0] && 0 === n[1] && 0 === n[2] && (o = !1) } o && (s[p] = n) } } return r }, preload: function() { for (var a in this.materialsInfo) this.create(a) }, getIndex: function(a) { return this.nameLookup[a] }, getAsArray: function() { var a = 0; for (var r in this.materialsInfo) this.materialsArray[a] = this.create(r), this.nameLookup[r] = a, a++; return this.materialsArray }, create: function(a) { return void 0 === this.materials[a] && this.createMaterial_(a), this.materials[a] }, createMaterial_: function(a) { var r = this,
                    t = this.materialsInfo[a],
                    e = { name: a, side: this.side };

                function s(a, t) { if (!e[a]) { var s, i, o = r.getTextureParams(t, e),
                            n = r.loadTexture((s = r.baseUrl, "string" != typeof(i = o.url) || "" === i ? "" : /^https?:\/\//i.test(i) ? i : s + i));
                        n.repeat.copy(o.scale), n.offset.copy(o.offset), n.wrapS = r.wrap, n.wrapT = r.wrap, e[a] = n } } for (var i in t) { var o, n = t[i]; if ("" !== n) switch (i.toLowerCase()) {
                        case "kd":
                            e.color = (new THREE.Color).fromArray(n); break;
                        case "ks":
                            e.specular = (new THREE.Color).fromArray(n); break;
                        case "ke":
                            e.emissive = (new THREE.Color).fromArray(n); break;
                        case "map_kd":
                            s("map", n); break;
                        case "map_ks":
                            s("specularMap", n); break;
                        case "map_ke":
                            s("emissiveMap", n); break;
                        case "norm":
                            s("normalMap", n); break;
                        case "map_bump":
                        case "bump":
                            s("bumpMap", n); break;
                        case "map_d":
                            s("alphaMap", n), e.transparent = !0; break;
                        case "ns":
                            e.shininess = parseFloat(n); break;
                        case "d":
                            (o = parseFloat(n)) < 1 && (e.opacity = o, e.transparent = !0); break;
                        case "tr":
                            o = parseFloat(n), this.options && this.options.invertTrProperty && (o = 1 - o), o > 0 && (e.opacity = 1 - o, e.transparent = !0) } } return this.materials[a] = new THREE.MeshPhongMaterial(e), this.materials[a] }, getTextureParams: function(a, r) { var t, e = { scale: new THREE.Vector2(1, 1), offset: new THREE.Vector2(0, 0) },
                    s = a.split(/\s+/); return (t = s.indexOf("-bm")) >= 0 && (r.bumpScale = parseFloat(s[t + 1]), s.splice(t, 2)), (t = s.indexOf("-s")) >= 0 && (e.scale.set(parseFloat(s[t + 1]), parseFloat(s[t + 2])), s.splice(t, 4)), (t = s.indexOf("-o")) >= 0 && (e.offset.set(parseFloat(s[t + 1]), parseFloat(s[t + 2])), s.splice(t, 4)), e.url = s.join(" ").trim(), e }, loadTexture: function(a, r, t, e, s) { var i, o = void 0 !== this.manager ? this.manager : THREE.DefaultLoadingManager,
                    n = o.getHandler(a); return null === n && (n = new THREE.TextureLoader(o)), n.setCrossOrigin && n.setCrossOrigin(this.crossOrigin), i = n.load(a, t, e, s), void 0 !== r && (i.mapping = r), i } }, module.exports = exports = THREE.MTLLoader;

    }, { "../../three.js": 23 }],
    18: [function(require, module, exports) {
        const THREE = require("../../three.js");
        THREE.OBJLoader = function() { var e = /^[og]\s*(.+)?/,
                t = /^mtllib /,
                r = /^usemtl /,
                s = /^usemap /,
                i = new THREE.Vector3,
                a = new THREE.Vector3,
                o = new THREE.Vector3,
                n = new THREE.Vector3,
                l = new THREE.Vector3;

            function h() { var e = { objects: [], object: {}, vertices: [], normals: [], colors: [], uvs: [], materials: {}, materialLibraries: [], startObject: function(e, t) { if (this.object && !1 === this.object.fromDeclaration) return this.object.name = e, void(this.object.fromDeclaration = !1 !== t); var r = this.object && "function" == typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0; if (this.object && "function" == typeof this.object._finalize && this.object._finalize(!0), this.object = { name: e || "", fromDeclaration: !1 !== t, geometry: { vertices: [], normals: [], colors: [], uvs: [], hasNormalIndices: !1, hasUVIndices: !1 }, materials: [], smooth: !0, startMaterial: function(e, t) { var r = this._finalize(!1);
                                    r && (r.inherited || r.groupCount <= 0) && this.materials.splice(r.index, 1); var s = { index: this.materials.length, name: e || "", mtllib: Array.isArray(t) && t.length > 0 ? t[t.length - 1] : "", smooth: void 0 !== r ? r.smooth : this.smooth, groupStart: void 0 !== r ? r.groupEnd : 0, groupEnd: -1, groupCount: -1, inherited: !1, clone: function(e) { var t = { index: "number" == typeof e ? e : this.index, name: this.name, mtllib: this.mtllib, smooth: this.smooth, groupStart: 0, groupEnd: -1, groupCount: -1, inherited: !1 }; return t.clone = this.clone.bind(t), t } }; return this.materials.push(s), s }, currentMaterial: function() { if (this.materials.length > 0) return this.materials[this.materials.length - 1] }, _finalize: function(e) { var t = this.currentMaterial(); if (t && -1 === t.groupEnd && (t.groupEnd = this.geometry.vertices.length / 3, t.groupCount = t.groupEnd - t.groupStart, t.inherited = !1), e && this.materials.length > 1)
                                        for (var r = this.materials.length - 1; r >= 0; r--) this.materials[r].groupCount <= 0 && this.materials.splice(r, 1); return e && 0 === this.materials.length && this.materials.push({ name: "", smooth: this.smooth }), t } }, r && r.name && "function" == typeof r.clone) { var s = r.clone(0);
                            s.inherited = !0, this.object.materials.push(s) } this.objects.push(this.object) }, finalize: function() { this.object && "function" == typeof this.object._finalize && this.object._finalize(!0) }, parseVertexIndex: function(e, t) { var r = parseInt(e, 10); return 3 * (r >= 0 ? r - 1 : r + t / 3) }, parseNormalIndex: function(e, t) { var r = parseInt(e, 10); return 3 * (r >= 0 ? r - 1 : r + t / 3) }, parseUVIndex: function(e, t) { var r = parseInt(e, 10); return 2 * (r >= 0 ? r - 1 : r + t / 2) }, addVertex: function(e, t, r) { var s = this.vertices,
                            i = this.object.geometry.vertices;
                        i.push(s[e + 0], s[e + 1], s[e + 2]), i.push(s[t + 0], s[t + 1], s[t + 2]), i.push(s[r + 0], s[r + 1], s[r + 2]) }, addVertexPoint: function(e) { var t = this.vertices;
                        this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]) }, addVertexLine: function(e) { var t = this.vertices;
                        this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]) }, addNormal: function(e, t, r) { var s = this.normals,
                            i = this.object.geometry.normals;
                        i.push(s[e + 0], s[e + 1], s[e + 2]), i.push(s[t + 0], s[t + 1], s[t + 2]), i.push(s[r + 0], s[r + 1], s[r + 2]) }, addFaceNormal: function(e, t, r) { var s = this.vertices,
                            h = this.object.geometry.normals;
                        i.fromArray(s, e), a.fromArray(s, t), o.fromArray(s, r), l.subVectors(o, a), n.subVectors(i, a), l.cross(n), l.normalize(), h.push(l.x, l.y, l.z), h.push(l.x, l.y, l.z), h.push(l.x, l.y, l.z) }, addColor: function(e, t, r) { var s = this.colors,
                            i = this.object.geometry.colors;
                        void 0 !== s[e] && i.push(s[e + 0], s[e + 1], s[e + 2]), void 0 !== s[t] && i.push(s[t + 0], s[t + 1], s[t + 2]), void 0 !== s[r] && i.push(s[r + 0], s[r + 1], s[r + 2]) }, addUV: function(e, t, r) { var s = this.uvs,
                            i = this.object.geometry.uvs;
                        i.push(s[e + 0], s[e + 1]), i.push(s[t + 0], s[t + 1]), i.push(s[r + 0], s[r + 1]) }, addDefaultUV: function() { var e = this.object.geometry.uvs;
                        e.push(0, 0), e.push(0, 0), e.push(0, 0) }, addUVLine: function(e) { var t = this.uvs;
                        this.object.geometry.uvs.push(t[e + 0], t[e + 1]) }, addFace: function(e, t, r, s, i, a, o, n, l) { var h = this.vertices.length,
                            c = this.parseVertexIndex(e, h),
                            u = this.parseVertexIndex(t, h),
                            p = this.parseVertexIndex(r, h); if (this.addVertex(c, u, p), this.addColor(c, u, p), void 0 !== o && "" !== o) { var m = this.normals.length;
                            c = this.parseNormalIndex(o, m), u = this.parseNormalIndex(n, m), p = this.parseNormalIndex(l, m), this.addNormal(c, u, p), this.object.geometry.hasNormalIndices = !0 } else this.addFaceNormal(c, u, p); if (void 0 !== s && "" !== s) { var d = this.uvs.length;
                            c = this.parseUVIndex(s, d), u = this.parseUVIndex(i, d), p = this.parseUVIndex(a, d), this.addUV(c, u, p), this.object.geometry.hasUVIndices = !0 } else this.addDefaultUV() }, addPointGeometry: function(e) { this.object.geometry.type = "Points"; for (var t = this.vertices.length, r = 0, s = e.length; r < s; r++) this.addVertexPoint(this.parseVertexIndex(e[r], t)) }, addLineGeometry: function(e, t) { this.object.geometry.type = "Line"; for (var r = this.vertices.length, s = this.uvs.length, i = 0, a = e.length; i < a; i++) this.addVertexLine(this.parseVertexIndex(e[i], r)); var o = 0; for (a = t.length; o < a; o++) this.addUVLine(this.parseUVIndex(t[o], s)) } }; return e.startObject("", !1), e }

            function c(e) { THREE.Loader.call(this, e), this.materials = null } return c.prototype = Object.assign(Object.create(THREE.Loader.prototype), { constructor: c, load: function(e, t, r, s) { var i = this,
                        a = new THREE.FileLoader(i.manager);
                    a.setPath(this.path), a.load(e, function(r) { try { t(i.parse(r)) } catch (t) { s ? s(t) : console.error(t), i.manager.itemError(e) } }, r, s) }, setMaterials: function(e) { return this.materials = e, this }, parse: function(i) { var a = new h; - 1 !== i.indexOf("\r\n") && (i = i.replace(/\r\n/g, "\n")), -1 !== i.indexOf("\\\n") && (i = i.replace(/\\\n/g, "")); for (var o = i.split("\n"), n = "", l = "", c = [], u = "function" == typeof "".trimLeft, p = 0, m = o.length; p < m; p++)
                        if (n = o[p], 0 !== (n = u ? n.trimLeft() : n.trim()).length && "#" !== (l = n.charAt(0)))
                            if ("v" === l) { var d = n.split(/\s+/); switch (d[0]) {
                                    case "v":
                                        a.vertices.push(parseFloat(d[1]), parseFloat(d[2]), parseFloat(d[3])), d.length >= 7 ? a.colors.push(parseFloat(d[4]), parseFloat(d[5]), parseFloat(d[6])) : a.colors.push(void 0, void 0, void 0); break;
                                    case "vn":
                                        a.normals.push(parseFloat(d[1]), parseFloat(d[2]), parseFloat(d[3])); break;
                                    case "vt":
                                        a.uvs.push(parseFloat(d[1]), parseFloat(d[2])) } } else if ("f" === l) { for (var f = n.substr(1).trim().split(/\s+/), v = [], g = 0, b = f.length; g < b; g++) { var E = f[g]; if (E.length > 0) { var y = E.split("/");
                                v.push(y) } } var j = v[0]; for (g = 1, b = v.length - 1; g < b; g++) { var x = v[g],
                                T = v[g + 1];
                            a.addFace(j[0], x[0], T[0], j[1], x[1], T[1], j[2], x[2], T[2]) } } else if ("l" === l) { var R = n.substring(1).trim().split(" "),
                            H = [],
                            V = []; if (-1 === n.indexOf("/")) H = R;
                        else
                            for (var L = 0, w = R.length; L < w; L++) { var I = R[L].split("/"); "" !== I[0] && H.push(I[0]), "" !== I[1] && V.push(I[1]) } a.addLineGeometry(H, V) } else if ("p" === l) { var M = n.substr(1).trim().split(" ");
                        a.addPointGeometry(M) } else if (null !== (c = e.exec(n))) { var F = (" " + c[0].substr(1).trim()).substr(1);
                        a.startObject(F) } else if (r.test(n)) a.object.startMaterial(n.substring(7).trim(), a.materialLibraries);
                    else if (t.test(n)) a.materialLibraries.push(n.substring(7).trim());
                    else if (s.test(n)) console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
                    else if ("s" === l) { if ((c = n.split(" ")).length > 1) { var z = c[1].trim().toLowerCase();
                            a.object.smooth = "0" !== z && "off" !== z } else a.object.smooth = !0;
                        (q = a.object.currentMaterial()) && (q.smooth = a.object.smooth) } else { if ("\0" === n) continue;
                        console.warn('THREE.OBJLoader: Unexpected line: "' + n + '"') } a.finalize(); var A = new THREE.Group;
                    A.materialLibraries = [].concat(a.materialLibraries); for (p = 0, m = a.objects.length; p < m; p++) { var U = a.objects[p],
                            P = U.geometry,
                            B = U.materials,
                            O = "Line" === P.type,
                            N = "Points" === P.type,
                            C = !1; if (0 !== P.vertices.length) { var _ = new THREE.BufferGeometry;
                            _.setAttribute("position", new THREE.Float32BufferAttribute(P.vertices, 3)), !0 === P.hasNormalIndices && _.setAttribute("normal", new THREE.Float32BufferAttribute(P.normals, 3)), P.colors.length > 0 && (C = !0, _.setAttribute("color", new THREE.Float32BufferAttribute(P.colors, 3))), !0 === P.hasUVIndices && _.setAttribute("uv", new THREE.Float32BufferAttribute(P.uvs, 2)); for (var G, S = [], D = 0, J = B.length; D < J; D++) { var k = (W = B[D]).name + "_" + W.smooth + "_" + C,
                                    q = a.materials[k]; if (null !== this.materials)
                                    if (q = this.materials.create(W.name), !O || !q || q instanceof THREE.LineBasicMaterial) { if (N && q && !(q instanceof THREE.PointsMaterial)) { var K = new THREE.PointsMaterial({ size: 10, sizeAttenuation: !1 });
                                            THREE.Material.prototype.copy.call(K, q), K.color.copy(q.color), K.map = q.map, q = K } } else { var Q = new THREE.LineBasicMaterial;
                                        THREE.Material.prototype.copy.call(Q, q), Q.color.copy(q.color), q = Q } void 0 === q && ((q = O ? new THREE.LineBasicMaterial : N ? new THREE.PointsMaterial({ size: 1, sizeAttenuation: !1 }) : new THREE.MeshPhongMaterial).name = W.name, q.flatShading = !W.smooth, q.vertexColors = C, a.materials[k] = q), S.push(q) } if (S.length > 1) { for (D = 0, J = B.length; D < J; D++) { var W = B[D];
                                    _.addGroup(W.groupStart, W.groupCount, D) } G = O ? new THREE.LineSegments(_, S) : N ? new THREE.Points(_, S) : new THREE.Mesh(_, S) } else G = O ? new THREE.LineSegments(_, S[0]) : N ? new THREE.Points(_, S[0]) : new THREE.Mesh(_, S[0]);
                            G.name = U.name, A.add(G) } } return A } }), c }(), module.exports = exports = THREE.OBJLoader;

    }, { "../../three.js": 23 }],
    19: [function(require, module, exports) {
        const utils = require("../utils/utils.js"),
            material = require("../utils/material.js"),
            THREE = require("../three.js"),
            AnimationManager = require("../animation/AnimationManager.js"),
            CSS2D = require("./CSS2DRenderer.js");

        function Objects() {} Objects.prototype = { line: function(e) { e = utils._validate(e, this._defaults.line); var t = utils.lnglatsToWorld(e.geometry),
                    o = utils.normalizeVertices(t),
                    a = utils.flattenVectors(o.vertices),
                    i = new Float32Array(a),
                    n = new THREE.BufferGeometry;
                n.setAttribute("position", new THREE.BufferAttribute(i, 3)); var r = new THREE.LineBasicMaterial({ color: 16711680, linewidth: 21 }),
                    l = new THREE.Line(n, r); return l.options = options || {}, l.position.copy(o.position), l }, extrusion: function(e) {}, unenroll: function(e, t) { t || this.animationManager.unenroll(e) }, _addMethods: function(e, t) { var o = this; if (t);
                else {
                    function a(e, t, o, a) { let i = utils.radify(a);
                        e.position.sub(t), e.position.applyAxisAngle(o, i), e.position.add(t), e.rotateOnAxis(o, i), tb.map.repaint = !0 } e.coordinates || (e.coordinates = [0, 0, 0]), Object.defineProperty(e, "model", { get: () => e.getObjectByName("model") }), Object.defineProperty(e, "animations", { get() { const t = e.model; return t ? t.animations : null } }), o.animationManager.enroll(e), e.setCoords = function(t) { if ("meters" === e.userData.units) { var o = utils.projectedUnitsPerMeter(t[1]);
                            o || (o = 1), "number" == typeof(o = Number(o.toFixed(7))) ? e.scale.set(o, o, o) : e.scale.set(o.x, o.y, o.z) } return e.userData.topMargin && e.userData.feature && (t[2] += ((e.userData.feature.properties.height || 0) - (e.userData.feature.properties.base_height || e.userData.feature.properties.min_height || 0)) * (e.userData.topMargin || 0)), e.coordinates = t, e.set({ position: t }), e.modelHeight = e.coordinates[2] || 0, e.setBoundingBoxShadowFloor(), e.setCastShadowFloor(), e }, e.setTranslate = function(t) { return e.set({ translate: t }), e }, e.setRotation = function(t) { "number" == typeof t && (t = { z: t }); var o = { x: utils.radify(t.x) || e.rotation.x, y: utils.radify(t.y) || e.rotation.y, z: utils.radify(t.z) || e.rotation.z };
                        e._setObject({ rotation: [o.x, o.y, o.z] }) }, e.calculateAdjustedPosition = function(t, o, a) { let i = t.slice(),
                            n = utils.unprojectFromWorld(e.modelSize); return a ? (i[0] -= 0 != o.x ? n[0] / o.x : 0, i[1] -= 0 != o.y ? n[1] / o.y : 0, i[2] -= 0 != o.z ? n[2] / o.z : 0) : (i[0] += 0 != o.x ? n[0] / o.x : 0, i[1] += 0 != o.y ? n[1] / o.y : 0, i[2] += 0 != o.z ? n[2] / o.z : 0), i }, e.setRotationAxis = function(t) { "number" == typeof t && (t = { z: t }); let o = e.modelBox(),
                            i = new THREE.Vector3(o.max.x, o.max.y, o.min.z);
                        0 != t.x && a(e, i, new THREE.Vector3(0, 0, 1), t.x), 0 != t.y && a(e, i, new THREE.Vector3(0, 0, 1), t.y), 0 != t.z && a(e, i, new THREE.Vector3(0, 0, 1), t.z) }, Object.defineProperty(e, "scaleGroup", { get: () => e.getObjectByName("scaleGroup") }), Object.defineProperty(e, "boxGroup", { get: () => e.getObjectByName("boxGroup") }), Object.defineProperty(e, "boundingBox", { get: () => e.getObjectByName("boxModel") }), Object.defineProperty(e, "boundingBoxShadow", { get: () => e.getObjectByName("boxShadow") }), e.drawBoundingBox = function() { let t = e.box3(),
                            o = new THREE.Group;
                        o.name = "boxGroup", o.updateMatrixWorld(!0); let a = new THREE.Box3Helper(t, Objects.prototype._defaults.colors.yellow);
                        a.name = "boxModel", o.add(a), a.layers.disable(0); let i = t.clone();
                        i.max.z = i.min.z; let n = new THREE.Box3Helper(i, Objects.prototype._defaults.colors.black);
                        n.name = "boxShadow", o.add(n), n.layers.disable(0), o.visible = !1, e.scaleGroup.add(o), e.setBoundingBoxShadowFloor() }, e.setBoundingBoxShadowFloor = function() { e.boxGroup && e.boundingBox && (e.boundingBoxShadow.box.max.z = -e.modelHeight, e.boundingBoxShadow.box.min.z = -e.modelHeight) }, e.setAnchor = function(t) { const o = e.box3(),
                            a = (o.getSize(new THREE.Vector3), o.getCenter(new THREE.Vector3)); switch (e.none = { x: 0, y: 0, z: 0 }, e.center = { x: a.x, y: a.y, z: o.min.z }, e.bottom = { x: a.x, y: o.max.y, z: o.min.z }, e.bottomLeft = { x: o.max.x, y: o.max.y, z: o.min.z }, e.bottomRight = { x: o.min.x, y: o.max.y, z: o.min.z }, e.top = { x: a.x, y: o.min.y, z: o.min.z }, e.topLeft = { x: o.max.x, y: o.min.y, z: o.min.z }, e.topRight = { x: o.min.x, y: o.min.y, z: o.min.z }, e.left = { x: o.max.x, y: a.y, z: o.min.z }, e.right = { x: o.min.x, y: a.y, z: o.min.z }, t) {
                            case "center":
                                e.anchor = e.center; break;
                            case "top":
                                e.anchor = e.top; break;
                            case "top-left":
                                e.anchor = e.topLeft; break;
                            case "top-right":
                                e.anchor = e.topRight; break;
                            case "left":
                                e.anchor = e.left; break;
                            case "right":
                                e.anchor = e.right; break;
                            case "bottom":
                                e.anchor = e.bottom; break;
                            case "bottom-left":
                            default:
                                e.anchor = e.bottomLeft; break;
                            case "bottom-right":
                                e.anchor = e.bottomRight; break;
                            case "auto":
                            case "none":
                                e.anchor = e.none } e.model.position.set(-e.anchor.x, -e.anchor.y, -e.anchor.z) }, e.setCenter = function(t) { if (t && (0 != t.x || 0 != t.y || 0 != t.z)) { let o = e.getSize();
                            e.anchor = { x: e.anchor.x - o.x * t.x, y: e.anchor.y - o.y * t.y, z: e.anchor.z - o.z * t.z }, e.model.position.set(-e.anchor.x, -e.anchor.y, -e.anchor.z) } }, Object.defineProperty(e, "label", { get: () => e.getObjectByName("label") }), Object.defineProperty(e, "tooltip", { get: () => e.getObjectByName("tooltip") }), Object.defineProperty(e, "help", { get: () => e.getObjectByName("help") }), Object.defineProperty(e, "visibility", { get: () => e.visible, set(t) { let o = t; if ("visible" == t || 1 == t) o = !0, e.label && (e.label.visible = o);
                            else { if ("none" != t && 0 != t) return;
                                o = !1, e.label && e.label.alwaysVisible && (e.label.visible = o), e.tooltip && (e.tooltip.visible = o) } e.visible != o && (e.visible = o, e.model && e.model.traverse(function(t) { "Mesh" != t.type && "SkinnedMesh" != t.type || (o && e.raycasted ? t.layers.enable(0) : t.layers.disable(0)), "LineSegments" == t.type && t.layers.disableAll() })) } }), e.addLabel = function(t, o, a, i) { t && e.drawLabelHTML(t, o, a, i) }, e.removeLabel = function() { e.removeCSS2D("label") }, e.drawLabelHTML = function(t, a = !1, i = e.anchor, n = .5) { let r = o.drawLabelHTML(t, Objects.prototype._defaults.label.cssClass),
                            l = e.addCSS2D(r, "label", i, n); return l.alwaysVisible = a, l.visible = a, l }, e.addTooltip = function(t, o, a, i = !0, n = 1) { let r = e.addHelp(t, "tooltip", o, a, n);
                        r.visible = !1, r.custom = i }, e.removeTooltip = function() { e.removeCSS2D("tooltip") }, e.addHelp = function(t, a = "help", i = !1, n = e.anchor, r = 0) { let l = o.drawTooltip(t, i),
                            s = e.addCSS2D(l, a, n, r); return s.visible = !0, s }, e.removeHelp = function() { e.removeCSS2D("help") }, e.addCSS2D = function(t, o, a = e.anchor, i = 1) { if (t) { const n = e.box3(),
                                r = n.getSize(new THREE.Vector3); let l = { x: n.max.x, y: n.max.y, z: n.min.z };
                            e.removeCSS2D(o); let s = new CSS2D.CSS2DObject(t); return s.name = o, s.position.set(.5 * -r.x - e.model.position.x - a.x + l.x, .5 * -r.y - e.model.position.y - a.y + l.y, r.z * i), s.visible = !1, e.scaleGroup.add(s), s } }, e.removeCSS2D = function(t) { let o = e.getObjectByName(t); if (o) { o.dispose(); let t = e.scaleGroup.children;
                            t.splice(t.indexOf(o), 1) } }, Object.defineProperty(e, "shadowPlane", { get: () => e.getObjectByName("shadowPlane") }); let t = !1;
                    Object.defineProperty(e, "castShadow", { get: () => t, set(o) { if (e.model && t !== o) { if (e.model.traverse(function(e) { e.isMesh && (e.castShadow = !0) }), o) { const t = e.modelSize,
                                        a = [t.x, t.y, t.z],
                                        i = 10 * Math.max(...a),
                                        n = new THREE.PlaneBufferGeometry(i, i),
                                        r = new THREE.ShadowMaterial;
                                    r.opacity = .5; let l = new THREE.Mesh(n, r);
                                    l.name = "shadowPlane", l.layers.enable(1), l.layers.disable(0), l.receiveShadow = o, e.add(l) } else e.traverse(function(t) { t.isMesh && t.material instanceof THREE.ShadowMaterial && e.remove(t) });
                                t = o } } }), e.setCastShadowFloor = function() { e.castShadow && (e.shadowPlane.position.z = -e.modelHeight) }; let i = !1;
                    Object.defineProperty(e, "receiveShadow", { get: () => i, set(t) { e.model && i !== t && (e.model.traverse(function(e) { e.isMesh && (e.receiveShadow = !0) }), i = t) } }); let n = !1;
                    Object.defineProperty(e, "wireframe", { get: () => n, set(t) { e.model && n !== t && (e.model.traverse(function(e) { if ("Mesh" == e.type || "SkinnedMesh" == e.type) { let o = []; if (Array.isArray(e.material) ? o = e.material : o.push(e.material), t) e.userData.materials = o, e.material = Objects.prototype._defaults.materials.wireframeMaterial, e.material.opacity = t ? .5 : 1, e.material.wireframe = t, e.material.transparent = t;
                                    else { let t = e.userData.materials;
                                        e.material = t.length > 1 ? t : t[0], e.userData.materials = null } t ? (e.layers.disable(0), e.layers.enable(1)) : (e.layers.disable(1), e.layers.enable(0)) } "LineSegments" == e.type && e.layers.disableAll() }), n = t, e.dispatchEvent(new CustomEvent("Wireframed", { detail: e, bubbles: !0, cancelable: !0 }))) } }); let r = !1;
                    Object.defineProperty(e, "selected", { get: () => r, set(t) { t ? (e.boxGroup && (e.boundingBox.material = Objects.prototype._defaults.materials.boxSelectedMaterial, e.boundingBox.parent.visible = !0, e.boundingBox.layers.enable(1), e.boundingBoxShadow.layers.enable(1)), e.label && !e.label.alwaysVisible && (e.label.visible = !0)) : (e.boxGroup && (e.boundingBox.parent.visible = !1, e.boundingBox.layers.disable(1), e.boundingBoxShadow.layers.disable(1), e.boundingBox.material = Objects.prototype._defaults.materials.boxNormalMaterial, e.remove(e.boxGroup)), e.label && !e.label.alwaysVisible && (e.label.visible = !1), e.removeHelp()), e.tooltip && (e.tooltip.visible = t), r != t && (r = t, e.dispatchEvent(new CustomEvent("SelectedChange", { detail: e, bubbles: !0, cancelable: !0 }))) } }); let l = !0;
                    Object.defineProperty(e, "raycasted", { get: () => l, set(t) { e.model && l !== t && (e.model.traverse(function(e) { "Mesh" != e.type && "SkinnedMesh" != e.type || (t ? (e.layers.disable(1), e.layers.enable(0)) : (e.layers.disable(0), e.layers.enable(1))) }), l = t) } }); let s = !1;
                    Object.defineProperty(e, "over", { get: () => s, set(t) { t ? (e.selected || (e.userData.bbox && !e.boundingBox && e.drawBoundingBox(), e.userData.tooltip && !e.tooltip && e.addTooltip(e.uuid, !0, e.anchor, !1), e.boxGroup && (e.boundingBox.material = Objects.prototype._defaults.materials.boxOverMaterial, e.boundingBox.parent.visible = !0, e.boundingBox.layers.enable(1), e.boundingBoxShadow.layers.enable(1))), e.label && !e.label.alwaysVisible && (e.label.visible = !0), e.dispatchEvent(new CustomEvent("ObjectMouseOver", { detail: e, bubbles: !0, cancelable: !0 }))) : (e.selected || (e.boundingBox && (e.boundingBox.parent.visible = !1, e.boundingBox.layers.disable(1), e.boundingBoxShadow.layers.disable(1), e.boundingBox.material = Objects.prototype._defaults.materials.boxNormalMaterial, e.remove(e.boxGroup), e.tooltip && !e.tooltip.custom && e.removeTooltip()), e.label && !e.label.alwaysVisible && (e.label.visible = !1)), e.dispatchEvent(new CustomEvent("ObjectMouseOut", { detail: e, bubbles: !0, cancelable: !0 }))), e.tooltip && (e.tooltip.visible = t || e.selected), s = t } }), e.box3 = function() { let t; if (e.updateMatrix(), e.updateMatrixWorld(!0, !0), e.model) { let o = e.clone(!0),
                                a = e.model.clone(); if (t = (new THREE.Box3).setFromObject(a), e.parent) { let i = new THREE.Matrix4,
                                    n = new THREE.Matrix4;
                                e.matrix.extractRotation(i), i.getInverse(n), o.setRotationFromMatrix(n), t = (new THREE.Box3).setFromObject(a) } } return t }, e.modelBox = function() { return e.box3() }, e.getSize = function() { return e.box3().getSize(new THREE.Vector3(0, 0, 0)) }; let c = !1;
                    Object.defineProperty(e, "modelSize", { get: () => c = e.getSize(), set(e) { c != e && (c = e) } }), e.modelHeight = 0 } e.add = function(t) { return e.scaleGroup.add(t), t.position.z = e.coordinates[2] ? -e.coordinates[2] : 0, t }, e.remove = function(t) { t && (t.traverse(e => { if (e.geometry && e.geometry.dispose(), e.material)
                            if (e.material.isMaterial) i(e.material);
                            else
                                for (const t of e.material) i(t);
                        e.dispose && e.dispose() }), e.scaleGroup.remove(t), tb.map.repaint = !0) }, e.duplicate = function(t) { let a = e.clone(!0); if (a.getObjectByName("model").animations = e.animations, a.userData.feature && (t && t.feature && (a.userData.feature = t.feature), a.userData.feature.properties.uuid = a.uuid), o._addMethods(a), !t || utils.equal(t.scale, e.userData.scale)) return a.copyAnchor(e), a; { a.userData = t, a.userData.isGeoGroup = !0, a.remove(a.boxGroup); const e = utils.types.rotation(t.rotation, [0, 0, 0]),
                            o = utils.types.scale(t.scale, [1, 1, 1]); return a.model.position.set(0, 0, 0), a.model.rotation.set(e[0], e[1], e[2]), a.model.scale.set(o[0], o[1], o[2]), a.setAnchor(t.anchor), a.setCenter(t.adjustment), a } }, e.copyAnchor = function(t) { e.anchor = t.anchor, e.none = { x: 0, y: 0, z: 0 }, e.center = t.center, e.bottom = t.bottom, e.bottomLeft = t.bottomLeft, e.bottomRight = t.bottomRight, e.top = t.top, e.topLeft = t.topLeft, e.topRight = t.topRight, e.left = t.left, e.right = t.right }, e.dispose = function() { Objects.prototype.unenroll(e), e.traverse(e => { if ((!e.parent || "world" != e.parent.name) && "threeboxObject" !== e.name) { if (e.geometry && e.geometry.dispose(), e.material)
                                if (e.material.isMaterial) i(e.material);
                                else
                                    for (const t of e.material) i(t);
                            e.dispose && e.dispose() } }), e.children = [] }; const i = e => { e.dispose(); for (const t of Object.keys(e)) { const o = e[t];
                        o && "object" == typeof o && "minFilter" in o && o.dispose() } let t = e;
                    (t.map || t.alphaMap || t.aoMap || t.bumpMap || t.displacementMap || t.emissiveMap || t.envMap || t.lightMap || t.metalnessMap || t.normalMap || t.roughnessMap) && (t.map && t.map.dispose(), t.alphaMap && t.alphaMap.dispose(), t.aoMap && t.aoMap.dispose(), t.bumpMap && t.bumpMap.dispose(), t.displacementMap && t.displacementMap.dispose(), t.emissiveMap && t.emissiveMap.dispose(), t.envMap && t.envMap.dispose(), t.lightMap && t.lightMap.dispose(), t.metalnessMap && t.metalnessMap.dispose(), t.normalMap && t.normalMap.dispose(), t.roughnessMap && t.roughnessMap.dispose()) }; return e }, _makeGroup: function(e, t) { let a = new THREE.Group;
                a.name = "scaleGroup", a.add(e); var i = new THREE.Group; if (i.userData = t || {}, i.userData.isGeoGroup = !0, i.userData.feature && (i.userData.feature.properties.uuid = i.uuid), a.length)
                    for (o of a) i.add(o);
                else i.add(a); return i.name = "threeboxObject", i }, animationManager: new AnimationManager, drawTooltip: function(e, t = !1) { if (e) { let o; if (t) { let t = document.createElement("div");
                        t.className = "mapboxgl-popup-content"; let a = document.createElement("strong");
                        a.innerHTML = e, t.appendChild(a); let i = document.createElement("div");
                        i.className = "mapboxgl-popup-tip"; let n = document.createElement("div");
                        n.className = "marker mapboxgl-popup-anchor-bottom", n.appendChild(i), n.appendChild(t), (o = document.createElement("div")).className += "label3D", o.appendChild(n) } else(o = document.createElement("span")).className = this._defaults.tooltip.cssClass, o.innerHTML = e; return o } }, drawLabelHTML: function(e, t) { let o = document.createElement("div"); return o.className += t, o.innerHTML = "string" == typeof e ? e : e.outerHTML, o }, _defaults: { colors: { red: new THREE.Color(16711680), yellow: new THREE.Color(16776960), green: new THREE.Color(65280), black: new THREE.Color(0) }, materials: { wireframeMaterial: new THREE.LineBasicMaterial({ color: new THREE.Color(16777215) }), boxNormalMaterial: new THREE.LineBasicMaterial({ color: new THREE.Color(16711680) }), boxOverMaterial: new THREE.LineBasicMaterial({ color: new THREE.Color(16776960) }), boxSelectedMaterial: new THREE.LineBasicMaterial({ color: new THREE.Color(65280) }) }, line: { geometry: null, color: "black", width: 1, opacity: 1 }, sphere: { position: [0, 0, 0], radius: 1, sides: 20, units: "scene", material: "MeshBasicMaterial", anchor: "bottom-left", bbox: !0, tooltip: !0, raycasted: !0 }, label: { htmlElement: null, cssClass: " label3D", alwaysVisible: !1, topMargin: -.5 }, tooltip: { text: "", cssClass: "toolTip text-xs", mapboxStyle: !1, topMargin: 0, feature: null }, tube: { geometry: null, radius: 1, sides: 6, units: "scene", material: "MeshBasicMaterial", anchor: "center", bbox: !0, tooltip: !0, raycasted: !0 }, loadObj: { type: null, obj: null, units: "scene", scale: 1, rotation: 0, defaultAnimation: 0, anchor: "bottom-left", bbox: !0, tooltip: !0, raycasted: !0 }, Object3D: { obj: null, units: "scene", anchor: "bottom-left", bbox: !0, tooltip: !0, raycasted: !0 }, extrusion: { coordinates: [
                        [
                            []
                        ]
                    ], geometryOptions: {}, height: 100, materials: null, scale: 1, rotation: 0, units: "scene", anchor: "center", bbox: !0, tooltip: !0, raycasted: !0 } }, geometries: { line: ["LineString"], tube: ["LineString"], sphere: ["Point"] } }, module.exports = exports = Objects;

    }, { "../animation/AnimationManager.js": 3, "../three.js": 23, "../utils/material.js": 25, "../utils/utils.js": 27, "./CSS2DRenderer.js": 5 }],
    20: [function(require, module, exports) {
        const utils = require("../utils/utils.js"),
            material = require("../utils/material.js"),
            Objects = require("./objects.js"),
            Object3D = require("./Object3D.js");

        function Sphere(e) { e = utils._validate(e, Objects.prototype._defaults.sphere); let t = new THREE.SphereBufferGeometry(e.radius, e.sides, e.sides),
                s = material(e),
                r = new THREE.Mesh(t, s); return new Object3D({ obj: r, units: e.units, anchor: e.anchor, adjustment: e.adjustment, bbox: e.bbox, tooltip: e.tooltip, raycasted: e.raycasted }) } module.exports = exports = Sphere;

    }, { "../utils/material.js": 25, "../utils/utils.js": 27, "./Object3D.js": 7, "./objects.js": 19 }],
    21: [function(require, module, exports) {
        const utils = require("../utils/utils.js"),
            Objects = require("./objects.js"),
            CSS2D = require("./CSS2DRenderer.js");
        var THREE = require("../three.js");

        function Tooltip(t) { if ((t = utils._validate(t, Objects.prototype._defaults.tooltip)).text) { let o = Objects.prototype.drawTooltip(t.text, t.mapboxStyle),
                    r = new CSS2D.CSS2DObject(o);
                r.visible = !1, r.name = "tooltip"; var e = Objects.prototype._makeGroup(r, t); return Objects.prototype._addMethods(e), e } } module.exports = exports = Tooltip;

    }, { "../three.js": 23, "../utils/utils.js": 27, "./CSS2DRenderer.js": 5, "./objects.js": 19 }],
    22: [function(require, module, exports) {
        const utils = require("../utils/utils.js"),
            material = require("../utils/material.js"),
            Objects = require("./objects.js"),
            THREE = require("../three.js"),
            Object3D = require("./Object3D.js");

        function tube(e, t) { e = utils._validate(e, Objects.prototype._defaults.tube); let r = utils.lnglatsToWorld(e.geometry),
                i = utils.normalizeVertices(r),
                o = tube.prototype.defineCrossSection(e),
                s = tube.prototype.buildVertices(o, i.vertices, t),
                n = tube.prototype.buildFaces(s, i.vertices, e),
                a = material(e),
                l = new THREE.Mesh(n, a); return new Object3D({ obj: l, units: e.units, anchor: e.anchor, adjustment: e.adjustment, bbox: e.bbox, tooltip: e.tooltip, raycasted: e.raycasted }) } tube.prototype = { buildVertices: function(e, t, r) { var o = new THREE.PlaneBufferGeometry(99999999999, 9999999999),
                    s = new THREE.MeshBasicMaterial({ color: 16777215, side: THREE.DoubleSide });
                s.opacity = 0; var n = new THREE.Mesh(o, s),
                    a = new THREE.Geometry,
                    l = !1,
                    c = [t[0].clone().normalize()]; for (i in t) { var u;
                    i = parseFloat(i), t[i + 1] && (u = (new THREE.Vector3).subVectors(t[i + 1], t[i]).normalize()), c.push(u) } for (i in c.push(new THREE.Vector3), t) { i = parseFloat(i); var d = t[i],
                        E = c[i],
                        p = c[i + 1],
                        b = E.clone().add(p).normalize(); if (0 === i ? b = p : i === t.length - 1 && (b = E), l) { let e = [];
                        n.position.copy(d), n.lookAt(b.clone().add(d)), n.updateMatrixWorld(), l.forEach(function(t) { let r = new THREE.Raycaster(t, E).intersectObject(n)[0];
                            r ? (a.vertices.push(r.point), e.push(r.point)) : console.error("Tube geometry failed at vertex " + i + ". Consider reducing tube radius, or smoothening out the sharp angle at this vertex") }), l = e } else { let t = e.clone();
                        t.lookAt(b), t.vertices.forEach(function(e) { a.vertices.push(e.add(d)) }), l = t.vertices } } return r.remove(n), a }, defineCrossSection: function(e) { let t = new THREE.Geometry,
                    r = e.sides; for (let i = 0; i < r; i++) { let o = e.radius,
                        s = (i + .5) / r * Math.PI;
                    t.vertices.push(new THREE.Vector3(-Math.sin(2 * s), Math.cos(2 * s), 0).multiplyScalar(o)) } return t }, buildFaces: function(e, t, r) { for (let i in t) { t[i = parseFloat(i)]; if (i < t.length - 1)
                        for (let t = 0; t < r.sides; t++) { let o = i * r.sides + t,
                                s = i * r.sides + (t + 1) % r.sides,
                                n = o + r.sides,
                                a = s + r.sides,
                                l = new THREE.Face3(n, o, s),
                                c = new THREE.Face3(n, s, a);
                            e.faces.push(l, c) } } let i = e.vertices.length; for (let t = 0; t + 2 < r.sides; t++) { let r = new THREE.Face3(0, t + 2, t + 1),
                        o = new THREE.Face3(i - 1, i - 1 - (t + 2), i - 1 - (t + 1));
                    e.faces.push(r, o) } e.computeFaceNormals();
                (new THREE.BufferGeometry).fromGeometry(e); return e } }, module.exports = exports = tube;

    }, { "../three.js": 23, "../utils/material.js": 25, "../utils/utils.js": 27, "./Object3D.js": 7, "./objects.js": 19 }],
    23: [function(require, module, exports) {
        ! function(e, t) { "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = e || self).THREE = {}) }(this, function(e) {
            function t() {}

            function n(e, t) { this.x = e || 0, this.y = t || 0 }

            function i() { this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.") }

            function r(e, t, a, o, s, c, l, h, u, p) { Object.defineProperty(this, "id", { value: Oa++ }), this.uuid = Ra.generateUUID(), this.name = "", this.image = void 0 !== e ? e : r.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== t ? t : r.DEFAULT_MAPPING, this.wrapS = void 0 !== a ? a : 1001, this.wrapT = void 0 !== o ? o : 1001, this.magFilter = void 0 !== s ? s : 1006, this.minFilter = void 0 !== c ? c : 1008, this.anisotropy = void 0 !== u ? u : 1, this.format = void 0 !== l ? l : 1023, this.internalFormat = null, this.type = void 0 !== h ? h : 1009, this.offset = new n(0, 0), this.repeat = new n(1, 1), this.center = new n(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new i, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== p ? p : 3e3, this.version = 0, this.onUpdate = null }

            function a(e, t, n, i) { this.x = e || 0, this.y = t || 0, this.z = n || 0, this.w = void 0 !== i ? i : 1 }

            function o(e, t, n) { this.width = e, this.height = t, this.scissor = new a(0, 0, e, t), this.scissorTest = !1, this.viewport = new a(0, 0, e, t), n = n || {}, this.texture = new r(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = e, this.texture.image.height = t, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null }

            function s(e, t, n) { o.call(this, e, t, n), this.samples = 4 }

            function c(e, t, n, i) { this._x = e || 0, this._y = t || 0, this._z = n || 0, this._w = void 0 !== i ? i : 1 }

            function l(e, t, n) { this.x = e || 0, this.y = t || 0, this.z = n || 0 }

            function h() { this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.") }

            function u(e, t, n, i) { this._x = e || 0, this._y = t || 0, this._z = n || 0, this._order = i || u.DefaultOrder }

            function p() { this.mask = 1 }

            function d() { Object.defineProperty(this, "id", { value: ja++ }), this.uuid = Ra.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = d.DefaultUp.clone(); var e = new l,
                    t = new u,
                    n = new c,
                    r = new l(1, 1, 1);
                t._onChange(function() { n.setFromEuler(t, !1) }), n._onChange(function() { t.setFromQuaternion(n, void 0, !1) }), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: e }, rotation: { configurable: !0, enumerable: !0, value: t }, quaternion: { configurable: !0, enumerable: !0, value: n }, scale: { configurable: !0, enumerable: !0, value: r }, modelViewMatrix: { value: new h }, normalMatrix: { value: new i } }), this.matrix = new h, this.matrixWorld = new h, this.matrixAutoUpdate = d.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new p, this.visible = !0, this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {} }

            function f() { d.call(this), this.type = "Scene", this.overrideMaterial = this.fog = this.environment = this.background = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) }

            function m(e, t) { this.min = void 0 !== e ? e : new l(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== t ? t : new l(-1 / 0, -1 / 0, -1 / 0) }

            function g(e, t, n, i, r) { var a, o = 0; for (a = e.length - 3; o <= a; o += 3) { go.fromArray(e, o); var s = r.x * Math.abs(go.x) + r.y * Math.abs(go.y) + r.z * Math.abs(go.z),
                        c = t.dot(go),
                        l = n.dot(go),
                        h = i.dot(go); if (Math.max(-Math.max(c, l, h), Math.min(c, l, h)) > s) return !1 } return !0 }

            function v(e, t) { this.center = void 0 !== e ? e : new l, this.radius = void 0 !== t ? t : -1 }

            function y(e, t) { this.origin = void 0 !== e ? e : new l, this.direction = void 0 !== t ? t : new l(0, 0, -1) }

            function x(e, t) { this.normal = void 0 !== e ? e : new l(1, 0, 0), this.constant = void 0 !== t ? t : 0 }

            function _(e, t, n) { this.a = void 0 !== e ? e : new l, this.b = void 0 !== t ? t : new l, this.c = void 0 !== n ? n : new l }

            function b(e, t, n) { return void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n) }

            function w(e, t, n) { return 0 > n && (n += 1), 1 < n && --n, n < 1 / 6 ? e + 6 * (t - e) * n : .5 > n ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e }

            function M(e) { return .04045 > e ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4) }

            function S(e) { return .0031308 > e ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055 }

            function T(e, t, n, i, r, a) { this.a = e, this.b = t, this.c = n, this.normal = i && i.isVector3 ? i : new l, this.vertexNormals = Array.isArray(i) ? i : [], this.color = r && r.isColor ? r : new b, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== a ? a : 0 }

            function E() { Object.defineProperty(this, "id", { value: Ho++ }), this.uuid = Ra.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.vertexColors = this.flatShading = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null, this.depthFunc = 3, this.depthWrite = this.depthTest = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilZPass = this.stencilZFail = this.stencilFail = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipShadows = this.clipIntersection = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.toneMapped = this.visible = !0, this.userData = {}, this.version = 0 }

            function A(e) { E.call(this), this.type = "MeshBasicMaterial", this.color = new b(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphTargets = this.skinning = !1, this.setValues(e) }

            function L(e, t, n) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === n, this.usage = 35044, this.updateRange = { offset: 0, count: -1 }, this.version = 0 }

            function R(e, t, n) { L.call(this, new Int8Array(e), t, n) }

            function P(e, t, n) { L.call(this, new Uint8Array(e), t, n) }

            function C(e, t, n) { L.call(this, new Uint8ClampedArray(e), t, n) }

            function O(e, t, n) { L.call(this, new Int16Array(e), t, n) }

            function D(e, t, n) { L.call(this, new Uint16Array(e), t, n) }

            function I(e, t, n) { L.call(this, new Int32Array(e), t, n) }

            function N(e, t, n) { L.call(this, new Uint32Array(e), t, n) }

            function B(e, t, n) { L.call(this, new Float32Array(e), t, n) }

            function z(e, t, n) { L.call(this, new Float64Array(e), t, n) }

            function U() { this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1 }

            function F(e) { if (0 === e.length) return -1 / 0; for (var t = e[0], n = 1, i = e.length; n < i; ++n) e[n] > t && (t = e[n]); return t }

            function G() { Object.defineProperty(this, "id", { value: Vo += 2 }), this.uuid = Ra.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingSphere = this.boundingBox = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} }

            function H(e, t) { d.call(this), this.type = "Mesh", this.geometry = void 0 !== e ? e : new G, this.material = void 0 !== t ? t : new A, this.updateMorphTargets() }

            function k(e, t, n, i, r, a, o, s) { return null === (1 === t.side ? i.intersectTriangle(o, a, r, !0, s) : i.intersectTriangle(r, a, o, 2 !== t.side, s)) ? null : (ps.copy(s), ps.applyMatrix4(e.matrixWorld), (t = n.ray.origin.distanceTo(ps)) < n.near || t > n.far ? null : { distance: t, point: ps.clone(), object: e }) }

            function V(e, t, i, r, a, o, s, c, l, h, u, p) { if ($o.fromBufferAttribute(a, h), es.fromBufferAttribute(a, u), ts.fromBufferAttribute(a, p), a = e.morphTargetInfluences, t.morphTargets && o && a) { as.set(0, 0, 0), os.set(0, 0, 0), ss.set(0, 0, 0); for (var d = 0, f = o.length; d < f; d++) { var m = a[d],
                            g = o[d];
                        0 !== m && (ns.fromBufferAttribute(g, h), is.fromBufferAttribute(g, u), rs.fromBufferAttribute(g, p), s ? (as.addScaledVector(ns, m), os.addScaledVector(is, m), ss.addScaledVector(rs, m)) : (as.addScaledVector(ns.sub($o), m), os.addScaledVector(is.sub(es), m), ss.addScaledVector(rs.sub(ts), m))) } $o.add(as), es.add(os), ts.add(ss) } return e.isSkinnedMesh && (e.boneTransform(h, $o), e.boneTransform(u, es), e.boneTransform(p, ts)), (e = k(e, t, i, r, $o, es, ts, us)) && (c && (cs.fromBufferAttribute(c, h), ls.fromBufferAttribute(c, u), hs.fromBufferAttribute(c, p), e.uv = _.getUV(us, $o, es, ts, cs, ls, hs, new n)), l && (cs.fromBufferAttribute(l, h), ls.fromBufferAttribute(l, u), hs.fromBufferAttribute(l, p), e.uv2 = _.getUV(us, $o, es, ts, cs, ls, hs, new n)), c = new T(h, u, p), _.getNormal($o, es, ts, c.normal), e.face = c), e }

            function j() { Object.defineProperty(this, "id", { value: ds += 2 }), this.uuid = Ra.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1 }

            function W(e) { var t, n = {}; for (t in e)
                    for (var i in n[t] = {}, e[t]) { var r = e[t][i];
                        r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? n[t][i] = r.clone() : Array.isArray(r) ? n[t][i] = r.slice() : n[t][i] = r }
                return n }

            function q(e) { for (var t = {}, n = 0; n < e.length; n++) { var i, r = W(e[n]); for (i in r) t[i] = r[i] } return t }

            function X(e) { E.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e)) }

            function Y() { d.call(this), this.type = "Camera", this.matrixWorldInverse = new h, this.projectionMatrix = new h, this.projectionMatrixInverse = new h }

            function Z(e, t, n, i) { Y.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== e ? e : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== i ? i : 2e3, this.focus = 10, this.aspect = void 0 !== t ? t : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() }

            function J(e, t, n) { if (d.call(this), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                else { this.renderTarget = n; var i = new Z(90, 1, e, t);
                    i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new l(1, 0, 0)), this.add(i); var r = new Z(90, 1, e, t);
                    r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new l(-1, 0, 0)), this.add(r); var a = new Z(90, 1, e, t);
                    a.layers = this.layers, a.up.set(0, 0, 1), a.lookAt(new l(0, 1, 0)), this.add(a); var o = new Z(90, 1, e, t);
                    o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(new l(0, -1, 0)), this.add(o); var s = new Z(90, 1, e, t);
                    s.layers = this.layers, s.up.set(0, -1, 0), s.lookAt(new l(0, 0, 1)), this.add(s); var c = new Z(90, 1, e, t);
                    c.layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new l(0, 0, -1)), this.add(c), this.update = function(e, t) { null === this.parent && this.updateMatrixWorld(); var l = e.xr.enabled,
                            h = e.getRenderTarget();
                        e.xr.enabled = !1; var u = n.texture.generateMipmaps;
                        n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, i), e.setRenderTarget(n, 1), e.render(t, r), e.setRenderTarget(n, 2), e.render(t, a), e.setRenderTarget(n, 3), e.render(t, o), e.setRenderTarget(n, 4), e.render(t, s), n.texture.generateMipmaps = u, e.setRenderTarget(n, 5), e.render(t, c), e.setRenderTarget(h), e.xr.enabled = l }, this.clear = function(e, t, i, r) { for (var a = e.getRenderTarget(), o = 0; 6 > o; o++) e.setRenderTarget(n, o), e.clear(t, i, r);
                        e.setRenderTarget(a) } } }

            function Q(e, t, n) { Number.isInteger(t) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), t = n), o.call(this, e, e, t) }

            function K(e, t, n, i, a, o, s, c, l, h, u, p) { r.call(this, null, o, s, c, l, h, i, a, u, p), this.image = { data: e || null, width: t || 1, height: n || 1 }, this.magFilter = void 0 !== l ? l : 1003, this.minFilter = void 0 !== h ? h : 1003, this.flipY = this.generateMipmaps = !1, this.unpackAlignment = 1, this.needsUpdate = !0 }

            function $(e, t, n, i, r, a) { this.planes = [void 0 !== e ? e : new x, void 0 !== t ? t : new x, void 0 !== n ? n : new x, void 0 !== i ? i : new x, void 0 !== r ? r : new x, void 0 !== a ? a : new x] }

            function ee() {
                function e(r, a) {!1 !== n && (i(r, a), t.requestAnimationFrame(e)) } var t = null,
                    n = !1,
                    i = null; return { start: function() {!0 !== n && null !== i && (t.requestAnimationFrame(e), n = !0) }, stop: function() { n = !1 }, setAnimationLoop: function(e) { i = e }, setContext: function(e) { t = e } } }

            function te(e, t) { var n = t.isWebGL2,
                    i = new WeakMap; return { get: function(e) { return e.isInterleavedBufferAttribute && (e = e.data), i.get(e) }, remove: function(t) { t.isInterleavedBufferAttribute && (t = t.data); var n = i.get(t);
                        n && (e.deleteBuffer(n.buffer), i.delete(t)) }, update: function(t, r) { t.isInterleavedBufferAttribute && (t = t.data); var a = i.get(t); if (void 0 === a) i.set(t, function(t, n) { var i = t.array,
                                r = t.usage,
                                a = e.createBuffer(); return e.bindBuffer(n, a), e.bufferData(n, i, r), t.onUploadCallback(), n = 5126, i instanceof Float32Array ? n = 5126 : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? n = 5123 : i instanceof Int16Array ? n = 5122 : i instanceof Uint32Array ? n = 5125 : i instanceof Int32Array ? n = 5124 : i instanceof Int8Array ? n = 5120 : i instanceof Uint8Array && (n = 5121), { buffer: a, type: n, bytesPerElement: i.BYTES_PER_ELEMENT, version: t.version } }(t, r));
                        else if (a.version < t.version) { var o = t.array,
                                s = t.updateRange;
                            e.bindBuffer(r, a.buffer), -1 === s.count ? e.bufferSubData(r, 0, o) : (n ? e.bufferSubData(r, s.offset * o.BYTES_PER_ELEMENT, o, s.offset, s.count) : e.bufferSubData(r, s.offset * o.BYTES_PER_ELEMENT, o.subarray(s.offset, s.offset + s.count)), s.count = -1), a.version = t.version } } } }

            function ne(e, t, n, i) { j.call(this), this.type = "PlaneGeometry", this.parameters = { width: e, height: t, widthSegments: n, heightSegments: i }, this.fromBufferGeometry(new ie(e, t, n, i)), this.mergeVertices() }

            function ie(e, t, n, i) { G.call(this), this.type = "PlaneBufferGeometry", this.parameters = { width: e, height: t, widthSegments: n, heightSegments: i }; var r = (e = e || 1) / 2,
                    a = (t = t || 1) / 2,
                    o = (n = Math.floor(n) || 1) + 1,
                    s = (i = Math.floor(i) || 1) + 1,
                    c = e / n,
                    l = t / i,
                    h = [],
                    u = [],
                    p = [],
                    d = []; for (e = 0; e < s; e++) { var f = e * l - a; for (t = 0; t < o; t++) u.push(t * c - r, -f, 0), p.push(0, 0, 1), d.push(t / n), d.push(1 - e / i) } for (e = 0; e < i; e++)
                    for (t = 0; t < n; t++) r = t + o * (e + 1), a = t + 1 + o * (e + 1), s = t + 1 + o * e, h.push(t + o * e, r, s), h.push(r, a, s);
                this.setIndex(h), this.setAttribute("position", new B(u, 3)), this.setAttribute("normal", new B(p, 3)), this.setAttribute("uv", new B(d, 2)) }

            function re(e, t, n, i) {
                function r(e, n) { t.buffers.color.setClear(e.r, e.g, e.b, n, i) } var a, o, s = new b(0),
                    c = 0,
                    l = null,
                    h = 0,
                    u = null; return { getClearColor: function() { return s }, setClearColor: function(e, t) { s.set(e), r(s, c = void 0 !== t ? t : 1) }, getClearAlpha: function() { return c }, setClearAlpha: function(e) { r(s, c = e) }, render: function(t, i, p, d) { i = i.background, (p = (p = e.xr).getSession && p.getSession()) && "additive" === p.environmentBlendMode && (i = null), null === i ? r(s, c) : i && i.isColor && (r(i, 1), d = !0), (e.autoClear || d) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), i && (i.isCubeTexture || i.isWebGLCubeRenderTarget || 306 === i.mapping) ? (void 0 === o && ((o = new H(new ys(1, 1, 1), new X({ type: "BackgroundCubeMaterial", uniforms: W(Ss.cube.uniforms), vertexShader: Ss.cube.vertexShader, fragmentShader: Ss.cube.fragmentShader, side: 1, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.deleteAttribute("normal"), o.geometry.deleteAttribute("uv"), o.onBeforeRender = function(e, t, n) { this.matrixWorld.copyPosition(n.matrixWorld) }, Object.defineProperty(o.material, "envMap", { get: function() { return this.uniforms.envMap.value } }), n.update(o)), d = i.isWebGLCubeRenderTarget ? i.texture : i, o.material.uniforms.envMap.value = d, o.material.uniforms.flipEnvMap.value = d.isCubeTexture ? -1 : 1, l === i && h === d.version && u === e.toneMapping || (o.material.needsUpdate = !0, l = i, h = d.version, u = e.toneMapping), t.unshift(o, o.geometry, o.material, 0, 0, null)) : i && i.isTexture && (void 0 === a && ((a = new H(new ie(2, 2), new X({ type: "BackgroundMaterial", uniforms: W(Ss.background.uniforms), vertexShader: Ss.background.vertexShader, fragmentShader: Ss.background.fragmentShader, side: 0, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.deleteAttribute("normal"), Object.defineProperty(a.material, "map", { get: function() { return this.uniforms.t2D.value } }), n.update(a)), a.material.uniforms.t2D.value = i, !0 === i.matrixAutoUpdate && i.updateMatrix(), a.material.uniforms.uvTransform.value.copy(i.matrix), l === i && h === i.version && u === e.toneMapping || (a.material.needsUpdate = !0, l = i, h = i.version, u = e.toneMapping), t.unshift(a, a.geometry, a.material, 0, 0, null)) } } }

            function ae(e, t, n, i) { var r, a = i.isWebGL2;
                this.setMode = function(e) { r = e }, this.render = function(t, i) { e.drawArrays(r, t, i), n.update(i, r) }, this.renderInstances = function(i, o, s, c) { if (0 !== c) { if (a) { i = e; var l = "drawArraysInstanced" } else if (l = "drawArraysInstancedANGLE", null === (i = t.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        i[l](r, o, s, c), n.update(s, r, c) } } }

            function oe(e, t, n) {
                function i(t) { if ("highp" === t) { if (0 < e.getShaderPrecisionFormat(35633, 36338).precision && 0 < e.getShaderPrecisionFormat(35632, 36338).precision) return "highp";
                        t = "mediump" } return "mediump" === t && 0 < e.getShaderPrecisionFormat(35633, 36337).precision && 0 < e.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp" } var r, a = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext,
                    o = void 0 !== n.precision ? n.precision : "highp",
                    s = i(o);
                s !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", s, "instead."), o = s), n = !0 === n.logarithmicDepthBuffer, s = e.getParameter(34930); var c = e.getParameter(35660),
                    l = e.getParameter(3379),
                    h = e.getParameter(34076),
                    u = e.getParameter(34921),
                    p = e.getParameter(36347),
                    d = e.getParameter(36348),
                    f = e.getParameter(36349),
                    m = 0 < c,
                    g = a || !!t.get("OES_texture_float"); return { isWebGL2: a, getMaxAnisotropy: function() { if (void 0 !== r) return r; var n = t.get("EXT_texture_filter_anisotropic"); return r = null !== n ? e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0 }, getMaxPrecision: i, precision: o, logarithmicDepthBuffer: n, maxTextures: s, maxVertexTextures: c, maxTextureSize: l, maxCubemapSize: h, maxAttributes: u, maxVertexUniforms: p, maxVaryings: d, maxFragmentUniforms: f, vertexTextures: m, floatFragmentTextures: g, floatVertexTextures: m && g, maxSamples: a ? e.getParameter(36183) : 0 } }

            function se() {
                function e() { h.value !== r && (h.value = r, h.needsUpdate = 0 < a), n.numPlanes = a, n.numIntersection = 0 }

                function t(e, t, i, r) { var a = null !== e ? e.length : 0,
                        o = null; if (0 !== a) { if (o = h.value, !0 !== r || null === o)
                            for (r = i + 4 * a, t = t.matrixWorldInverse, l.getNormalMatrix(t), (null === o || o.length < r) && (o = new Float32Array(r)), r = 0; r !== a; ++r, i += 4) c.copy(e[r]).applyMatrix4(t, l), c.normal.toArray(o, i), o[i + 3] = c.constant;
                        h.value = o, h.needsUpdate = !0 } return n.numPlanes = a, n.numIntersection = 0, o } var n = this,
                    r = null,
                    a = 0,
                    o = !1,
                    s = !1,
                    c = new x,
                    l = new i,
                    h = { value: null, needsUpdate: !1 };
                this.uniform = h, this.numIntersection = this.numPlanes = 0, this.init = function(e, n, i) { var s = 0 !== e.length || n || 0 !== a || o; return o = n, r = t(e, i, 0), a = e.length, s }, this.beginShadows = function() { s = !0, t(null) }, this.endShadows = function() { s = !1, e() }, this.setState = function(n, i, c, l, u, p) { if (!o || null === n || 0 === n.length || s && !c) s ? t(null) : e();
                    else { var d = 4 * (c = s ? 0 : a),
                            f = u.clippingState || null; for (h.value = f, f = t(n, l, d, p), n = 0; n !== d; ++n) f[n] = r[n];
                        u.clippingState = f, this.numIntersection = i ? this.numPlanes : 0, this.numPlanes += c } } }

            function ce(e) { var t = {}; return { get: function(n) { if (void 0 !== t[n]) return t[n]; switch (n) {
                            case "WEBGL_depth_texture":
                                var i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture"); break;
                            case "EXT_texture_filter_anisotropic":
                                i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break;
                            case "WEBGL_compressed_texture_s3tc":
                                i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break;
                            case "WEBGL_compressed_texture_pvrtc":
                                i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break;
                            default:
                                i = e.getExtension(n) } return null === i && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), t[n] = i } } }

            function le(e, t, n) {
                function i(e) { var r = e.target; for (var s in null !== (e = a.get(r)).index && t.remove(e.index), e.attributes) t.remove(e.attributes[s]);
                    r.removeEventListener("dispose", i), a.delete(r), (s = o.get(e)) && (t.remove(s), o.delete(e)), n.memory.geometries-- }

                function r(e) { var n = [],
                        i = e.index,
                        r = e.attributes.position; if (null !== i) { var a = i.array;
                        i = i.version, r = 0; for (var s = a.length; r < s; r += 3) { var c = a[r + 0],
                                l = a[r + 1],
                                h = a[r + 2];
                            n.push(c, l, l, h, h, c) } } else
                        for (a = r.array, i = r.version, r = 0, s = a.length / 3 - 1; r < s; r += 3) c = r + 0, l = r + 1, h = r + 2, n.push(c, l, l, h, h, c);
                    (n = new(65535 < F(n) ? N : D)(n, 1)).version = i, t.update(n, 34963), (a = o.get(e)) && t.remove(a), o.set(e, n) } var a = new WeakMap,
                    o = new WeakMap; return { get: function(e, t) { var r = a.get(t); return r || (t.addEventListener("dispose", i), t.isBufferGeometry ? r = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new G).setFromObject(e)), r = t._bufferGeometry), a.set(t, r), n.memory.geometries++, r) }, update: function(e) { var n = e.index,
                            i = e.attributes; for (var r in null !== n && t.update(n, 34963), i) t.update(i[r], 34962); for (r in e = e.morphAttributes) { i = 0; for (var a = (n = e[r]).length; i < a; i++) t.update(n[i], 34962) } }, getWireframeAttribute: function(e) { var t = o.get(e); if (t) { var n = e.index;
                            null !== n && t.version < n.version && r(e) } else r(e); return o.get(e) } } }

            function he(e, t, n, i) { var r, a, o, s = i.isWebGL2;
                this.setMode = function(e) { r = e }, this.setIndex = function(e) { a = e.type, o = e.bytesPerElement }, this.render = function(t, i) { e.drawElements(r, i, a, t * o), n.update(i, r) }, this.renderInstances = function(i, c, l, h) { if (0 !== h) { if (s) { i = e; var u = "drawElementsInstanced" } else if (u = "drawElementsInstancedANGLE", null === (i = t.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        i[u](r, l, a, c * o, h), n.update(l, r, h) } } }

            function ue(e) { var t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; return { memory: { geometries: 0, textures: 0 }, render: t, programs: null, autoReset: !0, reset: function() { t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0 }, update: function(e, n, i) { switch (i = i || 1, t.calls++, n) {
                            case 4:
                                t.triangles += e / 3 * i; break;
                            case 1:
                                t.lines += e / 2 * i; break;
                            case 3:
                                t.lines += i * (e - 1); break;
                            case 2:
                                t.lines += i * e; break;
                            case 0:
                                t.points += i * e; break;
                            default:
                                console.error("THREE.WebGLInfo: Unknown draw mode:", n) } } } }

            function pe(e, t) { return Math.abs(t[1]) - Math.abs(e[1]) }

            function de(e) { var t = {},
                    n = new Float32Array(8); return { update: function(i, r, a, o) { var s = i.morphTargetInfluences,
                            c = void 0 === s ? 0 : s.length; if (void 0 === (i = t[r.id])) { i = []; for (var l = 0; l < c; l++) i[l] = [l, 0];
                            t[r.id] = i } var h = a.morphTargets && r.morphAttributes.position; for (a = a.morphNormals && r.morphAttributes.normal, l = 0; l < c; l++) { var u = i[l];
                            0 !== u[1] && (h && r.deleteAttribute("morphTarget" + l), a && r.deleteAttribute("morphNormal" + l)) } for (l = 0; l < c; l++)(u = i[l])[0] = l, u[1] = s[l]; for (i.sort(pe), l = s = 0; 8 > l; l++)(u = i[l]) && (c = u[0], u = u[1]) ? (h && r.setAttribute("morphTarget" + l, h[c]), a && r.setAttribute("morphNormal" + l, a[c]), n[l] = u, s += u) : n[l] = 0;
                        r = r.morphTargetsRelative ? 1 : 1 - s, o.getUniforms().setValue(e, "morphTargetBaseInfluence", r), o.getUniforms().setValue(e, "morphTargetInfluences", n) } } }

            function fe(e, t, n, i) { var r = new WeakMap; return { update: function(e) { var a = i.render.frame,
                            o = e.geometry,
                            s = t.get(e, o); return r.get(s) !== a && (o.isGeometry && s.updateFromObject(e), t.update(s), r.set(s, a)), e.isInstancedMesh && n.update(e.instanceMatrix, 34962), s }, dispose: function() { r = new WeakMap } } }

            function me(e, t, n, i, a, o, s, c, l, h) { e = void 0 !== e ? e : [], r.call(this, e, void 0 !== t ? t : 301, n, i, a, o, void 0 !== s ? s : 1022, c, l, h), this.flipY = !1 }

            function ge(e, t, n, i) { r.call(this, null), this.image = { data: e || null, width: t || 1, height: n || 1, depth: i || 1 }, this.minFilter = this.magFilter = 1003, this.wrapR = 1001, this.flipY = this.generateMipmaps = !1, this.needsUpdate = !0 }

            function ve(e, t, n, i) { r.call(this, null), this.image = { data: e || null, width: t || 1, height: n || 1, depth: i || 1 }, this.minFilter = this.magFilter = 1003, this.wrapR = 1001, this.flipY = this.generateMipmaps = !1, this.needsUpdate = !0 }

            function ye(e, t, n) { var i = e[0]; if (0 >= i || 0 < i) return e; var r = t * n,
                    a = Rs[r]; if (void 0 === a && (a = new Float32Array(r), Rs[r] = a), 0 !== t)
                    for (i.toArray(a, 0), i = 1, r = 0; i !== t; ++i) r += n, e[i].toArray(a, r); return a }

            function xe(e, t) { if (e.length !== t.length) return !1; for (var n = 0, i = e.length; n < i; n++)
                    if (e[n] !== t[n]) return !1; return !0 }

            function _e(e, t) { for (var n = 0, i = t.length; n < i; n++) e[n] = t[n] }

            function be(e, t) { var n = Ps[t];
                void 0 === n && (n = new Int32Array(t), Ps[t] = n); for (var i = 0; i !== t; ++i) n[i] = e.allocateTextureUnit(); return n }

            function we(e, t) { var n = this.cache;
                n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t) }

            function Me(e, t) { var n = this.cache;
                void 0 !== t.x ? n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y) : xe(n, t) || (e.uniform2fv(this.addr, t), _e(n, t)) }

            function Se(e, t) { var n = this.cache;
                void 0 !== t.x ? n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z) : void 0 !== t.r ? n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b) : xe(n, t) || (e.uniform3fv(this.addr, t), _e(n, t)) }

            function Te(e, t) { var n = this.cache;
                void 0 !== t.x ? n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w) : xe(n, t) || (e.uniform4fv(this.addr, t), _e(n, t)) }

            function Ee(e, t) { var n = this.cache,
                    i = t.elements;
                void 0 === i ? xe(n, t) || (e.uniformMatrix2fv(this.addr, !1, t), _e(n, t)) : xe(n, i) || (Ds.set(i), e.uniformMatrix2fv(this.addr, !1, Ds), _e(n, i)) }

            function Ae(e, t) { var n = this.cache,
                    i = t.elements;
                void 0 === i ? xe(n, t) || (e.uniformMatrix3fv(this.addr, !1, t), _e(n, t)) : xe(n, i) || (Os.set(i), e.uniformMatrix3fv(this.addr, !1, Os), _e(n, i)) }

            function Le(e, t) { var n = this.cache,
                    i = t.elements;
                void 0 === i ? xe(n, t) || (e.uniformMatrix4fv(this.addr, !1, t), _e(n, t)) : xe(n, i) || (Cs.set(i), e.uniformMatrix4fv(this.addr, !1, Cs), _e(n, i)) }

            function Re(e, t, n) { var i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(t || Ts, r) }

            function Pe(e, t, n) { var i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(t || Es, r) }

            function Ce(e, t, n) { var i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(t || As, r) }

            function Oe(e, t, n) { var i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(t || Ls, r) }

            function De(e, t) { var n = this.cache;
                n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t) }

            function Ie(e, t) { var n = this.cache;
                xe(n, t) || (e.uniform2iv(this.addr, t), _e(n, t)) }

            function Ne(e, t) { var n = this.cache;
                xe(n, t) || (e.uniform3iv(this.addr, t), _e(n, t)) }

            function Be(e, t) { var n = this.cache;
                xe(n, t) || (e.uniform4iv(this.addr, t), _e(n, t)) }

            function ze(e, t) { var n = this.cache;
                n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t) }

            function Ue(e, t) { e.uniform1fv(this.addr, t) }

            function Fe(e, t) { e.uniform1iv(this.addr, t) }

            function Ge(e, t) { e.uniform2iv(this.addr, t) }

            function He(e, t) { e.uniform3iv(this.addr, t) }

            function ke(e, t) { e.uniform4iv(this.addr, t) }

            function Ve(e, t) { t = ye(t, this.size, 2), e.uniform2fv(this.addr, t) }

            function je(e, t) { t = ye(t, this.size, 3), e.uniform3fv(this.addr, t) }

            function We(e, t) { t = ye(t, this.size, 4), e.uniform4fv(this.addr, t) }

            function qe(e, t) { t = ye(t, this.size, 4), e.uniformMatrix2fv(this.addr, !1, t) }

            function Xe(e, t) { t = ye(t, this.size, 9), e.uniformMatrix3fv(this.addr, !1, t) }

            function Ye(e, t) { t = ye(t, this.size, 16), e.uniformMatrix4fv(this.addr, !1, t) }

            function Ze(e, t, n) { var i = t.length,
                    r = be(n, i); for (e.uniform1iv(this.addr, r), e = 0; e !== i; ++e) n.safeSetTexture2D(t[e] || Ts, r[e]) }

            function Je(e, t, n) { var i = t.length,
                    r = be(n, i); for (e.uniform1iv(this.addr, r), e = 0; e !== i; ++e) n.safeSetTextureCube(t[e] || Ls, r[e]) }

            function Qe(e, t, n) { this.id = e, this.addr = n, this.cache = [], this.setValue = function(e) { switch (e) {
                        case 5126:
                            return we;
                        case 35664:
                            return Me;
                        case 35665:
                            return Se;
                        case 35666:
                            return Te;
                        case 35674:
                            return Ee;
                        case 35675:
                            return Ae;
                        case 35676:
                            return Le;
                        case 5124:
                        case 35670:
                            return De;
                        case 35667:
                        case 35671:
                            return Ie;
                        case 35668:
                        case 35672:
                            return Ne;
                        case 35669:
                        case 35673:
                            return Be;
                        case 5125:
                            return ze;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return Re;
                        case 35679:
                        case 36299:
                        case 36307:
                            return Ce;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return Oe;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return Pe } }(t.type) }

            function Ke(e, t, n) { this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = function(e) { switch (e) {
                        case 5126:
                            return Ue;
                        case 35664:
                            return Ve;
                        case 35665:
                            return je;
                        case 35666:
                            return We;
                        case 35674:
                            return qe;
                        case 35675:
                            return Xe;
                        case 35676:
                            return Ye;
                        case 5124:
                        case 35670:
                            return Fe;
                        case 35667:
                        case 35671:
                            return Ge;
                        case 35668:
                        case 35672:
                            return He;
                        case 35669:
                        case 35673:
                            return ke;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return Ze;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return Je } }(t.type) }

            function $e(e) { this.id = e, this.seq = [], this.map = {} }

            function et(e, t) { this.seq = [], this.map = {}; for (var n = e.getProgramParameter(t, 35718), i = 0; i < n; ++i) { var r = e.getActiveUniform(t, i),
                        a = e.getUniformLocation(t, r.name),
                        o = this,
                        s = r.name,
                        c = s.length; for (Is.lastIndex = 0;;) { var l = Is.exec(s),
                            h = Is.lastIndex,
                            u = l[1],
                            p = l[3]; if ("]" === l[2] && (u |= 0), void 0 === p || "[" === p && h + 2 === c) { s = o, r = void 0 === p ? new Qe(u, r, a) : new Ke(u, r, a), s.seq.push(r), s.map[r.id] = r; break } void 0 === (p = o.map[u]) && (p = new $e(u), u = o, o = p, u.seq.push(o), u.map[o.id] = o), o = p } } }

            function tt(e, t, n) { return t = e.createShader(t), e.shaderSource(t, n), e.compileShader(t), t }

            function nt(e) { switch (e) {
                    case 3e3:
                        return ["Linear", "( value )"];
                    case 3001:
                        return ["sRGB", "( value )"];
                    case 3002:
                        return ["RGBE", "( value )"];
                    case 3004:
                        return ["RGBM", "( value, 7.0 )"];
                    case 3005:
                        return ["RGBM", "( value, 16.0 )"];
                    case 3006:
                        return ["RGBD", "( value, 256.0 )"];
                    case 3007:
                        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                    case 3003:
                        return ["LogLuv", "( value )"];
                    default:
                        throw Error("unsupported encoding: " + e) } }

            function it(e, t, n) { var i = e.getShaderParameter(t, 35713),
                    r = e.getShaderInfoLog(t).trim(); if (i && "" === r) return ""; for (e = e.getShaderSource(t).split("\n"), t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t]; return "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + r + (e = e.join("\n")) }

            function rt(e, t) { return "vec4 " + e + "( vec4 value ) { return " + (t = nt(t))[0] + "ToLinear" + t[1] + "; }" }

            function at(e, t) { return "vec4 " + e + "( vec4 value ) { return LinearTo" + (t = nt(t))[0] + t[1] + "; }" }

            function ot(e, t) { switch (t) {
                    case 1:
                        t = "Linear"; break;
                    case 2:
                        t = "Reinhard"; break;
                    case 3:
                        t = "Uncharted2"; break;
                    case 4:
                        t = "OptimizedCineon"; break;
                    case 5:
                        t = "ACESFilmic"; break;
                    default:
                        throw Error("unsupported toneMapping: " + t) } return "vec3 " + e + "( vec3 color ) { return " + t + "ToneMapping( color ); }" }

            function st(e) { return "" !== e }

            function ct(e, t) { return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows) }

            function lt(e, t) { return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection) }

            function ht(e, t) { if (void 0 === (e = Ms[t])) throw Error("Can not resolve #include <" + t + ">"); return e.replace(Bs, ht) }

            function ut(e, t, n, i) { return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), pt(e, t, n, i) }

            function pt(e, t, n, i) { for (e = "", t = parseInt(t); t < parseInt(n); t++) e += i.replace(/\[ i \]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t); return e }

            function dt(e) { var t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;"; return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t }

            function ft(e, t, n) { var i, r, a = e.getContext(),
                    o = n.defines,
                    s = n.vertexShader,
                    c = n.fragmentShader,
                    l = function(e) { var t = "SHADOWMAP_TYPE_BASIC"; return 1 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF" : 2 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"), t }(n),
                    h = function(e) { var t = "ENVMAP_TYPE_CUBE"; if (e.envMap) switch (e.envMapMode) {
                            case 301:
                            case 302:
                                t = "ENVMAP_TYPE_CUBE"; break;
                            case 306:
                            case 307:
                                t = "ENVMAP_TYPE_CUBE_UV"; break;
                            case 303:
                            case 304:
                                t = "ENVMAP_TYPE_EQUIREC"; break;
                            case 305:
                                t = "ENVMAP_TYPE_SPHERE" }
                        return t }(n),
                    u = function(e) { var t = "ENVMAP_MODE_REFLECTION"; if (e.envMap) switch (e.envMapMode) {
                            case 302:
                            case 304:
                                t = "ENVMAP_MODE_REFRACTION" }
                        return t }(n),
                    p = function(e) { var t = "ENVMAP_BLENDING_NONE"; if (e.envMap) switch (e.combine) {
                            case 0:
                                t = "ENVMAP_BLENDING_MULTIPLY"; break;
                            case 1:
                                t = "ENVMAP_BLENDING_MIX"; break;
                            case 2:
                                t = "ENVMAP_BLENDING_ADD" }
                        return t }(n),
                    d = 0 < e.gammaFactor ? e.gammaFactor : 1,
                    f = n.isWebGL2 ? "" : [n.extensionDerivatives || n.envMapCubeUV || n.bumpMap || n.tangentSpaceNormalMap || n.clearcoatNormalMap || n.flatShading || "physical" === n.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (n.extensionFragDepth || n.logarithmicDepthBuffer) && n.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", n.extensionDrawBuffers && n.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(st).join("\n"),
                    m = function(e) { var t, n = []; for (t in e) { var i = e[t];!1 !== i && n.push("#define " + t + " " + i) } return n.join("\n") }(o),
                    g = a.createProgram(); return n.isRawShaderMaterial ? (0 < (o = [m].filter(st).join("\n")).length && (o += "\n"), 0 < (l = [f, m].filter(st).join("\n")).length && (l += "\n")) : (o = [dt(n), "#define SHADER_NAME " + n.shaderName, m, n.instancing ? "#define USE_INSTANCING" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", " attribute mat4 instanceMatrix;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(st).join("\n"), l = [f, dt(n), "#define SHADER_NAME " + n.shaderName, m, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + d, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + p : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? Ms.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? ot("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.outputEncoding || n.mapEncoding || n.matcapEncoding || n.envMapEncoding || n.emissiveMapEncoding || n.lightMapEncoding ? Ms.encodings_pars_fragment : "", n.mapEncoding ? rt("mapTexelToLinear", n.mapEncoding) : "", n.matcapEncoding ? rt("matcapTexelToLinear", n.matcapEncoding) : "", n.envMapEncoding ? rt("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMapEncoding ? rt("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMapEncoding ? rt("lightMapTexelToLinear", n.lightMapEncoding) : "", n.outputEncoding ? at("linearToOutputTexel", n.outputEncoding) : "", n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(st).join("\n")), s = lt(s = ct(s = s.replace(Bs, ht), n), n), c = lt(c = ct(c = c.replace(Bs, ht), n), n), s = s.replace(Us, pt).replace(zs, ut), c = c.replace(Us, pt).replace(zs, ut), n.isWebGL2 && !n.isRawShaderMaterial && (h = !1, u = /^\s*#version\s+300\s+es\s*\n/, n.isShaderMaterial && null !== s.match(u) && null !== c.match(u) && (h = !0, s = s.replace(u, ""), c = c.replace(u, "")), o = "#version 300 es\n\n#define attribute in\n#define varying out\n#define texture2D texture\n" + o, l = ["#version 300 es\n\n#define varying in", h ? "" : "out highp vec4 pc_fragColor;", h ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + l), c = l + c, s = tt(a, 35633, o + s), c = tt(a, 35632, c), a.attachShader(g, s), a.attachShader(g, c), void 0 !== n.index0AttributeName ? a.bindAttribLocation(g, 0, n.index0AttributeName) : !0 === n.morphTargets && a.bindAttribLocation(g, 0, "position"), a.linkProgram(g), e.debug.checkShaderErrors && (e = a.getProgramInfoLog(g).trim(), h = a.getShaderInfoLog(s).trim(), u = a.getShaderInfoLog(c).trim(), d = p = !0, !1 === a.getProgramParameter(g, 35714) ? (p = !1, f = it(a, s, "vertex"), m = it(a, c, "fragment"), console.error("THREE.WebGLProgram: shader error: ", a.getError(), "35715", a.getProgramParameter(g, 35715), "gl.getProgramInfoLog", e, f, m)) : "" !== e ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", e) : "" !== h && "" !== u || (d = !1), d && (this.diagnostics = { runnable: p, programLog: e, vertexShader: { log: h, prefix: o }, fragmentShader: { log: u, prefix: l } })), a.deleteShader(s), a.deleteShader(c), this.getUniforms = function() { return void 0 === i && (i = new et(a, g)), i }, this.getAttributes = function() { if (void 0 === r) { for (var e = {}, t = a.getProgramParameter(g, 35721), n = 0; n < t; n++) { var i = a.getActiveAttrib(g, n).name;
                            e[i] = a.getAttribLocation(g, i) } r = e } return r }, this.destroy = function() { a.deleteProgram(g), this.program = void 0 }, this.name = n.shaderName, this.id = Ns++, this.cacheKey = t, this.usedTimes = 1, this.program = g, this.vertexShader = s, this.fragmentShader = c, this }

            function mt(e, t, n) {
                function i(e) { if (e) e.isTexture ? t = e.encoding : e.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), t = e.texture.encoding);
                    else var t = 3e3; return t } var r = [],
                    a = n.isWebGL2,
                    o = n.logarithmicDepthBuffer,
                    s = n.floatVertexTextures,
                    c = n.precision,
                    l = n.maxVertexUniforms,
                    h = n.vertexTextures,
                    u = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" },
                    p = "precision isWebGL2 supportsVertexTextures outputEncoding instancing map mapEncoding matcap matcapEncoding envMap envMapMode envMapEncoding envMapCubeUV lightMap lightMapEncoding aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap tangentSpaceNormalMap clearcoatMap clearcoatRoughnessMap clearcoatNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors vertexTangents vertexUvs uvsVertexOnly fog useFog fogExp2 flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights numDirLightShadows numPointLightShadows numSpotLightShadows shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering sheen".split(" ");
                this.getParameters = function(r, p, d, f, m, g, v) { var y = f.fog;
                    f = r.isMeshStandardMaterial ? f.environment : null, f = r.envMap || f; var x = u[r.type]; if (v.isSkinnedMesh) { var _ = v.skeleton.bones; if (s) _ = 1024;
                        else { var b = Math.min(Math.floor((l - 20) / 4), _.length);
                            b < _.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + _.length + " bones. This GPU supports " + b + "."), _ = 0) : _ = b } } else _ = 0;
                    null !== r.precision && ((c = n.getMaxPrecision(r.precision)) !== r.precision && console.warn("THREE.WebGLProgram.getParameters:", r.precision, "not supported, using", c, "instead.")), x ? (b = Ss[x], b = { name: r.type, uniforms: xs.clone(b.uniforms), vertexShader: b.vertexShader, fragmentShader: b.fragmentShader }) : b = { name: r.type, uniforms: r.uniforms, vertexShader: r.vertexShader, fragmentShader: r.fragmentShader }, r.onBeforeCompile(b, e); var w = e.getRenderTarget(); return { isWebGL2: a, shaderID: x, shaderName: b.name, uniforms: b.uniforms, vertexShader: b.vertexShader, fragmentShader: b.fragmentShader, defines: r.defines, isRawShaderMaterial: r.isRawShaderMaterial, isShaderMaterial: r.isShaderMaterial, precision: c, instancing: !0 === v.isInstancedMesh, supportsVertexTextures: h, outputEncoding: null !== w ? i(w.texture) : e.outputEncoding, map: !!r.map, mapEncoding: i(r.map), matcap: !!r.matcap, matcapEncoding: i(r.matcap), envMap: !!f, envMapMode: f && f.mapping, envMapEncoding: i(f), envMapCubeUV: !!f && (306 === f.mapping || 307 === f.mapping), lightMap: !!r.lightMap, lightMapEncoding: i(r.lightMap), aoMap: !!r.aoMap, emissiveMap: !!r.emissiveMap, emissiveMapEncoding: i(r.emissiveMap), bumpMap: !!r.bumpMap, normalMap: !!r.normalMap, objectSpaceNormalMap: 1 === r.normalMapType, tangentSpaceNormalMap: 0 === r.normalMapType, clearcoatMap: !!r.clearcoatMap, clearcoatRoughnessMap: !!r.clearcoatRoughnessMap, clearcoatNormalMap: !!r.clearcoatNormalMap, displacementMap: !!r.displacementMap, roughnessMap: !!r.roughnessMap, metalnessMap: !!r.metalnessMap, specularMap: !!r.specularMap, alphaMap: !!r.alphaMap, gradientMap: !!r.gradientMap, sheen: !!r.sheen, combine: r.combine, vertexTangents: r.normalMap && r.vertexTangents, vertexColors: r.vertexColors, vertexUvs: !!(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatMap || r.clearcoatRoughnessMap || r.clearcoatNormalMap || r.displacementMap), uvsVertexOnly: !(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatNormalMap || !r.displacementMap), fog: !!y, useFog: r.fog, fogExp2: y && y.isFogExp2, flatShading: r.flatShading, sizeAttenuation: r.sizeAttenuation, logarithmicDepthBuffer: o, skinning: r.skinning && 0 < _, maxBones: _, useVertexTexture: s, morphTargets: r.morphTargets, morphNormals: r.morphNormals, maxMorphTargets: e.maxMorphTargets, maxMorphNormals: e.maxMorphNormals, numDirLights: p.directional.length, numPointLights: p.point.length, numSpotLights: p.spot.length, numRectAreaLights: p.rectArea.length, numHemiLights: p.hemi.length, numDirLightShadows: p.directionalShadowMap.length, numPointLightShadows: p.pointShadowMap.length, numSpotLightShadows: p.spotShadowMap.length, numClippingPlanes: m, numClipIntersection: g, dithering: r.dithering, shadowMapEnabled: e.shadowMap.enabled && 0 < d.length, shadowMapType: e.shadowMap.type, toneMapping: r.toneMapped ? e.toneMapping : 0, physicallyCorrectLights: e.physicallyCorrectLights, premultipliedAlpha: r.premultipliedAlpha, alphaTest: r.alphaTest, doubleSided: 2 === r.side, flipSided: 1 === r.side, depthPacking: void 0 !== r.depthPacking && r.depthPacking, index0AttributeName: r.index0AttributeName, extensionDerivatives: r.extensions && r.extensions.derivatives, extensionFragDepth: r.extensions && r.extensions.fragDepth, extensionDrawBuffers: r.extensions && r.extensions.drawBuffers, extensionShaderTextureLOD: r.extensions && r.extensions.shaderTextureLOD, rendererExtensionFragDepth: a || null !== t.get("EXT_frag_depth"), rendererExtensionDrawBuffers: a || null !== t.get("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: a || null !== t.get("EXT_shader_texture_lod"), onBeforeCompile: r.onBeforeCompile } }, this.getProgramCacheKey = function(t) { var n = []; if (t.shaderID ? n.push(t.shaderID) : (n.push(t.fragmentShader), n.push(t.vertexShader)), void 0 !== t.defines)
                        for (var i in t.defines) n.push(i), n.push(t.defines[i]); if (void 0 === t.isRawShaderMaterial) { for (i = 0; i < p.length; i++) n.push(t[p[i]]);
                        n.push(e.outputEncoding), n.push(e.gammaFactor) } return n.push(t.onBeforeCompile.toString()), n.join() }, this.acquireProgram = function(t, n) { for (var i, a = 0, o = r.length; a < o; a++) { var s = r[a]; if (s.cacheKey === n) {++(i = s).usedTimes; break } } return void 0 === i && (i = new ft(e, n, t), r.push(i)), i }, this.releaseProgram = function(e) { if (0 == --e.usedTimes) { var t = r.indexOf(e);
                        r[t] = r[r.length - 1], r.pop(), e.destroy() } }, this.programs = r }

            function gt() { var e = new WeakMap; return { get: function(t) { var n = e.get(t); return void 0 === n && (n = {}, e.set(t, n)), n }, remove: function(t) { e.delete(t) }, update: function(t, n, i) { e.get(t)[n] = i }, dispose: function() { e = new WeakMap } } }

            function vt(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id }

            function yt(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id }

            function xt() {
                function e(e, i, r, o, s, c) { var l = t[n]; return void 0 === l ? (l = { id: e.id, object: e, geometry: i, material: r, program: r.program || a, groupOrder: o, renderOrder: e.renderOrder, z: s, group: c }, t[n] = l) : (l.id = e.id, l.object = e, l.geometry = i, l.material = r, l.program = r.program || a, l.groupOrder = o, l.renderOrder = e.renderOrder, l.z = s, l.group = c), n++, l } var t = [],
                    n = 0,
                    i = [],
                    r = [],
                    a = { id: -1 }; return { opaque: i, transparent: r, init: function() { n = 0, i.length = 0, r.length = 0 }, push: function(t, n, a, o, s, c) { t = e(t, n, a, o, s, c), (!0 === a.transparent ? r : i).push(t) }, unshift: function(t, n, a, o, s, c) { t = e(t, n, a, o, s, c), (!0 === a.transparent ? r : i).unshift(t) }, finish: function() { for (var e = n, i = t.length; e < i; e++) { var r = t[e]; if (null === r.id) break;
                            r.id = null, r.object = null, r.geometry = null, r.material = null, r.program = null, r.group = null } }, sort: function(e, t) { 1 < i.length && i.sort(e || vt), 1 < r.length && r.sort(t || yt) } } }

            function _t() {
                function e(n) {
                    (n = n.target).removeEventListener("dispose", e), t.delete(n) } var t = new WeakMap; return { get: function(n, i) { var r = t.get(n); if (void 0 === r) { var a = new xt;
                            t.set(n, new WeakMap), t.get(n).set(i, a), n.addEventListener("dispose", e) } else void 0 === (a = r.get(i)) && (a = new xt, r.set(i, a)); return a }, dispose: function() { t = new WeakMap } } }

            function bt() { var e = {}; return { get: function(t) { if (void 0 !== e[t.id]) return e[t.id]; switch (t.type) {
                            case "DirectionalLight":
                                var n = { direction: new l, color: new b }; break;
                            case "SpotLight":
                                n = { position: new l, direction: new l, color: new b, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break;
                            case "PointLight":
                                n = { position: new l, color: new b, distance: 0, decay: 0 }; break;
                            case "HemisphereLight":
                                n = { direction: new l, skyColor: new b, groundColor: new b }; break;
                            case "RectAreaLight":
                                n = { color: new b, position: new l, halfWidth: new l, halfHeight: new l } } return e[t.id] = n } } }

            function wt(e, t) { return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0) }

            function Mt() { for (var e = new bt, t = function() { var e = {}; return { get: function(t) { if (void 0 !== e[t.id]) return e[t.id]; switch (t.type) {
                                    case "DirectionalLight":
                                        var i = { shadowBias: 0, shadowRadius: 1, shadowMapSize: new n }; break;
                                    case "SpotLight":
                                        i = { shadowBias: 0, shadowRadius: 1, shadowMapSize: new n }; break;
                                    case "PointLight":
                                        i = { shadowBias: 0, shadowRadius: 1, shadowMapSize: new n, shadowCameraNear: 1, shadowCameraFar: 1e3 } } return e[t.id] = i } } }(), i = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] }, r = 0; 9 > r; r++) i.probe.push(new l); var a = new l,
                    o = new h,
                    s = new h; return { setup: function(n, r, c) { for (var l = 0, h = 0, u = 0, p = 0; 9 > p; p++) i.probe[p].set(0, 0, 0); var d = r = 0,
                            f = 0,
                            m = 0,
                            g = 0,
                            v = 0,
                            y = 0,
                            x = 0;
                        c = c.matrixWorldInverse, n.sort(wt), p = 0; for (var _ = n.length; p < _; p++) { var b = n[p],
                                w = b.color,
                                M = b.intensity,
                                S = b.distance,
                                T = b.shadow && b.shadow.map ? b.shadow.map.texture : null; if (b.isAmbientLight) l += w.r * M, h += w.g * M, u += w.b * M;
                            else if (b.isLightProbe)
                                for (T = 0; 9 > T; T++) i.probe[T].addScaledVector(b.sh.coefficients[T], M);
                            else if (b.isDirectionalLight) { var E = e.get(b);
                                E.color.copy(b.color).multiplyScalar(b.intensity), E.direction.setFromMatrixPosition(b.matrixWorld), a.setFromMatrixPosition(b.target.matrixWorld), E.direction.sub(a), E.direction.transformDirection(c), b.castShadow && (M = b.shadow, (w = t.get(b)).shadowBias = M.bias, w.shadowRadius = M.radius, w.shadowMapSize = M.mapSize, i.directionalShadow[r] = w, i.directionalShadowMap[r] = T, i.directionalShadowMatrix[r] = b.shadow.matrix, v++), i.directional[r] = E, r++ } else b.isSpotLight ? ((E = e.get(b)).position.setFromMatrixPosition(b.matrixWorld), E.position.applyMatrix4(c), E.color.copy(w).multiplyScalar(M), E.distance = S, E.direction.setFromMatrixPosition(b.matrixWorld), a.setFromMatrixPosition(b.target.matrixWorld), E.direction.sub(a), E.direction.transformDirection(c), E.coneCos = Math.cos(b.angle), E.penumbraCos = Math.cos(b.angle * (1 - b.penumbra)), E.decay = b.decay, b.castShadow && (M = b.shadow, (w = t.get(b)).shadowBias = M.bias, w.shadowRadius = M.radius, w.shadowMapSize = M.mapSize, i.spotShadow[f] = w, i.spotShadowMap[f] = T, i.spotShadowMatrix[f] = b.shadow.matrix, x++), i.spot[f] = E, f++) : b.isRectAreaLight ? ((E = e.get(b)).color.copy(w).multiplyScalar(M), E.position.setFromMatrixPosition(b.matrixWorld), E.position.applyMatrix4(c), s.identity(), o.copy(b.matrixWorld), o.premultiply(c), s.extractRotation(o), E.halfWidth.set(.5 * b.width, 0, 0), E.halfHeight.set(0, .5 * b.height, 0), E.halfWidth.applyMatrix4(s), E.halfHeight.applyMatrix4(s), i.rectArea[m] = E, m++) : b.isPointLight ? ((E = e.get(b)).position.setFromMatrixPosition(b.matrixWorld), E.position.applyMatrix4(c), E.color.copy(b.color).multiplyScalar(b.intensity), E.distance = b.distance, E.decay = b.decay, b.castShadow && (M = b.shadow, (w = t.get(b)).shadowBias = M.bias, w.shadowRadius = M.radius, w.shadowMapSize = M.mapSize, w.shadowCameraNear = M.camera.near, w.shadowCameraFar = M.camera.far, i.pointShadow[d] = w, i.pointShadowMap[d] = T, i.pointShadowMatrix[d] = b.shadow.matrix, y++), i.point[d] = E, d++) : b.isHemisphereLight && ((E = e.get(b)).direction.setFromMatrixPosition(b.matrixWorld), E.direction.transformDirection(c), E.direction.normalize(), E.skyColor.copy(b.color).multiplyScalar(M), E.groundColor.copy(b.groundColor).multiplyScalar(M), i.hemi[g] = E, g++) } i.ambient[0] = l, i.ambient[1] = h, i.ambient[2] = u, (n = i.hash).directionalLength === r && n.pointLength === d && n.spotLength === f && n.rectAreaLength === m && n.hemiLength === g && n.numDirectionalShadows === v && n.numPointShadows === y && n.numSpotShadows === x || (i.directional.length = r, i.spot.length = f, i.rectArea.length = m, i.point.length = d, i.hemi.length = g, i.directionalShadow.length = v, i.directionalShadowMap.length = v, i.pointShadow.length = y, i.pointShadowMap.length = y, i.spotShadow.length = x, i.spotShadowMap.length = x, i.directionalShadowMatrix.length = v, i.pointShadowMatrix.length = y, i.spotShadowMatrix.length = x, n.directionalLength = r, n.pointLength = d, n.spotLength = f, n.rectAreaLength = m, n.hemiLength = g, n.numDirectionalShadows = v, n.numPointShadows = y, n.numSpotShadows = x, i.version = Fs++) }, state: i } }

            function St() { var e = new Mt,
                    t = [],
                    n = []; return { init: function() { t.length = 0, n.length = 0 }, state: { lightsArray: t, shadowsArray: n, lights: e }, setupLights: function(i) { e.setup(t, n, i) }, pushLight: function(e) { t.push(e) }, pushShadow: function(e) { n.push(e) } } }

            function Tt() {
                function e(n) {
                    (n = n.target).removeEventListener("dispose", e), t.delete(n) } var t = new WeakMap; return { get: function(n, i) { if (!1 === t.has(n)) { var r = new St;
                            t.set(n, new WeakMap), t.get(n).set(i, r), n.addEventListener("dispose", e) } else !1 === t.get(n).has(i) ? (r = new St, t.get(n).set(i, r)) : r = t.get(n).get(i); return r }, dispose: function() { t = new WeakMap } } }

            function Et(e) { E.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(e) }

            function At(e) { E.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new l, this.nearDistance = 1, this.farDistance = 1e3, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(e) }

            function Lt(e, t, i) {
                function r(e, t, n) { var i = f[n = e << 0 | t << 1 | n << 2]; return void 0 === i && (i = new Et({ depthPacking: 3201, morphTargets: e, skinning: t }), f[n] = i), i }

                function s(e, t, n) { var i = m[n = e << 0 | t << 1 | n << 2]; return void 0 === i && (i = new At({ morphTargets: e, skinning: t }), m[n] = i), i }

                function c(t, n, i, a, o, c, l) { var h = r,
                        u = t.customDepthMaterial; return !0 === a.isPointLight && (h = s, u = t.customDistanceMaterial), void 0 === u ? (u = !1, !0 === i.morphTargets && (u = n.morphAttributes && n.morphAttributes.position && 0 < n.morphAttributes.position.length), n = !1, !0 === t.isSkinnedMesh && (!0 === i.skinning ? n = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t)), t = h(u, n, !0 === t.isInstancedMesh)) : t = u, e.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length && (u = t.uuid, h = i.uuid, void 0 === (n = g[u]) && (n = {}, g[u] = n), void 0 === (u = n[h]) && (u = t.clone(), n[h] = u), t = u), t.visible = i.visible, t.wireframe = i.wireframe, t.side = 3 === l ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : v[i.side], t.clipShadows = i.clipShadows, t.clippingPlanes = i.clippingPlanes, t.clipIntersection = i.clipIntersection, t.wireframeLinewidth = i.wireframeLinewidth, t.linewidth = i.linewidth, !0 === a.isPointLight && !0 === t.isMeshDistanceMaterial && (t.referencePosition.setFromMatrixPosition(a.matrixWorld), t.nearDistance = o, t.farDistance = c), t }

                function l(n, i, r, a, o) { if (!1 !== n.visible) { if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === o) && (!n.frustumCulled || h.intersectsObject(n))) { n.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, n.matrixWorld); var s = t.update(n),
                                u = n.material; if (Array.isArray(u))
                                for (var p = s.groups, d = 0, f = p.length; d < f; d++) { var m = p[d],
                                        g = u[m.materialIndex];
                                    g && g.visible && (g = c(n, s, g, a, r.near, r.far, o), e.renderBufferDirect(r, null, s, g, n, m)) } else u.visible && (g = c(n, s, u, a, r.near, r.far, o), e.renderBufferDirect(r, null, s, g, n, null)) } for (s = 0, u = (n = n.children).length; s < u; s++) l(n[s], i, r, a, o) } } var h = new $,
                    u = new n,
                    p = new n,
                    d = new a,
                    f = [],
                    m = [],
                    g = {},
                    v = { 0: 1, 1: 0, 2: 2 },
                    y = new X({ defines: { SAMPLE_RATE: .25, HALF_SAMPLE_RATE: .125 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new n }, radius: { value: 4 } }, vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }),
                    x = y.clone();
                x.defines.HORIZONAL_PASS = 1; var _ = new G;
                _.setAttribute("position", new L(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); var b = new H(_, y),
                    w = this;
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(n, r, a) { if (!1 !== w.enabled && (!1 !== w.autoUpdate || !1 !== w.needsUpdate) && 0 !== n.length) { var s = e.getRenderTarget(),
                            c = e.getActiveCubeFace(),
                            f = e.getActiveMipmapLevel(),
                            m = e.state;
                        m.setBlending(0), m.buffers.color.setClear(1, 1, 1, 1), m.buffers.depth.setTest(!0), m.setScissorTest(!1); for (var g = 0, v = n.length; g < v; g++) { var _ = n[g],
                                M = _.shadow; if (void 0 === M) console.warn("THREE.WebGLShadowMap:", _, "has no shadow.");
                            else { u.copy(M.mapSize); var S = M.getFrameExtents();
                                u.multiply(S), p.copy(M.mapSize), (u.x > i || u.y > i) && (u.x > i && (p.x = Math.floor(i / S.x), u.x = p.x * S.x, M.mapSize.x = p.x), u.y > i && (p.y = Math.floor(i / S.y), u.y = p.y * S.y, M.mapSize.y = p.y)), null !== M.map || M.isPointLightShadow || 3 !== this.type || (S = { minFilter: 1006, magFilter: 1006, format: 1023 }, M.map = new o(u.x, u.y, S), M.map.texture.name = _.name + ".shadowMap", M.mapPass = new o(u.x, u.y, S), M.camera.updateProjectionMatrix()), null === M.map && (S = { minFilter: 1003, magFilter: 1003, format: 1023 }, M.map = new o(u.x, u.y, S), M.map.texture.name = _.name + ".shadowMap", M.camera.updateProjectionMatrix()), e.setRenderTarget(M.map), e.clear(), S = M.getViewportCount(); for (var T = 0; T < S; T++) { var E = M.getViewport(T);
                                    d.set(p.x * E.x, p.y * E.y, p.x * E.z, p.y * E.w), m.viewport(d), M.updateMatrices(_, T), h = M.getFrustum(), l(r, a, M.camera, _, this.type) } M.isPointLightShadow || 3 !== this.type || (_ = M, M = a, S = t.update(b), y.uniforms.shadow_pass.value = _.map.texture, y.uniforms.resolution.value = _.mapSize, y.uniforms.radius.value = _.radius, e.setRenderTarget(_.mapPass), e.clear(), e.renderBufferDirect(M, null, S, y, b, null), x.uniforms.shadow_pass.value = _.mapPass.texture, x.uniforms.resolution.value = _.mapSize, x.uniforms.radius.value = _.radius, e.setRenderTarget(_.map), e.clear(), e.renderBufferDirect(M, null, S, x, b, null)) } } w.needsUpdate = !1, e.setRenderTarget(s, c, f) } } }

            function Rt(e, t, n) {
                function i(t, n, i) { var r = new Uint8Array(4),
                        a = e.createTexture(); for (e.bindTexture(t, a), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728), t = 0; t < i; t++) e.texImage2D(n + t, 0, 6408, 1, 1, 0, 6408, 5121, r); return a }

                function r(n, i) { v[n] = 1, 0 === y[n] && (e.enableVertexAttribArray(n), y[n] = 1), x[n] !== i && ((d ? e : t.get("ANGLE_instanced_arrays"))[d ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i), x[n] = i) }

                function o(t) {!0 !== _[t] && (e.enable(t), _[t] = !0) }

                function s(t) {!1 !== _[t] && (e.disable(t), _[t] = !1) }

                function c(t, n, i, r, a, c, l, h) { if (0 === t) w && (s(3042), w = !1);
                    else if (w || (o(3042), w = !0), 5 !== t) { if (t !== M || h !== P) { if (100 === S && 100 === A || (e.blendEquation(32774), A = S = 100), h) switch (t) {
                                case 1:
                                    e.blendFuncSeparate(1, 771, 1, 771); break;
                                case 2:
                                    e.blendFunc(1, 1); break;
                                case 3:
                                    e.blendFuncSeparate(0, 0, 769, 771); break;
                                case 4:
                                    e.blendFuncSeparate(0, 768, 0, 770); break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", t) } else switch (t) {
                                case 1:
                                    e.blendFuncSeparate(770, 771, 1, 771); break;
                                case 2:
                                    e.blendFunc(770, 1); break;
                                case 3:
                                    e.blendFunc(0, 769); break;
                                case 4:
                                    e.blendFunc(0, 768); break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", t) } R = L = E = T = null, M = t, P = h } } else a = a || n, c = c || i, l = l || r, n === S && a === A || (e.blendEquationSeparate(V[n], V[a]), S = n, A = a), i === T && r === E && c === L && l === R || (e.blendFuncSeparate(j[i], j[r], j[c], j[l]), T = i, E = r, L = c, R = l), M = t, P = null }

                function l(t) { C !== t && (t ? e.frontFace(2304) : e.frontFace(2305), C = t) }

                function h(t) { 0 !== t ? (o(2884), t !== O && (1 === t ? e.cullFace(1029) : 2 === t ? e.cullFace(1028) : e.cullFace(1032))) : s(2884), O = t }

                function u(t, n, i) { t ? (o(32823), (I !== n || N !== i) && (e.polygonOffset(n, i), I = n, N = i)) : s(32823) }

                function p(t) { void 0 === t && (t = 33984 + B - 1), U !== t && (e.activeTexture(t), U = t) } var d = n.isWebGL2,
                    f = new function() { var t = !1,
                            n = new a,
                            i = null,
                            r = new a(0, 0, 0, 0); return { setMask: function(n) { i === n || t || (e.colorMask(n, n, n, n), i = n) }, setLocked: function(e) { t = e }, setClear: function(t, i, a, o, s) {!0 === s && (t *= o, i *= o, a *= o), n.set(t, i, a, o), !1 === r.equals(n) && (e.clearColor(t, i, a, o), r.copy(n)) }, reset: function() { t = !1, i = null, r.set(-1, 0, 0, 0) } } },
                    m = new function() { var t = !1,
                            n = null,
                            i = null,
                            r = null; return { setTest: function(e) { e ? o(2929) : s(2929) }, setMask: function(i) { n === i || t || (e.depthMask(i), n = i) }, setFunc: function(t) { if (i !== t) { if (t) switch (t) {
                                        case 0:
                                            e.depthFunc(512); break;
                                        case 1:
                                            e.depthFunc(519); break;
                                        case 2:
                                            e.depthFunc(513); break;
                                        case 3:
                                            e.depthFunc(515); break;
                                        case 4:
                                            e.depthFunc(514); break;
                                        case 5:
                                            e.depthFunc(518); break;
                                        case 6:
                                            e.depthFunc(516); break;
                                        case 7:
                                            e.depthFunc(517); break;
                                        default:
                                            e.depthFunc(515) } else e.depthFunc(515);
                                    i = t } }, setLocked: function(e) { t = e }, setClear: function(t) { r !== t && (e.clearDepth(t), r = t) }, reset: function() { t = !1, r = i = n = null } } },
                    g = new function() { var t = !1,
                            n = null,
                            i = null,
                            r = null,
                            a = null,
                            c = null,
                            l = null,
                            h = null,
                            u = null; return { setTest: function(e) { t || (e ? o(2960) : s(2960)) }, setMask: function(i) { n === i || t || (e.stencilMask(i), n = i) }, setFunc: function(t, n, o) { i === t && r === n && a === o || (e.stencilFunc(t, n, o), i = t, r = n, a = o) }, setOp: function(t, n, i) { c === t && l === n && h === i || (e.stencilOp(t, n, i), c = t, l = n, h = i) }, setLocked: function(e) { t = e }, setClear: function(t) { u !== t && (e.clearStencil(t), u = t) }, reset: function() { t = !1, u = h = l = c = a = r = i = n = null } } };
                n = e.getParameter(34921); var v = new Uint8Array(n),
                    y = new Uint8Array(n),
                    x = new Uint8Array(n),
                    _ = {},
                    b = null,
                    w = null,
                    M = null,
                    S = null,
                    T = null,
                    E = null,
                    A = null,
                    L = null,
                    R = null,
                    P = !1,
                    C = null,
                    O = null,
                    D = null,
                    I = null,
                    N = null,
                    B = e.getParameter(35661),
                    z = !1;
                n = 0, -1 !== (n = e.getParameter(7938)).indexOf("WebGL") ? (n = parseFloat(/^WebGL ([0-9])/.exec(n)[1]), z = 1 <= n) : -1 !== n.indexOf("OpenGL ES") && (n = parseFloat(/^OpenGL ES ([0-9])/.exec(n)[1]), z = 2 <= n); var U = null,
                    F = {},
                    G = new a,
                    H = new a,
                    k = {};
                k[3553] = i(3553, 3553, 1), k[34067] = i(34067, 34069, 6), f.setClear(0, 0, 0, 1), m.setClear(1), g.setClear(0), o(2929), m.setFunc(3), l(!1), h(1), o(2884), c(0); var V = { 100: 32774, 101: 32778, 102: 32779 };
                d ? (V[103] = 32775, V[104] = 32776) : null !== (n = t.get("EXT_blend_minmax")) && (V[103] = n.MIN_EXT, V[104] = n.MAX_EXT); var j = { 200: 0, 201: 1, 202: 768, 204: 770, 210: 776, 208: 774, 206: 772, 203: 769, 205: 771, 209: 775, 207: 773 }; return { buffers: { color: f, depth: m, stencil: g }, initAttributes: function() { for (var e = 0, t = v.length; e < t; e++) v[e] = 0 }, enableAttribute: function(e) { r(e, 0) }, enableAttributeAndDivisor: r, disableUnusedAttributes: function() { for (var t = 0, n = y.length; t !== n; ++t) y[t] !== v[t] && (e.disableVertexAttribArray(t), y[t] = 0) }, vertexAttribPointer: function(t, n, i, r, a, o) {!0 !== d || 5124 !== i && 5125 !== i ? e.vertexAttribPointer(t, n, i, r, a, o) : e.vertexAttribIPointer(t, n, i, r, a, o) }, enable: o, disable: s, useProgram: function(t) { return b !== t && (e.useProgram(t), b = t, !0) }, setBlending: c, setMaterial: function(e, t) { 2 === e.side ? s(2884) : o(2884); var n = 1 === e.side;
                        t && (n = !n), l(n), 1 === e.blending && !1 === e.transparent ? c(0) : c(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), m.setFunc(e.depthFunc), m.setTest(e.depthTest), m.setMask(e.depthWrite), f.setMask(e.colorWrite), t = e.stencilWrite, g.setTest(t), t && (g.setMask(e.stencilWriteMask), g.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), g.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), u(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits) }, setFlipSided: l, setCullFace: h, setLineWidth: function(t) { t !== D && (z && e.lineWidth(t), D = t) }, setPolygonOffset: u, setScissorTest: function(e) { e ? o(3089) : s(3089) }, activeTexture: p, bindTexture: function(t, n) { null === U && p(); var i = F[U];
                        void 0 === i && (i = { type: void 0, texture: void 0 }, F[U] = i), i.type === t && i.texture === n || (e.bindTexture(t, n || k[t]), i.type = t, i.texture = n) }, unbindTexture: function() { var t = F[U];
                        void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0) }, compressedTexImage2D: function() { try { e.compressedTexImage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage2D: function() { try { e.texImage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage3D: function() { try { e.texImage3D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, scissor: function(t) {!1 === G.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), G.copy(t)) }, viewport: function(t) {!1 === H.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), H.copy(t)) }, reset: function() { for (var t = 0; t < y.length; t++) 1 === y[t] && (e.disableVertexAttribArray(t), y[t] = 0);
                        _ = {}, U = null, F = {}, O = C = M = b = null, f.reset(), m.reset(), g.reset() } } }

            function Pt(e, t, n, i, r, a, o) {
                function s(e, t) { return O ? new OffscreenCanvas(e, t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") }

                function c(e, t, n, i) { var r = 1; if ((e.width > i || e.height > i) && (r = i / Math.max(e.width, e.height)), 1 > r || !0 === t) { if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) return t = (i = t ? Ra.floorPowerOfTwo : Math.floor)(r * e.width), r = i(r * e.height), void 0 === T && (T = s(t, r)), (n = n ? s(t, r) : T).width = t, n.height = r, n.getContext("2d").drawImage(e, 0, 0, t, r), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + t + "x" + r + ")."), n; "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ").") } return e }

                function l(e) { return Ra.isPowerOfTwo(e.width) && Ra.isPowerOfTwo(e.height) }

                function h(e, t) { return e.generateMipmaps && t && 1003 !== e.minFilter && 1006 !== e.minFilter }

                function u(t, n, r, a) { e.generateMipmap(t), i.get(n).__maxMipLevel = Math.log(Math.max(r, a)) * Math.LOG2E }

                function p(n, i, r) { if (!1 === E) return i; if (null !== n) { if (void 0 !== e[n]) return e[n];
                        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'") } return n = i, 6403 === i && (5126 === r && (n = 33326), 5131 === r && (n = 33325), 5121 === r && (n = 33321)), 6407 === i && (5126 === r && (n = 34837), 5131 === r && (n = 34843), 5121 === r && (n = 32849)), 6408 === i && (5126 === r && (n = 34836), 5131 === r && (n = 34842), 5121 === r && (n = 32856)), 33325 !== n && 33326 !== n && 34842 !== n && 34836 !== n || t.get("EXT_color_buffer_float"), n }

                function d(e) { return 1003 === e || 1004 === e || 1005 === e ? 9728 : 9729 }

                function f(t) {
                    (t = t.target).removeEventListener("dispose", f); var n = i.get(t);
                    void 0 !== n.__webglInit && (e.deleteTexture(n.__webglTexture), i.remove(t)), t.isVideoTexture && C.delete(t), o.memory.textures-- }

                function m(t) {
                    (t = t.target).removeEventListener("dispose", m); var n = i.get(t),
                        r = i.get(t.texture); if (t) { if (void 0 !== r.__webglTexture && e.deleteTexture(r.__webglTexture), t.depthTexture && t.depthTexture.dispose(), t.isWebGLCubeRenderTarget)
                            for (r = 0; 6 > r; r++) e.deleteFramebuffer(n.__webglFramebuffer[r]), n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[r]);
                        else e.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && e.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer && e.deleteRenderbuffer(n.__webglColorRenderbuffer), n.__webglDepthRenderbuffer && e.deleteRenderbuffer(n.__webglDepthRenderbuffer);
                        i.remove(t.texture), i.remove(t) } o.memory.textures-- }

                function g(e, t) { var r = i.get(e); if (e.isVideoTexture) { var a = o.render.frame;
                        C.get(e) !== a && (C.set(e, a), e.update()) } if (0 < e.version && r.__version !== e.version)
                        if (void 0 === (a = e.image)) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                        else { if (!1 !== a.complete) return void b(r, e, t);
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete") } n.activeTexture(33984 + t), n.bindTexture(3553, r.__webglTexture) }

                function v(t, r) { if (6 === t.image.length) { var o = i.get(t); if (0 < t.version && o.__version !== t.version) { _(o, t), n.activeTexture(33984 + r), n.bindTexture(34067, o.__webglTexture), e.pixelStorei(37440, t.flipY); var s = t && (t.isCompressedTexture || t.image[0].isCompressedTexture);
                            r = t.image[0] && t.image[0].isDataTexture; for (var d = [], f = 0; 6 > f; f++) d[f] = s || r ? r ? t.image[f].image : t.image[f] : c(t.image[f], !1, !0, L); var m = d[0],
                                g = l(m) || E,
                                v = a.convert(t.format),
                                y = a.convert(t.type),
                                b = p(t.internalFormat, v, y); if (x(34067, t, g), s) { for (f = 0; 6 > f; f++) { var w = d[f].mipmaps; for (s = 0; s < w.length; s++) { var M = w[s];
                                        1023 !== t.format && 1022 !== t.format ? null !== v ? n.compressedTexImage2D(34069 + f, s, b, M.width, M.height, 0, M.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + f, s, b, M.width, M.height, 0, v, y, M.data) } } o.__maxMipLevel = w.length - 1 } else { for (w = t.mipmaps, f = 0; 6 > f; f++)
                                    if (r)
                                        for (n.texImage2D(34069 + f, 0, b, d[f].width, d[f].height, 0, v, y, d[f].data), s = 0; s < w.length; s++) M = (M = w[s]).image[f].image, n.texImage2D(34069 + f, s + 1, b, M.width, M.height, 0, v, y, M.data);
                                    else
                                        for (n.texImage2D(34069 + f, 0, b, v, y, d[f]), s = 0; s < w.length; s++) M = w[s], n.texImage2D(34069 + f, s + 1, b, v, y, M.image[f]);
                                o.__maxMipLevel = w.length } h(t, g) && u(34067, t, m.width, m.height), o.__version = t.version, t.onUpdate && t.onUpdate(t) } else n.activeTexture(33984 + r), n.bindTexture(34067, o.__webglTexture) } }

                function y(e, t) { n.activeTexture(33984 + t), n.bindTexture(34067, i.get(e).__webglTexture) }

                function x(n, a, o) { o ? (e.texParameteri(n, 10242, I[a.wrapS]), e.texParameteri(n, 10243, I[a.wrapT]), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, I[a.wrapR]), e.texParameteri(n, 10240, N[a.magFilter]), e.texParameteri(n, 10241, N[a.minFilter])) : (e.texParameteri(n, 10242, 33071), e.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, 33071), 1001 === a.wrapS && 1001 === a.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(n, 10240, d(a.magFilter)), e.texParameteri(n, 10241, d(a.minFilter)), 1003 !== a.minFilter && 1006 !== a.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !(o = t.get("EXT_texture_filter_anisotropic")) || 1015 === a.type && null === t.get("OES_texture_float_linear") || 1016 === a.type && null === (E || t.get("OES_texture_half_float_linear")) || !(1 < a.anisotropy || i.get(a).__currentAnisotropy) || (e.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())), i.get(a).__currentAnisotropy = a.anisotropy) }

                function _(t, n) { void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", f), t.__webglTexture = e.createTexture(), o.memory.textures++) }

                function b(t, i, r) { var o = 3553;
                    i.isDataTexture2DArray && (o = 35866), i.isDataTexture3D && (o = 32879), _(t, i), n.activeTexture(33984 + r), n.bindTexture(o, t.__webglTexture), e.pixelStorei(37440, i.flipY), e.pixelStorei(37441, i.premultiplyAlpha), e.pixelStorei(3317, i.unpackAlignment), r = (r = !E && (1001 !== i.wrapS || 1001 !== i.wrapT || 1003 !== i.minFilter && 1006 !== i.minFilter)) && !1 === l(i.image); var s = l(r = c(i.image, r, !1, R)) || E,
                        d = a.convert(i.format),
                        f = a.convert(i.type),
                        m = p(i.internalFormat, d, f);
                    x(o, i, s); var g = i.mipmaps; if (i.isDepthTexture) m = 6402, E ? m = 1015 === i.type ? 36012 : 1014 === i.type ? 33190 : 1020 === i.type ? 35056 : 33189 : 1015 === i.type && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), 1026 === i.format && 6402 === m && 1012 !== i.type && 1014 !== i.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = 1012, f = a.convert(i.type)), 1027 === i.format && 6402 === m && (m = 34041, 1020 !== i.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = 1020, f = a.convert(i.type))), n.texImage2D(3553, 0, m, r.width, r.height, 0, d, f, null);
                    else if (i.isDataTexture)
                        if (0 < g.length && s) { for (var v = 0, y = g.length; v < y; v++) { var b = g[v];
                                n.texImage2D(3553, v, m, b.width, b.height, 0, d, f, b.data) } i.generateMipmaps = !1, t.__maxMipLevel = g.length - 1 } else n.texImage2D(3553, 0, m, r.width, r.height, 0, d, f, r.data), t.__maxMipLevel = 0;
                    else if (i.isCompressedTexture) { for (v = 0, y = g.length; v < y; v++) b = g[v], 1023 !== i.format && 1022 !== i.format ? null !== d ? n.compressedTexImage2D(3553, v, m, b.width, b.height, 0, b.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, v, m, b.width, b.height, 0, d, f, b.data);
                        t.__maxMipLevel = g.length - 1 } else if (i.isDataTexture2DArray) n.texImage3D(35866, 0, m, r.width, r.height, r.depth, 0, d, f, r.data), t.__maxMipLevel = 0;
                    else if (i.isDataTexture3D) n.texImage3D(32879, 0, m, r.width, r.height, r.depth, 0, d, f, r.data), t.__maxMipLevel = 0;
                    else if (0 < g.length && s) { for (v = 0, y = g.length; v < y; v++) b = g[v], n.texImage2D(3553, v, m, d, f, b);
                        i.generateMipmaps = !1, t.__maxMipLevel = g.length - 1 } else n.texImage2D(3553, 0, m, d, f, r), t.__maxMipLevel = 0;
                    h(i, s) && u(o, i, r.width, r.height), t.__version = i.version, i.onUpdate && i.onUpdate(i) }

                function w(t, r, o, s) { var c = a.convert(r.texture.format),
                        l = a.convert(r.texture.type),
                        h = p(r.texture.internalFormat, c, l);
                    n.texImage2D(s, 0, h, r.width, r.height, 0, c, l, null), e.bindFramebuffer(36160, t), e.framebufferTexture2D(36160, o, s, i.get(r.texture).__webglTexture, 0), e.bindFramebuffer(36160, null) }

                function M(t, n, i) { if (e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer) { var r = 33189;
                        i ? ((i = n.depthTexture) && i.isDepthTexture && (1015 === i.type ? r = 36012 : 1014 === i.type && (r = 33190)), i = S(n), e.renderbufferStorageMultisample(36161, i, r, n.width, n.height)) : e.renderbufferStorage(36161, r, n.width, n.height), e.framebufferRenderbuffer(36160, 36096, 36161, t) } else n.depthBuffer && n.stencilBuffer ? (i ? (i = S(n), e.renderbufferStorageMultisample(36161, i, 35056, n.width, n.height)) : e.renderbufferStorage(36161, 34041, n.width, n.height), e.framebufferRenderbuffer(36160, 33306, 36161, t)) : (t = a.convert(n.texture.format), r = a.convert(n.texture.type), r = p(n.texture.internalFormat, t, r), i ? (i = S(n), e.renderbufferStorageMultisample(36161, i, r, n.width, n.height)) : e.renderbufferStorage(36161, r, n.width, n.height));
                    e.bindRenderbuffer(36161, null) }

                function S(e) { return E && e.isWebGLMultisampleRenderTarget ? Math.min(P, e.samples) : 0 } var T, E = r.isWebGL2,
                    A = r.maxTextures,
                    L = r.maxCubemapSize,
                    R = r.maxTextureSize,
                    P = r.maxSamples,
                    C = new WeakMap,
                    O = !1; try { O = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d") } catch (e) {} var D = 0,
                    I = { 1000: 10497, 1001: 33071, 1002: 33648 },
                    N = { 1003: 9728, 1004: 9984, 1005: 9986, 1006: 9729, 1007: 9985, 1008: 9987 },
                    B = !1,
                    z = !1;
                this.allocateTextureUnit = function() { var e = D; return e >= A && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + A), D += 1, e }, this.resetTextureUnits = function() { D = 0 }, this.setTexture2D = g, this.setTexture2DArray = function(e, t) { var r = i.get(e);
                    0 < e.version && r.__version !== e.version ? b(r, e, t) : (n.activeTexture(33984 + t), n.bindTexture(35866, r.__webglTexture)) }, this.setTexture3D = function(e, t) { var r = i.get(e);
                    0 < e.version && r.__version !== e.version ? b(r, e, t) : (n.activeTexture(33984 + t), n.bindTexture(32879, r.__webglTexture)) }, this.setTextureCube = v, this.setTextureCubeDynamic = y, this.setupRenderTarget = function(t) { var r = i.get(t),
                        s = i.get(t.texture);
                    t.addEventListener("dispose", m), s.__webglTexture = e.createTexture(), o.memory.textures++; var c = !0 === t.isWebGLCubeRenderTarget,
                        d = !0 === t.isWebGLMultisampleRenderTarget,
                        f = l(t) || E; if (!E || 1022 !== t.texture.format || 1015 !== t.texture.type && 1016 !== t.texture.type || (t.texture.format = 1023, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), c)
                        for (r.__webglFramebuffer = [], d = 0; 6 > d; d++) r.__webglFramebuffer[d] = e.createFramebuffer();
                    else if (r.__webglFramebuffer = e.createFramebuffer(), d)
                        if (E) { r.__webglMultisampledFramebuffer = e.createFramebuffer(), r.__webglColorRenderbuffer = e.createRenderbuffer(), e.bindRenderbuffer(36161, r.__webglColorRenderbuffer), d = a.convert(t.texture.format); var v = a.convert(t.texture.type);
                            d = p(t.texture.internalFormat, d, v), v = S(t), e.renderbufferStorageMultisample(36161, v, d, t.width, t.height), e.bindFramebuffer(36160, r.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064, 36161, r.__webglColorRenderbuffer), e.bindRenderbuffer(36161, null), t.depthBuffer && (r.__webglDepthRenderbuffer = e.createRenderbuffer(), M(r.__webglDepthRenderbuffer, t, !0)), e.bindFramebuffer(36160, null) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."); if (c) { for (n.bindTexture(34067, s.__webglTexture), x(34067, t.texture, f), d = 0; 6 > d; d++) w(r.__webglFramebuffer[d], t, 36064, 34069 + d);
                        h(t.texture, f) && u(34067, t.texture, t.width, t.height), n.bindTexture(34067, null) } else n.bindTexture(3553, s.__webglTexture), x(3553, t.texture, f), w(r.__webglFramebuffer, t, 36064, 3553), h(t.texture, f) && u(3553, t.texture, t.width, t.height), n.bindTexture(3553, null); if (t.depthBuffer) { if (r = i.get(t), s = !0 === t.isWebGLCubeRenderTarget, t.depthTexture) { if (s) throw Error("target.depthTexture not supported in Cube render targets"); if (t && t.isWebGLCubeRenderTarget) throw Error("Depth Texture with cube render targets is not supported"); if (e.bindFramebuffer(36160, r.__webglFramebuffer), !t.depthTexture || !t.depthTexture.isDepthTexture) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); if (i.get(t.depthTexture).__webglTexture && t.depthTexture.image.width === t.width && t.depthTexture.image.height === t.height || (t.depthTexture.image.width = t.width, t.depthTexture.image.height = t.height, t.depthTexture.needsUpdate = !0), g(t.depthTexture, 0), r = i.get(t.depthTexture).__webglTexture, 1026 === t.depthTexture.format) e.framebufferTexture2D(36160, 36096, 3553, r, 0);
                            else { if (1027 !== t.depthTexture.format) throw Error("Unknown depthTexture format");
                                e.framebufferTexture2D(36160, 33306, 3553, r, 0) } } else if (s)
                            for (r.__webglDepthbuffer = [], s = 0; 6 > s; s++) e.bindFramebuffer(36160, r.__webglFramebuffer[s]), r.__webglDepthbuffer[s] = e.createRenderbuffer(), M(r.__webglDepthbuffer[s], t, !1);
                        else e.bindFramebuffer(36160, r.__webglFramebuffer), r.__webglDepthbuffer = e.createRenderbuffer(), M(r.__webglDepthbuffer, t, !1);
                        e.bindFramebuffer(36160, null) } }, this.updateRenderTargetMipmap = function(e) { var t = e.texture,
                        r = l(e) || E; if (h(t, r)) { r = e.isWebGLCubeRenderTarget ? 34067 : 3553; var a = i.get(t).__webglTexture;
                        n.bindTexture(r, a), u(r, t, e.width, e.height), n.bindTexture(r, null) } }, this.updateMultisampleRenderTarget = function(t) { if (t.isWebGLMultisampleRenderTarget)
                        if (E) { var n = i.get(t);
                            e.bindFramebuffer(36008, n.__webglMultisampledFramebuffer), e.bindFramebuffer(36009, n.__webglFramebuffer); var r = t.width,
                                a = t.height,
                                o = 16384;
                            t.depthBuffer && (o |= 256), t.stencilBuffer && (o |= 1024), e.blitFramebuffer(0, 0, r, a, 0, 0, r, a, o, 9728), e.bindFramebuffer(36160, n.__webglMultisampledFramebuffer) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.") }, this.safeSetTexture2D = function(e, t) { e && e.isWebGLRenderTarget && (!1 === B && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), B = !0), e = e.texture), g(e, t) }, this.safeSetTextureCube = function(e, t) { e && e.isWebGLCubeRenderTarget && (!1 === z && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), z = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? v(e, t) : y(e, t) } }

            function Ct(e, t, n) { var i = n.isWebGL2; return { convert: function(e) { if (1009 === e) return 5121; if (1017 === e) return 32819; if (1018 === e) return 32820; if (1019 === e) return 33635; if (1010 === e) return 5120; if (1011 === e) return 5122; if (1012 === e) return 5123; if (1013 === e) return 5124; if (1014 === e) return 5125; if (1015 === e) return 5126; if (1016 === e) { if (i) return 5131; var n = t.get("OES_texture_half_float"); return null !== n ? n.HALF_FLOAT_OES : null } if (1021 === e) return 6406; if (1022 === e) return 6407; if (1023 === e) return 6408; if (1024 === e) return 6409; if (1025 === e) return 6410; if (1026 === e) return 6402; if (1027 === e) return 34041; if (1028 === e) return 6403; if (1029 === e) return 36244; if (1030 === e) return 33319; if (1031 === e) return 33320; if (1032 === e) return 36248; if (1033 === e) return 36249; if (33776 === e || 33777 === e || 33778 === e || 33779 === e) { if (null === (n = t.get("WEBGL_compressed_texture_s3tc"))) return null; if (33776 === e) return n.COMPRESSED_RGB_S3TC_DXT1_EXT; if (33777 === e) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (33778 === e) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (33779 === e) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (35840 === e || 35841 === e || 35842 === e || 35843 === e) { if (null === (n = t.get("WEBGL_compressed_texture_pvrtc"))) return null; if (35840 === e) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (35841 === e) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (35842 === e) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (35843 === e) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (36196 === e) return null !== (n = t.get("WEBGL_compressed_texture_etc1")) ? n.COMPRESSED_RGB_ETC1_WEBGL : null; if ((37492 === e || 37496 === e) && null !== (n = t.get("WEBGL_compressed_texture_etc"))) { if (37492 === e) return n.COMPRESSED_RGB8_ETC2; if (37496 === e) return n.COMPRESSED_RGBA8_ETC2_EAC } return 37808 === e || 37809 === e || 37810 === e || 37811 === e || 37812 === e || 37813 === e || 37814 === e || 37815 === e || 37816 === e || 37817 === e || 37818 === e || 37819 === e || 37820 === e || 37821 === e || 37840 === e || 37841 === e || 37842 === e || 37843 === e || 37844 === e || 37845 === e || 37846 === e || 37847 === e || 37848 === e || 37849 === e || 37850 === e || 37851 === e || 37852 === e || 37853 === e ? null !== (n = t.get("WEBGL_compressed_texture_astc")) ? e : null : 36492 === e ? null !== (n = t.get("EXT_texture_compression_bptc")) ? e : null : 1020 === e ? i ? 34042 : null !== (n = t.get("WEBGL_depth_texture")) ? n.UNSIGNED_INT_24_8_WEBGL : null : void 0 } } }

            function Ot(e) { Z.call(this), this.cameras = e || [] }

            function Dt() { d.call(this), this.type = "Group" }

            function It() { this._grip = this._targetRay = null }

            function Nt(e, t) {
                function n(e) { var t = g.get(e.inputSource);
                    t && t.dispatchEvent({ type: e.type }) }

                function i() { g.forEach(function(e, t) { e.disconnect(t) }), g.clear(), e.setFramebuffer(null), e.setRenderTarget(e.getRenderTarget()), E.stop(), c.isPresenting = !1, c.dispatchEvent({ type: "sessionend" }) }

                function r(e) { p = e, E.setContext(h), E.start(), c.isPresenting = !0, c.dispatchEvent({ type: "sessionstart" }) }

                function o(e) { for (var t = h.inputSources, n = 0; n < m.length; n++) g.set(t[n], m[n]); for (n = 0; n < e.removed.length; n++) { t = e.removed[n]; var i = g.get(t);
                        i && (i.dispatchEvent({ type: "disconnected", data: t }), g.delete(t)) } for (n = 0; n < e.added.length; n++) t = e.added[n], (i = g.get(t)) && i.dispatchEvent({ type: "connected", data: t }) }

                function s(e, t) { null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.getInverse(e.matrixWorld) } var c = this,
                    h = null,
                    u = 1,
                    p = null,
                    d = "local-floor",
                    f = null,
                    m = [],
                    g = new Map,
                    v = new Z;
                v.layers.enable(1), v.viewport = new a; var y = new Z;
                y.layers.enable(2), y.viewport = new a; var x = [v, y],
                    _ = new Ot;
                _.layers.enable(1), _.layers.enable(2); var b = null,
                    w = null;
                this.isPresenting = this.enabled = !1, this.getController = function(e) { var t = m[e]; return void 0 === t && (t = new It, m[e] = t), t.getTargetRaySpace() }, this.getControllerGrip = function(e) { var t = m[e]; return void 0 === t && (t = new It, m[e] = t), t.getGripSpace() }, this.setFramebufferScaleFactor = function(e) { u = e, !0 === c.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function(e) { d = e, !0 === c.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function() { return p }, this.getSession = function() { return h }, this.setSession = function(e) { null !== (h = e) && (h.addEventListener("select", n), h.addEventListener("selectstart", n), h.addEventListener("selectend", n), h.addEventListener("squeeze", n), h.addEventListener("squeezestart", n), h.addEventListener("squeezeend", n), h.addEventListener("end", i), !0 !== (e = t.getContextAttributes()).xrCompatible && t.makeXRCompatible(), e = new XRWebGLLayer(h, t, { antialias: e.antialias, alpha: e.alpha, depth: e.depth, stencil: e.stencil, framebufferScaleFactor: u }), h.updateRenderState({ baseLayer: e }), h.requestReferenceSpace(d).then(r), h.addEventListener("inputsourceschange", o)) }; var M = new l,
                    S = new l;
                this.getCamera = function(e) { _.near = y.near = v.near = e.near, _.far = y.far = v.far = e.far, b === _.near && w === _.far || (h.updateRenderState({ depthNear: _.near, depthFar: _.far }), b = _.near, w = _.far); var t = e.parent,
                        n = _.cameras;
                    s(_, t); for (var i = 0; i < n.length; i++) s(n[i], t); for (e.matrixWorld.copy(_.matrixWorld), i = 0, t = (e = e.children).length; i < t; i++) e[i].updateMatrixWorld(!0); if (2 === n.length) { M.setFromMatrixPosition(v.matrixWorld), S.setFromMatrixPosition(y.matrixWorld), n = M.distanceTo(S); var r = v.projectionMatrix.elements,
                            a = y.projectionMatrix.elements,
                            o = r[14] / (r[10] - 1);
                        i = r[14] / (r[10] + 1), e = (r[9] + 1) / r[5], t = (r[9] - 1) / r[5]; var c = (r[8] - 1) / r[0],
                            l = (a[8] + 1) / a[0];
                        a = o * c, r = o * l, c = (l = n / (-c + l)) * -c, v.matrixWorld.decompose(_.position, _.quaternion, _.scale), _.translateX(c), _.translateZ(l), _.matrixWorld.compose(_.position, _.quaternion, _.scale), _.matrixWorldInverse.getInverse(_.matrixWorld), o += l, l = i + l, _.projectionMatrix.makePerspective(a - c, r + (n - c), e * i / l * o, t * i / l * o, o, l) } else _.projectionMatrix.copy(v.projectionMatrix); return _ }; var T = null,
                    E = new ee;
                E.setAnimationLoop(function(t, n) { if (null !== (f = n.getViewerPose(p))) { var i = f.views,
                            r = h.renderState.baseLayer;
                        e.setFramebuffer(r.framebuffer); var a = !1;
                        i.length !== _.cameras.length && (_.cameras.length = 0, a = !0); for (var o = 0; o < i.length; o++) { var s = i[o],
                                c = r.getViewport(s),
                                l = x[o];
                            l.matrix.fromArray(s.transform.matrix), l.projectionMatrix.fromArray(s.projectionMatrix), l.viewport.set(c.x, c.y, c.width, c.height), 0 === o && _.matrix.copy(l.matrix), !0 === a && _.cameras.push(l) } } for (i = h.inputSources, o = 0; o < m.length; o++) m[o].update(i[o], n, p);
                    T && T(t, n) }), this.setAnimationLoop = function(e) { T = e }, this.dispose = function() {} }

            function Bt(e) {
                function t(t, n, i) { if (t.opacity.value = n.opacity, n.color && t.diffuse.value.copy(n.color), n.emissive && t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (t.map.value = n.map), n.alphaMap && (t.alphaMap.value = n.alphaMap), n.specularMap && (t.specularMap.value = n.specularMap), (i = n.envMap || i) && (t.envMap.value = i, t.flipEnvMap.value = i.isCubeTexture ? -1 : 1, t.reflectivity.value = n.reflectivity, t.refractionRatio.value = n.refractionRatio, t.maxMipLevel.value = e.get(i).__maxMipLevel), n.lightMap && (t.lightMap.value = n.lightMap, t.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (t.aoMap.value = n.aoMap, t.aoMapIntensity.value = n.aoMapIntensity), n.map) var r = n.map;
                    else n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap && (r = n.emissiveMap); if (void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix)), n.aoMap) var a = n.aoMap;
                    else n.lightMap && (a = n.lightMap);
                    void 0 !== a && (a.isWebGLRenderTarget && (a = a.texture), !0 === a.matrixAutoUpdate && a.updateMatrix(), t.uv2Transform.value.copy(a.matrix)) }

                function n(e, t, n) { e.roughness.value = t.roughness, e.metalness.value = t.metalness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap), t.metalnessMap && (e.metalnessMap.value = t.metalnessMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), (t.envMap || n) && (e.envMapIntensity.value = t.envMapIntensity) } return { refreshFogUniforms: function(e, t) { e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density) }, refreshMaterialUniforms: function(e, i, r, a, o) { if (i.isMeshBasicMaterial) t(e, i);
                        else if (i.isMeshLambertMaterial) t(e, i), i.emissiveMap && (e.emissiveMap.value = i.emissiveMap);
                        else if (i.isMeshToonMaterial) t(e, i), e.specular.value.copy(i.specular), e.shininess.value = Math.max(i.shininess, 1e-4), i.gradientMap && (e.gradientMap.value = i.gradientMap), i.emissiveMap && (e.emissiveMap.value = i.emissiveMap), i.bumpMap && (e.bumpMap.value = i.bumpMap, e.bumpScale.value = i.bumpScale, 1 === i.side && (e.bumpScale.value *= -1)), i.normalMap && (e.normalMap.value = i.normalMap, e.normalScale.value.copy(i.normalScale), 1 === i.side && e.normalScale.value.negate()), i.displacementMap && (e.displacementMap.value = i.displacementMap, e.displacementScale.value = i.displacementScale, e.displacementBias.value = i.displacementBias);
                        else if (i.isMeshPhongMaterial) t(e, i), e.specular.value.copy(i.specular), e.shininess.value = Math.max(i.shininess, 1e-4), i.emissiveMap && (e.emissiveMap.value = i.emissiveMap), i.bumpMap && (e.bumpMap.value = i.bumpMap, e.bumpScale.value = i.bumpScale, 1 === i.side && (e.bumpScale.value *= -1)), i.normalMap && (e.normalMap.value = i.normalMap, e.normalScale.value.copy(i.normalScale), 1 === i.side && e.normalScale.value.negate()), i.displacementMap && (e.displacementMap.value = i.displacementMap, e.displacementScale.value = i.displacementScale, e.displacementBias.value = i.displacementBias);
                        else if (i.isMeshStandardMaterial) t(e, i, r), i.isMeshPhysicalMaterial ? (n(e, i, r), e.reflectivity.value = i.reflectivity, e.clearcoat.value = i.clearcoat, e.clearcoatRoughness.value = i.clearcoatRoughness, i.sheen && e.sheen.value.copy(i.sheen), i.clearcoatMap && (e.clearcoatMap.value = i.clearcoatMap), i.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = i.clearcoatRoughnessMap), i.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(i.clearcoatNormalScale), e.clearcoatNormalMap.value = i.clearcoatNormalMap, 1 === i.side && e.clearcoatNormalScale.value.negate()), e.transparency.value = i.transparency) : n(e, i, r);
                        else if (i.isMeshMatcapMaterial) t(e, i), i.matcap && (e.matcap.value = i.matcap), i.bumpMap && (e.bumpMap.value = i.bumpMap, e.bumpScale.value = i.bumpScale, 1 === i.side && (e.bumpScale.value *= -1)), i.normalMap && (e.normalMap.value = i.normalMap, e.normalScale.value.copy(i.normalScale), 1 === i.side && e.normalScale.value.negate()), i.displacementMap && (e.displacementMap.value = i.displacementMap, e.displacementScale.value = i.displacementScale, e.displacementBias.value = i.displacementBias);
                        else if (i.isMeshDepthMaterial) t(e, i), i.displacementMap && (e.displacementMap.value = i.displacementMap, e.displacementScale.value = i.displacementScale, e.displacementBias.value = i.displacementBias);
                        else if (i.isMeshDistanceMaterial) t(e, i), i.displacementMap && (e.displacementMap.value = i.displacementMap, e.displacementScale.value = i.displacementScale, e.displacementBias.value = i.displacementBias), e.referencePosition.value.copy(i.referencePosition), e.nearDistance.value = i.nearDistance, e.farDistance.value = i.farDistance;
                        else if (i.isMeshNormalMaterial) t(e, i), i.bumpMap && (e.bumpMap.value = i.bumpMap, e.bumpScale.value = i.bumpScale, 1 === i.side && (e.bumpScale.value *= -1)), i.normalMap && (e.normalMap.value = i.normalMap, e.normalScale.value.copy(i.normalScale), 1 === i.side && e.normalScale.value.negate()), i.displacementMap && (e.displacementMap.value = i.displacementMap, e.displacementScale.value = i.displacementScale, e.displacementBias.value = i.displacementBias);
                        else if (i.isLineBasicMaterial) e.diffuse.value.copy(i.color), e.opacity.value = i.opacity, i.isLineDashedMaterial && (e.dashSize.value = i.dashSize, e.totalSize.value = i.dashSize + i.gapSize, e.scale.value = i.scale);
                        else if (i.isPointsMaterial) { if (e.diffuse.value.copy(i.color), e.opacity.value = i.opacity, e.size.value = i.size * a, e.scale.value = .5 * o, i.map && (e.map.value = i.map), i.alphaMap && (e.alphaMap.value = i.alphaMap), i.map) var s = i.map;
                            else i.alphaMap && (s = i.alphaMap);
                            void 0 !== s && (!0 === s.matrixAutoUpdate && s.updateMatrix(), e.uvTransform.value.copy(s.matrix)) } else if (i.isSpriteMaterial) { if (e.diffuse.value.copy(i.color), e.opacity.value = i.opacity, e.rotation.value = i.rotation, i.map && (e.map.value = i.map), i.alphaMap && (e.alphaMap.value = i.alphaMap), i.map) var c = i.map;
                            else i.alphaMap && (c = i.alphaMap);
                            void 0 !== c && (!0 === c.matrixAutoUpdate && c.updateMatrix(), e.uvTransform.value.copy(c.matrix)) } else i.isShadowMaterial ? (e.color.value.copy(i.color), e.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1) } } }

            function zt(e) { var t;

                function i() { L = new ce(Ne), !1 === (R = new oe(Ne, L, e)).isWebGL2 && (L.get("WEBGL_depth_texture"), L.get("OES_texture_float"), L.get("OES_texture_half_float"), L.get("OES_texture_half_float_linear"), L.get("OES_standard_derivatives"), L.get("OES_element_index_uint"), L.get("ANGLE_instanced_arrays")), L.get("OES_texture_float_linear"), W = new Ct(Ne, L, R), (P = new Rt(Ne, L, R)).scissor(xe.copy(Ae).multiplyScalar(Me).floor()), P.viewport(ye.copy(Ee).multiplyScalar(Me).floor()), C = new ue(Ne), O = new gt, D = new Pt(Ne, L, P, O, R, W, C), I = new te(Ne, R), N = new le(Ne, I, C), B = new fe(Ne, N, I, C), k = new de(Ne), z = new mt(q, L, R), U = new Bt(O), F = new _t, G = new Tt, H = new re(q, P, B, w), V = new ae(Ne, L, C, R), j = new he(Ne, L, C, R), C.programs = z.programs, q.capabilities = R, q.extensions = L, q.properties = O, q.renderLists = F, q.state = P, q.info = C }

                function r(e) { e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), X = !0 }

                function o() { console.log("THREE.WebGLRenderer: Context Restored."), X = !1, i() }

                function s(e) {
                    (e = e.target).removeEventListener("dispose", s), c(e), O.remove(e) }

                function c(e) { var t = O.get(e).program;
                    e.program = void 0, void 0 !== t && z.releaseProgram(t) }

                function u(e, t, n, i) { for (var r = 0, a = e.length; r < a; r++) { var o = e[r],
                            s = o.object,
                            c = o.geometry,
                            l = void 0 === i ? o.material : i; if (o = o.group, n.isArrayCamera) { ve = n; for (var h = n.cameras, u = 0, d = h.length; u < d; u++) { var f = h[u];
                                s.layers.test(f.layers) && (P.viewport(ye.copy(f.viewport)), A.setupLights(f), p(s, t, f, c, l, o)) } } else ve = null, p(s, t, n, c, l, o) } }

                function p(e, n, i, r, a, o) { if (e.onBeforeRender(q, n, i, r, a, o), A = G.get(n, ve || i), e.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject) { var s = m(i, n, a, e);
                        P.setMaterial(a), pe = t = null, me = !1,
                            function(e, t) { e.render(function(e) { q.renderBufferImmediate(e, t) }) }(e, s) } else q.renderBufferDirect(i, n, r, a, e, o);
                    e.onAfterRender(q, n, i, r, a, o), A = G.get(n, ve || i) }

                function d(e, t, n) { var i = O.get(e),
                        r = A.state.lights,
                        a = r.state.version;
                    n = z.getParameters(e, r.state, A.state.shadowsArray, t, Pe.numPlanes, Pe.numIntersection, n); var o = z.getProgramCacheKey(n),
                        l = i.program,
                        h = !0; if (void 0 === l) e.addEventListener("dispose", s);
                    else if (l.cacheKey !== o) c(e);
                    else { if (i.lightsStateVersion !== a) i.lightsStateVersion = a;
                        else if (void 0 !== n.shaderID) return;
                        h = !1 } if (h && (l = z.acquireProgram(n, o), i.program = l, i.uniforms = n.uniforms, i.outputEncoding = n.outputEncoding, e.program = l), n = l.getAttributes(), e.morphTargets)
                        for (o = e.numSupportedMorphTargets = 0; o < q.maxMorphTargets; o++) 0 <= n["morphTarget" + o] && e.numSupportedMorphTargets++; if (e.morphNormals)
                        for (o = e.numSupportedMorphNormals = 0; o < q.maxMorphNormals; o++) 0 <= n["morphNormal" + o] && e.numSupportedMorphNormals++;
                    n = i.uniforms, (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (i.numClippingPlanes = Pe.numPlanes, i.numIntersection = Pe.numIntersection, n.clippingPlanes = Pe.uniform), i.environment = e.isMeshStandardMaterial ? t.environment : null, i.fog = t.fog, i.needsLights = e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights, i.lightsStateVersion = a, i.needsLights && (n.ambientLightColor.value = r.state.ambient, n.lightProbe.value = r.state.probe, n.directionalLights.value = r.state.directional, n.directionalLightShadows.value = r.state.directionalShadow, n.spotLights.value = r.state.spot, n.spotLightShadows.value = r.state.spotShadow, n.rectAreaLights.value = r.state.rectArea, n.pointLights.value = r.state.point, n.pointLightShadows.value = r.state.pointShadow, n.hemisphereLights.value = r.state.hemi, n.directionalShadowMap.value = r.state.directionalShadowMap, n.directionalShadowMatrix.value = r.state.directionalShadowMatrix, n.spotShadowMap.value = r.state.spotShadowMap, n.spotShadowMatrix.value = r.state.spotShadowMatrix, n.pointShadowMap.value = r.state.pointShadowMap, n.pointShadowMatrix.value = r.state.pointShadowMatrix), e = i.program.getUniforms(), e = et.seqWithValue(e.seq, n), i.uniformsList = e }

                function m(e, t, n, i) { D.resetTextureUnits(); var r = t.fog,
                        a = n.isMeshStandardMaterial ? t.environment : null,
                        o = null === Q ? q.outputEncoding : Q.texture.encoding,
                        s = O.get(n),
                        c = A.state.lights;
                    Ce && (Oe || e !== ge) && Pe.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, e, s, e === ge && n.id === ie), n.version === s.__version ? void 0 === s.program ? d(n, t, i) : n.fog && s.fog !== r ? d(n, t, i) : s.environment !== a ? d(n, t, i) : s.needsLights && s.lightsStateVersion !== c.state.version ? d(n, t, i) : void 0 === s.numClippingPlanes || s.numClippingPlanes === Pe.numPlanes && s.numIntersection === Pe.numIntersection ? s.outputEncoding !== o && d(n, t, i) : d(n, t, i) : (d(n, t, i), s.__version = n.version); var l = !1,
                        h = !1,
                        u = !1; if (o = (t = s.program).getUniforms(), c = s.uniforms, P.useProgram(t.program) && (u = h = l = !0), n.id !== ie && (ie = n.id, h = !0), (l || ge !== e) && (o.setValue(Ne, "projectionMatrix", e.projectionMatrix), R.logarithmicDepthBuffer && o.setValue(Ne, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), ge !== e && (ge = e, u = h = !0), (n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) && (void 0 !== (l = o.map.cameraPosition) && l.setValue(Ne, Ie.setFromMatrixPosition(e.matrixWorld))), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && o.setValue(Ne, "isOrthographic", !0 === e.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && o.setValue(Ne, "viewMatrix", e.matrixWorldInverse)), n.skinning && (o.setOptional(Ne, i, "bindMatrix"), o.setOptional(Ne, i, "bindMatrixInverse"), e = i.skeleton))
                        if (l = e.bones, R.floatVertexTextures) { if (void 0 === e.boneTexture) { l = Math.sqrt(4 * l.length), l = Ra.ceilPowerOfTwo(l), l = Math.max(l, 4); var p = new Float32Array(l * l * 4);
                                p.set(e.boneMatrices); var f = new K(p, l, l, 1023, 1015);
                                e.boneMatrices = p, e.boneTexture = f, e.boneTextureSize = l } o.setValue(Ne, "boneTexture", e.boneTexture, D), o.setValue(Ne, "boneTextureSize", e.boneTextureSize) } else o.setOptional(Ne, e, "boneMatrices"); return (h || s.receiveShadow !== i.receiveShadow) && (s.receiveShadow = i.receiveShadow, o.setValue(Ne, "receiveShadow", i.receiveShadow)), h && (o.setValue(Ne, "toneMappingExposure", q.toneMappingExposure), o.setValue(Ne, "toneMappingWhitePoint", q.toneMappingWhitePoint), s.needsLights && (h = u, c.ambientLightColor.needsUpdate = h, c.lightProbe.needsUpdate = h, c.directionalLights.needsUpdate = h, c.directionalLightShadows.needsUpdate = h, c.pointLights.needsUpdate = h, c.pointLightShadows.needsUpdate = h, c.spotLights.needsUpdate = h, c.spotLightShadows.needsUpdate = h, c.rectAreaLights.needsUpdate = h, c.hemisphereLights.needsUpdate = h), r && n.fog && U.refreshFogUniforms(c, r), U.refreshMaterialUniforms(c, n, a, Me, we), void 0 !== c.ltc_1 && (c.ltc_1.value = ws.LTC_1), void 0 !== c.ltc_2 && (c.ltc_2.value = ws.LTC_2), et.upload(Ne, s.uniformsList, c, D)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (et.upload(Ne, s.uniformsList, c, D), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && o.setValue(Ne, "center", i.center), o.setValue(Ne, "modelViewMatrix", i.modelViewMatrix), o.setValue(Ne, "normalMatrix", i.normalMatrix), o.setValue(Ne, "modelMatrix", i.matrixWorld), t } var g = void 0 !== (e = e || {}).canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                    v = void 0 !== e.context ? e.context : null,
                    y = void 0 !== e.alpha && e.alpha,
                    x = void 0 === e.depth || e.depth,
                    _ = void 0 === e.stencil || e.stencil,
                    b = void 0 !== e.antialias && e.antialias,
                    w = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
                    M = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
                    S = void 0 !== e.powerPreference ? e.powerPreference : "default",
                    T = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat,
                    E = null,
                    A = null;
                this.domElement = g, this.debug = { checkShaderErrors: !0 }, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = 3e3, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingWhitePoint = this.toneMappingExposure = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4; var L, R, P, C, O, D, I, N, B, z, U, F, G, H, k, V, j, W, q = this,
                    X = !1,
                    Y = null,
                    Z = 0,
                    J = 0,
                    Q = null,
                    ne = null,
                    ie = -1,
                    pe = t = null,
                    me = !1,
                    ge = null,
                    ve = null,
                    ye = new a,
                    xe = new a,
                    _e = null,
                    be = g.width,
                    we = g.height,
                    Me = 1,
                    Se = null,
                    Te = null,
                    Ee = new a(0, 0, be, we),
                    Ae = new a(0, 0, be, we),
                    Le = !1,
                    Re = new $,
                    Pe = new se,
                    Ce = !1,
                    Oe = !1,
                    De = new h,
                    Ie = new l; try { y = { alpha: y, depth: x, stencil: _, antialias: b, premultipliedAlpha: w, preserveDrawingBuffer: M, powerPreference: S, failIfMajorPerformanceCaveat: T }, g.addEventListener("webglcontextlost", r, !1), g.addEventListener("webglcontextrestored", o, !1); var Ne = v || g.getContext("webgl", y) || g.getContext("experimental-webgl", y); if (null === Ne) { if (null !== g.getContext("webgl")) throw Error("Error creating WebGL context with your selected attributes."); throw Error("Error creating WebGL context.") } void 0 === Ne.getShaderPrecisionFormat && (Ne.getShaderPrecisionFormat = function() { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (e) { throw console.error("THREE.WebGLRenderer: " + e.message), e } i(); var Be = new Nt(q, Ne);
                this.xr = Be; var ze = new Lt(q, B, R.maxTextureSize);
                this.shadowMap = ze, this.getContext = function() { return Ne }, this.getContextAttributes = function() { return Ne.getContextAttributes() }, this.forceContextLoss = function() { var e = L.get("WEBGL_lose_context");
                    e && e.loseContext() }, this.forceContextRestore = function() { var e = L.get("WEBGL_lose_context");
                    e && e.restoreContext() }, this.getPixelRatio = function() { return Me }, this.setPixelRatio = function(e) { void 0 !== e && (Me = e, this.setSize(be, we, !1)) }, this.getSize = function(e) { return void 0 === e && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), e = new n), e.set(be, we) }, this.setSize = function(e, t, n) { Be.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (be = e, we = t, g.width = Math.floor(e * Me), g.height = Math.floor(t * Me), !1 !== n && (g.style.width = e + "px", g.style.height = t + "px"), this.setViewport(0, 0, e, t)) }, this.getDrawingBufferSize = function(e) { return void 0 === e && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), e = new n), e.set(be * Me, we * Me).floor() }, this.setDrawingBufferSize = function(e, t, n) { be = e, we = t, Me = n, g.width = Math.floor(e * n), g.height = Math.floor(t * n), this.setViewport(0, 0, e, t) }, this.getCurrentViewport = function(e) { return void 0 === e && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), e = new a), e.copy(ye) }, this.getViewport = function(e) { return e.copy(Ee) }, this.setViewport = function(e, t, n, i) { e.isVector4 ? Ee.set(e.x, e.y, e.z, e.w) : Ee.set(e, t, n, i), P.viewport(ye.copy(Ee).multiplyScalar(Me).floor()) }, this.getScissor = function(e) { return e.copy(Ae) }, this.setScissor = function(e, t, n, i) { e.isVector4 ? Ae.set(e.x, e.y, e.z, e.w) : Ae.set(e, t, n, i), P.scissor(xe.copy(Ae).multiplyScalar(Me).floor()) }, this.getScissorTest = function() { return Le }, this.setScissorTest = function(e) { P.setScissorTest(Le = e) }, this.setOpaqueSort = function(e) { Se = e }, this.setTransparentSort = function(e) { Te = e }, this.getClearColor = function() { return H.getClearColor() }, this.setClearColor = function() { H.setClearColor.apply(H, arguments) }, this.getClearAlpha = function() { return H.getClearAlpha() }, this.setClearAlpha = function() { H.setClearAlpha.apply(H, arguments) }, this.clear = function(e, t, n) { var i = 0;
                    (void 0 === e || e) && (i |= 16384), (void 0 === t || t) && (i |= 256), (void 0 === n || n) && (i |= 1024), Ne.clear(i) }, this.clearColor = function() { this.clear(!0, !1, !1) }, this.clearDepth = function() { this.clear(!1, !0, !1) }, this.clearStencil = function() { this.clear(!1, !1, !0) }, this.dispose = function() { g.removeEventListener("webglcontextlost", r, !1), g.removeEventListener("webglcontextrestored", o, !1), F.dispose(), G.dispose(), O.dispose(), B.dispose(), Be.dispose(), Ge.stop() }, this.renderBufferImmediate = function(e, t) { P.initAttributes(); var n = O.get(e);
                    e.hasPositions && !n.position && (n.position = Ne.createBuffer()), e.hasNormals && !n.normal && (n.normal = Ne.createBuffer()), e.hasUvs && !n.uv && (n.uv = Ne.createBuffer()), e.hasColors && !n.color && (n.color = Ne.createBuffer()), t = t.getAttributes(), e.hasPositions && (Ne.bindBuffer(34962, n.position), Ne.bufferData(34962, e.positionArray, 35048), P.enableAttribute(t.position), Ne.vertexAttribPointer(t.position, 3, 5126, !1, 0, 0)), e.hasNormals && (Ne.bindBuffer(34962, n.normal), Ne.bufferData(34962, e.normalArray, 35048), P.enableAttribute(t.normal), Ne.vertexAttribPointer(t.normal, 3, 5126, !1, 0, 0)), e.hasUvs && (Ne.bindBuffer(34962, n.uv), Ne.bufferData(34962, e.uvArray, 35048), P.enableAttribute(t.uv), Ne.vertexAttribPointer(t.uv, 2, 5126, !1, 0, 0)), e.hasColors && (Ne.bindBuffer(34962, n.color), Ne.bufferData(34962, e.colorArray, 35048), P.enableAttribute(t.color), Ne.vertexAttribPointer(t.color, 3, 5126, !1, 0, 0)), P.disableUnusedAttributes(), Ne.drawArrays(4, 0, e.count), e.count = 0 }; var Ue = new f;
                this.renderBufferDirect = function(e, n, i, r, a, o) { null === n && (n = Ue); var s = a.isMesh && 0 > a.matrixWorld.determinant(),
                        c = m(e, n, r, a);
                    P.setMaterial(r, s); var l = !1; if (t === i.id && pe === c.id && me === (!0 === r.wireframe) || (t = i.id, pe = c.id, me = !0 === r.wireframe, l = !0), (r.morphTargets || r.morphNormals) && (k.update(a, i, r, c), l = !0), !0 === a.isInstancedMesh && (l = !0), e = i.index, n = i.attributes.position, null === e) { if (void 0 === n || 0 === n.count) return } else if (0 === e.count) return; var h = 1; if (!0 === r.wireframe && (e = N.getWireframeAttribute(i), h = 2), s = V, null !== e) { var u = I.get(e);
                        (s = j).setIndex(u) } if (l) { if (!1 !== R.isWebGL2 || !a.isInstancedMesh && !i.isInstancedBufferGeometry || null !== L.get("ANGLE_instanced_arrays")) { P.initAttributes(), l = i.attributes, c = c.getAttributes(); var p = r.defaultAttributeValues; for (M in c) { var d = c[M]; if (0 <= d) { var f = l[M]; if (void 0 !== f) { var g = f.normalized,
                                            v = f.itemSize,
                                            y = I.get(f); if (void 0 !== y) { var x = y.buffer,
                                                _ = y.type; if (y = y.bytesPerElement, f.isInterleavedBufferAttribute) { var b = f.data,
                                                    w = b.stride;
                                                f = f.offset, b && b.isInstancedInterleavedBuffer ? (P.enableAttributeAndDivisor(d, b.meshPerAttribute), void 0 === i._maxInstanceCount && (i._maxInstanceCount = b.meshPerAttribute * b.count)) : P.enableAttribute(d), Ne.bindBuffer(34962, x), P.vertexAttribPointer(d, v, _, g, w * y, f * y) } else f.isInstancedBufferAttribute ? (P.enableAttributeAndDivisor(d, f.meshPerAttribute), void 0 === i._maxInstanceCount && (i._maxInstanceCount = f.meshPerAttribute * f.count)) : P.enableAttribute(d), Ne.bindBuffer(34962, x), P.vertexAttribPointer(d, v, _, g, 0, 0) } } else if ("instanceMatrix" === M) void 0 !== (y = I.get(a.instanceMatrix)) && (x = y.buffer, _ = y.type, P.enableAttributeAndDivisor(d + 0, 1), P.enableAttributeAndDivisor(d + 1, 1), P.enableAttributeAndDivisor(d + 2, 1), P.enableAttributeAndDivisor(d + 3, 1), Ne.bindBuffer(34962, x), Ne.vertexAttribPointer(d + 0, 4, _, !1, 64, 0), Ne.vertexAttribPointer(d + 1, 4, _, !1, 64, 16), Ne.vertexAttribPointer(d + 2, 4, _, !1, 64, 32), Ne.vertexAttribPointer(d + 3, 4, _, !1, 64, 48));
                                    else if (void 0 !== p && void 0 !== (g = p[M])) switch (g.length) {
                                        case 2:
                                            Ne.vertexAttrib2fv(d, g); break;
                                        case 3:
                                            Ne.vertexAttrib3fv(d, g); break;
                                        case 4:
                                            Ne.vertexAttrib4fv(d, g); break;
                                        default:
                                            Ne.vertexAttrib1fv(d, g) } } } P.disableUnusedAttributes() } null !== e && Ne.bindBuffer(34963, u.buffer) } var M = i.drawRange.start * h;
                    l = null !== o ? o.start * h : 0, u = Math.max(M, l), 0 !== (o = Math.max(0, Math.min(null !== e ? e.count : n.count, M + i.drawRange.count * h, l + (null !== o ? o.count * h : 1 / 0)) - 1 - u + 1)) && (a.isMesh ? !0 === r.wireframe ? (P.setLineWidth(r.wireframeLinewidth * (null === Q ? Me : 1)), s.setMode(1)) : s.setMode(4) : a.isLine ? (void 0 === (r = r.linewidth) && (r = 1), P.setLineWidth(r * (null === Q ? Me : 1)), a.isLineSegments ? s.setMode(1) : a.isLineLoop ? s.setMode(2) : s.setMode(3)) : a.isPoints ? s.setMode(0) : a.isSprite && s.setMode(4), a.isInstancedMesh ? s.renderInstances(i, u, o, a.count) : i.isInstancedBufferGeometry ? s.renderInstances(i, u, o, Math.min(i.instanceCount, i._maxInstanceCount)) : s.render(u, o)) }, this.compile = function(e, t) {
                    (A = G.get(e, t)).init(), e.traverse(function(e) { e.isLight && (A.pushLight(e), e.castShadow && A.pushShadow(e)) }), A.setupLights(t); var n = {};
                    e.traverse(function(t) { var i = t.material; if (i)
                            if (Array.isArray(i))
                                for (var r = 0; r < i.length; r++) { var a = i[r];!1 == a.uuid in n && (d(a, e, t), n[a.uuid] = !0) } else !1 == i.uuid in n && (d(i, e, t), n[i.uuid] = !0) }) }; var Fe = null,
                    Ge = new ee;
                Ge.setAnimationLoop(function(e) { Be.isPresenting || Fe && Fe(e) }), "undefined" != typeof window && Ge.setContext(window), this.setAnimationLoop = function(e) { Fe = e, Be.setAnimationLoop(e), Ge.start() }, this.render = function(e, n, i, r) { if (void 0 !== i) { console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."); var a = i } if (void 0 !== r) { console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."); var o = r } n && n.isCamera ? X || (pe = t = null, me = !1, ie = -1, ge = null, !0 === e.autoUpdate && e.updateMatrixWorld(), null === n.parent && n.updateMatrixWorld(), Be.enabled && Be.isPresenting && (n = Be.getCamera(n)), e.onBeforeRender(q, e, n, a || Q), (A = G.get(e, n)).init(), De.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), Re.setFromProjectionMatrix(De), Oe = this.localClippingEnabled, Ce = Pe.init(this.clippingPlanes, Oe, n), (E = F.get(e, n)).init(), function e(t, n, i, r) { if (!1 !== t.visible) { if (t.layers.test(n.layers))
                                if (t.isGroup) i = t.renderOrder;
                                else if (t.isLOD) !0 === t.autoUpdate && t.update(n);
                            else if (t.isLight) A.pushLight(t), t.castShadow && A.pushShadow(t);
                            else if (t.isSprite) { if (!t.frustumCulled || Re.intersectsSprite(t)) { r && Ie.setFromMatrixPosition(t.matrixWorld).applyMatrix4(De); var a = B.update(t),
                                        o = t.material;
                                    o.visible && E.push(t, a, o, i, Ie.z, null) } } else if (t.isImmediateRenderObject) r && Ie.setFromMatrixPosition(t.matrixWorld).applyMatrix4(De), E.push(t, null, t.material, i, Ie.z, null);
                            else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== C.render.frame && (t.skeleton.update(), t.skeleton.frame = C.render.frame), !t.frustumCulled || Re.intersectsObject(t)))
                                if (r && Ie.setFromMatrixPosition(t.matrixWorld).applyMatrix4(De), a = B.update(t), o = t.material, Array.isArray(o))
                                    for (var s = a.groups, c = 0, l = s.length; c < l; c++) { var h = s[c],
                                            u = o[h.materialIndex];
                                        u && u.visible && E.push(t, a, u, i, Ie.z, h) } else o.visible && E.push(t, a, o, i, Ie.z, null); for (c = 0, l = (t = t.children).length; c < l; c++) e(t[c], n, i, r) } }(e, n, 0, q.sortObjects), E.finish(), !0 === q.sortObjects && E.sort(Se, Te), Ce && Pe.beginShadows(), ze.render(A.state.shadowsArray, e, n), A.setupLights(n), Ce && Pe.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== a && this.setRenderTarget(a), H.render(E, e, n, o), i = E.opaque, r = E.transparent, e.overrideMaterial ? (a = e.overrideMaterial, i.length && u(i, e, n, a), r.length && u(r, e, n, a)) : (i.length && u(i, e, n), r.length && u(r, e, n)), e.onAfterRender(q, e, n), null !== Q && (D.updateRenderTargetMipmap(Q), D.updateMultisampleRenderTarget(Q)), P.buffers.depth.setTest(!0), P.buffers.depth.setMask(!0), P.buffers.color.setMask(!0), P.setPolygonOffset(!1), A = E = null) : console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.") }, this.setFramebuffer = function(e) { Y !== e && null === Q && Ne.bindFramebuffer(36160, e), Y = e }, this.getActiveCubeFace = function() { return Z }, this.getActiveMipmapLevel = function() { return J }, this.getRenderTarget = function() { return Q }, this.setRenderTarget = function(e, t, n) { Q = e, Z = t, J = n, e && void 0 === O.get(e).__webglFramebuffer && D.setupRenderTarget(e); var i = Y,
                        r = !1;
                    e ? (i = O.get(e).__webglFramebuffer, e.isWebGLCubeRenderTarget ? (i = i[t || 0], r = !0) : i = e.isWebGLMultisampleRenderTarget ? O.get(e).__webglMultisampledFramebuffer : i, ye.copy(e.viewport), xe.copy(e.scissor), _e = e.scissorTest) : (ye.copy(Ee).multiplyScalar(Me).floor(), xe.copy(Ae).multiplyScalar(Me).floor(), _e = Le), ne !== i && (Ne.bindFramebuffer(36160, i), ne = i), P.viewport(ye), P.scissor(xe), P.setScissorTest(_e), r && (e = O.get(e.texture), Ne.framebufferTexture2D(36160, 36064, 34069 + (t || 0), e.__webglTexture, n || 0)) }, this.readRenderTargetPixels = function(e, t, n, i, r, a, o) { if (e && e.isWebGLRenderTarget) { var s = O.get(e).__webglFramebuffer; if (e.isWebGLCubeRenderTarget && void 0 !== o && (s = s[o]), s) { o = !1, s !== ne && (Ne.bindFramebuffer(36160, s), o = !0); try { var c = e.texture,
                                    l = c.format,
                                    h = c.type;
                                1023 !== l && W.convert(l) !== Ne.getParameter(35739) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === h || W.convert(h) === Ne.getParameter(35738) || 1015 === h && (R.isWebGL2 || L.get("OES_texture_float") || L.get("WEBGL_color_buffer_float")) || 1016 === h && (R.isWebGL2 ? L.get("EXT_color_buffer_float") : L.get("EXT_color_buffer_half_float")) ? 36053 === Ne.checkFramebufferStatus(36160) ? 0 <= t && t <= e.width - i && 0 <= n && n <= e.height - r && Ne.readPixels(t, n, i, r, W.convert(l), W.convert(h), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.") } finally { o && Ne.bindFramebuffer(36160, ne) } } } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.") }, this.copyFramebufferToTexture = function(e, t, n) { void 0 === n && (n = 0); var i = Math.pow(2, -n),
                        r = Math.floor(t.image.width * i);
                    i = Math.floor(t.image.height * i); var a = W.convert(t.format);
                    D.setTexture2D(t, 0), Ne.copyTexImage2D(3553, n, a, e.x, e.y, r, i, 0), P.unbindTexture() }, this.copyTextureToTexture = function(e, t, n, i) { void 0 === i && (i = 0); var r = t.image.width,
                        a = t.image.height,
                        o = W.convert(n.format),
                        s = W.convert(n.type);
                    D.setTexture2D(n, 0), t.isDataTexture ? Ne.texSubImage2D(3553, i, e.x, e.y, r, a, o, s, t.image.data) : t.isCompressedTexture ? Ne.compressedTexSubImage2D(3553, i, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, o, t.mipmaps[0].data) : Ne.texSubImage2D(3553, i, e.x, e.y, o, s, t.image), 0 === i && n.generateMipmaps && Ne.generateMipmap(3553), P.unbindTexture() }, this.initTexture = function(e) { D.setTexture2D(e, 0), P.unbindTexture() }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) }

            function Ut(e, t) { this.name = "", this.color = new b(e), this.density = void 0 !== t ? t : 25e-5 }

            function Ft(e, t, n) { this.name = "", this.color = new b(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== n ? n : 1e3 }

            function Gt(e, t) { this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = 35044, this.updateRange = { offset: 0, count: -1 }, this.version = 0 }

            function Ht(e, t, n, i) { this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = !0 === i }

            function kt(e) { E.call(this), this.type = "SpriteMaterial", this.color = new b(16777215), this.alphaMap = this.map = null, this.rotation = 0, this.transparent = this.sizeAttenuation = !0, this.setValues(e) }

            function Vt(e) { if (d.call(this), this.type = "Sprite", void 0 === Hs) { Hs = new G; var t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]);
                    t = new Gt(t, 5), Hs.setIndex([0, 1, 2, 0, 2, 3]), Hs.setAttribute("position", new Ht(t, 3, 0, !1)), Hs.setAttribute("uv", new Ht(t, 2, 3, !1)) } this.geometry = Hs, this.material = void 0 !== e ? e : new kt, this.center = new n(.5, .5) }

            function jt(e, t, n, i, r, a) { Ws.subVectors(e, n).addScalar(.5).multiply(i), void 0 !== r ? (qs.x = a * Ws.x - r * Ws.y, qs.y = r * Ws.x + a * Ws.y) : qs.copy(Ws), e.copy(t), e.x += qs.x, e.y += qs.y, e.applyMatrix4(Xs) }

            function Wt() { d.call(this), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }), this.autoUpdate = !0 }

            function qt(e, t) { e && e.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), H.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new h, this.bindMatrixInverse = new h }

            function Xt(e, t) { if (e = e || [], this.bones = e.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), this.frame = -1, void 0 === t) this.calculateInverses();
                else if (this.bones.length === t.length) this.boneInverses = t.slice(0);
                else
                    for (console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [], e = 0, t = this.bones.length; e < t; e++) this.boneInverses.push(new h) }

            function Yt() { d.call(this), this.type = "Bone" }

            function Zt(e, t, n) { H.call(this, e, t), this.instanceMatrix = new L(new Float32Array(16 * n), 16), this.count = n, this.frustumCulled = !1 }

            function Jt(e) { E.call(this), this.type = "LineBasicMaterial", this.color = new b(16777215), this.linewidth = 1, this.linejoin = this.linecap = "round", this.morphTargets = !1, this.setValues(e) }

            function Qt(e, t, n) { 1 === n && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), d.call(this), this.type = "Line", this.geometry = void 0 !== e ? e : new G, this.material = void 0 !== t ? t : new Jt, this.updateMorphTargets() }

            function Kt(e, t) { Qt.call(this, e, t), this.type = "LineSegments" }

            function $t(e, t) { Qt.call(this, e, t), this.type = "LineLoop" }

            function en(e) { E.call(this), this.type = "PointsMaterial", this.color = new b(16777215), this.alphaMap = this.map = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(e) }

            function tn(e, t) { d.call(this), this.type = "Points", this.geometry = void 0 !== e ? e : new G, this.material = void 0 !== t ? t : new en, this.updateMorphTargets() }

            function nn(e, t, n, i, r, a, o) { var s = bc.distanceSqToPoint(e);
                s < n && (n = new l, bc.closestPointToPoint(e, n), n.applyMatrix4(i), (e = r.ray.origin.distanceTo(n)) < r.near || e > r.far || a.push({ distance: e, distanceToRay: Math.sqrt(s), point: n, index: t, face: null, object: o })) }

            function rn(e, t, n, i, a, o, s, c, l) { r.call(this, e, t, n, i, a, o, s, c, l), this.format = void 0 !== s ? s : 1022, this.minFilter = void 0 !== o ? o : 1006, this.magFilter = void 0 !== a ? a : 1006, this.generateMipmaps = !1 }

            function an(e, t, n, i, a, o, s, c, l, h, u, p) { r.call(this, null, o, s, c, l, h, i, a, u, p), this.image = { width: t, height: n }, this.mipmaps = e, this.generateMipmaps = this.flipY = !1 }

            function on(e, t, n, i, a, o, s, c, l) { r.call(this, e, t, n, i, a, o, s, c, l), this.needsUpdate = !0 }

            function sn(e, t, n, i, a, o, s, c, l, h) { if (1026 !== (h = void 0 !== h ? h : 1026) && 1027 !== h) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && 1026 === h && (n = 1012), void 0 === n && 1027 === h && (n = 1020), r.call(this, null, i, a, o, s, c, h, n, l), this.image = { width: e, height: t }, this.magFilter = void 0 !== s ? s : 1003, this.minFilter = void 0 !== c ? c : 1003, this.generateMipmaps = this.flipY = !1 }

            function cn(e) { G.call(this), this.type = "WireframeGeometry"; var t, n, i, r = [],
                    a = [0, 0],
                    o = {},
                    s = ["a", "b", "c"]; if (e && e.isGeometry) { var c = e.faces,
                        h = 0; for (n = c.length; h < n; h++) { var u = c[h]; for (t = 0; 3 > t; t++) { var p = u[s[t]],
                                d = u[s[(t + 1) % 3]];
                            a[0] = Math.min(p, d), a[1] = Math.max(p, d), void 0 === o[p = a[0] + "," + a[1]] && (o[p] = { index1: a[0], index2: a[1] }) } } for (p in o) h = o[p], s = e.vertices[h.index1], r.push(s.x, s.y, s.z), s = e.vertices[h.index2], r.push(s.x, s.y, s.z) } else if (e && e.isBufferGeometry)
                    if (s = new l, null !== e.index) { c = e.attributes.position, u = e.index; var f = e.groups; for (0 === f.length && (f = [{ start: 0, count: u.count, materialIndex: 0 }]), e = 0, i = f.length; e < i; ++e)
                            for (t = (h = f[e]).start, n = h.count, h = t, n = t + n; h < n; h += 3)
                                for (t = 0; 3 > t; t++) p = u.getX(h + t), d = u.getX(h + (t + 1) % 3), a[0] = Math.min(p, d), a[1] = Math.max(p, d), void 0 === o[p = a[0] + "," + a[1]] && (o[p] = { index1: a[0], index2: a[1] }); for (p in o) h = o[p], s.fromBufferAttribute(c, h.index1), r.push(s.x, s.y, s.z), s.fromBufferAttribute(c, h.index2), r.push(s.x, s.y, s.z) } else
                        for (h = 0, n = (c = e.attributes.position).count / 3; h < n; h++)
                            for (t = 0; 3 > t; t++) o = 3 * h + t, s.fromBufferAttribute(c, o), r.push(s.x, s.y, s.z), o = 3 * h + (t + 1) % 3, s.fromBufferAttribute(c, o), r.push(s.x, s.y, s.z);
                this.setAttribute("position", new B(r, 3)) }

            function ln(e, t, n) { j.call(this), this.type = "ParametricGeometry", this.parameters = { func: e, slices: t, stacks: n }, this.fromBufferGeometry(new hn(e, t, n)), this.mergeVertices() }

            function hn(e, t, n) { G.call(this), this.type = "ParametricBufferGeometry", this.parameters = { func: e, slices: t, stacks: n }; var i, r, a = [],
                    o = [],
                    s = [],
                    c = [],
                    h = new l,
                    u = new l,
                    p = new l,
                    d = new l,
                    f = new l;
                3 > e.length && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."); var m = t + 1; for (i = 0; i <= n; i++) { var g = i / n; for (r = 0; r <= t; r++) { var v = r / t;
                        e(v, g, u), o.push(u.x, u.y, u.z), 0 <= v - 1e-5 ? (e(v - 1e-5, g, p), d.subVectors(u, p)) : (e(v + 1e-5, g, p), d.subVectors(p, u)), 0 <= g - 1e-5 ? (e(v, g - 1e-5, p), f.subVectors(u, p)) : (e(v, g + 1e-5, p), f.subVectors(p, u)), h.crossVectors(d, f).normalize(), s.push(h.x, h.y, h.z), c.push(v, g) } } for (i = 0; i < n; i++)
                    for (r = 0; r < t; r++) e = i * m + r + 1, h = (i + 1) * m + r + 1, u = (i + 1) * m + r, a.push(i * m + r, e, u), a.push(e, h, u);
                this.setIndex(a), this.setAttribute("position", new B(o, 3)), this.setAttribute("normal", new B(s, 3)), this.setAttribute("uv", new B(c, 2)) }

            function un(e, t, n, i) { j.call(this), this.type = "PolyhedronGeometry", this.parameters = { vertices: e, indices: t, radius: n, detail: i }, this.fromBufferGeometry(new pn(e, t, n, i)), this.mergeVertices() }

            function pn(e, t, i, r) {
                function a(e) { c.push(e.x, e.y, e.z) }

                function o(t, n) { t *= 3, n.x = e[t + 0], n.y = e[t + 1], n.z = e[t + 2] }

                function s(e, t, n, i) { 0 > i && 1 === e.x && (h[t] = e.x - 1), 0 === n.x && 0 === n.z && (h[t] = i / 2 / Math.PI + .5) } G.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = { vertices: e, indices: t, radius: i, detail: r }, i = i || 1; var c = [],
                    h = [];! function(e) { for (var n = new l, i = new l, r = new l, s = 0; s < t.length; s += 3) { o(t[s + 0], n), o(t[s + 1], i), o(t[s + 2], r); var c, h, u = n,
                            p = i,
                            d = r,
                            f = Math.pow(2, e),
                            m = []; for (h = 0; h <= f; h++) { m[h] = []; var g = u.clone().lerp(d, h / f),
                                v = p.clone().lerp(d, h / f),
                                y = f - h; for (c = 0; c <= y; c++) m[h][c] = 0 === c && h === f ? g : g.clone().lerp(v, c / y) } for (h = 0; h < f; h++)
                            for (c = 0; c < 2 * (f - h) - 1; c++) u = Math.floor(c / 2), 0 == c % 2 ? (a(m[h][u + 1]), a(m[h + 1][u]), a(m[h][u])) : (a(m[h][u + 1]), a(m[h + 1][u + 1]), a(m[h + 1][u])) } }(r = r || 0),
                function(e) { for (var t = new l, n = 0; n < c.length; n += 3) t.x = c[n + 0], t.y = c[n + 1], t.z = c[n + 2], t.normalize().multiplyScalar(e), c[n + 0] = t.x, c[n + 1] = t.y, c[n + 2] = t.z }(i),
                function() { for (var e = new l, t = 0; t < c.length; t += 3) e.x = c[t + 0], e.y = c[t + 1], e.z = c[t + 2], h.push(Math.atan2(e.z, -e.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5));
                    e = new l, t = new l; for (var i = new l, r = new l, a = new n, o = new n, u = new n, p = 0, d = 0; p < c.length; p += 9, d += 6) { e.set(c[p + 0], c[p + 1], c[p + 2]), t.set(c[p + 3], c[p + 4], c[p + 5]), i.set(c[p + 6], c[p + 7], c[p + 8]), a.set(h[d + 0], h[d + 1]), o.set(h[d + 2], h[d + 3]), u.set(h[d + 4], h[d + 5]), r.copy(e).add(t).add(i).divideScalar(3); var f = Math.atan2(r.z, -r.x);
                        s(a, d + 0, e, f), s(o, d + 2, t, f), s(u, d + 4, i, f) } for (e = 0; e < h.length; e += 6) t = h[e + 0], i = h[e + 2], r = h[e + 4], a = Math.min(t, i, r), .9 < Math.max(t, i, r) && .1 > a && (.2 > t && (h[e + 0] += 1), .2 > i && (h[e + 2] += 1), .2 > r && (h[e + 4] += 1)) }(), this.setAttribute("position", new B(c, 3)), this.setAttribute("normal", new B(c.slice(), 3)), this.setAttribute("uv", new B(h, 2)), 0 === r ? this.computeVertexNormals() : this.normalizeNormals() }

            function dn(e, t) { j.call(this), this.type = "TetrahedronGeometry", this.parameters = { radius: e, detail: t }, this.fromBufferGeometry(new fn(e, t)), this.mergeVertices() }

            function fn(e, t) { pn.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronBufferGeometry", this.parameters = { radius: e, detail: t } }

            function mn(e, t) { j.call(this), this.type = "OctahedronGeometry", this.parameters = { radius: e, detail: t }, this.fromBufferGeometry(new gn(e, t)), this.mergeVertices() }

            function gn(e, t) { pn.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronBufferGeometry", this.parameters = { radius: e, detail: t } }

            function vn(e, t) { j.call(this), this.type = "IcosahedronGeometry", this.parameters = { radius: e, detail: t }, this.fromBufferGeometry(new yn(e, t)), this.mergeVertices() }

            function yn(e, t) { var n = (1 + Math.sqrt(5)) / 2;
                pn.call(this, [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronBufferGeometry", this.parameters = { radius: e, detail: t } }

            function xn(e, t) { j.call(this), this.type = "DodecahedronGeometry", this.parameters = { radius: e, detail: t }, this.fromBufferGeometry(new _n(e, t)), this.mergeVertices() }

            function _n(e, t) { var n = (1 + Math.sqrt(5)) / 2,
                    i = 1 / n;
                pn.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronBufferGeometry", this.parameters = { radius: e, detail: t } }

            function bn(e, t, n, i, r, a) { j.call(this), this.type = "TubeGeometry", this.parameters = { path: e, tubularSegments: t, radius: n, radialSegments: i, closed: r }, void 0 !== a && console.warn("THREE.TubeGeometry: taper has been removed."), e = new wn(e, t, n, i, r), this.tangents = e.tangents, this.normals = e.normals, this.binormals = e.binormals, this.fromBufferGeometry(e), this.mergeVertices() }

            function wn(e, t, i, r, a) {
                function o(n) { f = e.getPointAt(n / t, f); var a = s.normals[n]; for (n = s.binormals[n], h = 0; h <= r; h++) { var o = h / r * Math.PI * 2,
                            c = Math.sin(o);
                        o = -Math.cos(o), p.x = o * a.x + c * n.x, p.y = o * a.y + c * n.y, p.z = o * a.z + c * n.z, p.normalize(), g.push(p.x, p.y, p.z), u.x = f.x + i * p.x, u.y = f.y + i * p.y, u.z = f.z + i * p.z, m.push(u.x, u.y, u.z) } } G.call(this), this.type = "TubeBufferGeometry", this.parameters = { path: e, tubularSegments: t, radius: i, radialSegments: r, closed: a }, t = t || 64, i = i || 1, r = r || 8, a = a || !1; var s = e.computeFrenetFrames(t, a);
                this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals; var c, h, u = new l,
                    p = new l,
                    d = new n,
                    f = new l,
                    m = [],
                    g = [],
                    v = [],
                    y = []; for (c = 0; c < t; c++) o(c); for (o(!1 === a ? t : 0), c = 0; c <= t; c++)
                    for (h = 0; h <= r; h++) d.x = c / t, d.y = h / r, v.push(d.x, d.y);! function() { for (h = 1; h <= t; h++)
                        for (c = 1; c <= r; c++) { var e = (r + 1) * h + (c - 1),
                                n = (r + 1) * h + c,
                                i = (r + 1) * (h - 1) + c;
                            y.push((r + 1) * (h - 1) + (c - 1), e, i), y.push(e, n, i) } }(), this.setIndex(y), this.setAttribute("position", new B(m, 3)), this.setAttribute("normal", new B(g, 3)), this.setAttribute("uv", new B(v, 2)) }

            function Mn(e, t, n, i, r, a, o) { j.call(this), this.type = "TorusKnotGeometry", this.parameters = { radius: e, tube: t, tubularSegments: n, radialSegments: i, p: r, q: a }, void 0 !== o && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new Sn(e, t, n, i, r, a)), this.mergeVertices() }

            function Sn(e, t, n, i, r, a) {
                function o(e, t, n, i, r) { var a = Math.sin(e);
                    t = n / t * e, n = Math.cos(t), r.x = i * (2 + n) * .5 * Math.cos(e), r.y = i * (2 + n) * a * .5, r.z = i * Math.sin(t) * .5 } G.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = { radius: e, tube: t, tubularSegments: n, radialSegments: i, p: r, q: a }, e = e || 1, t = t || .4, n = Math.floor(n) || 64, i = Math.floor(i) || 8, r = r || 2, a = a || 3; var s, c = [],
                    h = [],
                    u = [],
                    p = [],
                    d = new l,
                    f = new l,
                    m = new l,
                    g = new l,
                    v = new l,
                    y = new l,
                    x = new l; for (s = 0; s <= n; ++s) { var _ = s / n * r * Math.PI * 2; for (o(_, r, a, e, m), o(_ + .01, r, a, e, g), y.subVectors(g, m), x.addVectors(g, m), v.crossVectors(y, x), x.crossVectors(v, y), v.normalize(), x.normalize(), _ = 0; _ <= i; ++_) { var b = _ / i * Math.PI * 2,
                            w = -t * Math.cos(b);
                        b = t * Math.sin(b), d.x = m.x + (w * x.x + b * v.x), d.y = m.y + (w * x.y + b * v.y), d.z = m.z + (w * x.z + b * v.z), h.push(d.x, d.y, d.z), f.subVectors(d, m).normalize(), u.push(f.x, f.y, f.z), p.push(s / n), p.push(_ / i) } } for (_ = 1; _ <= n; _++)
                    for (s = 1; s <= i; s++) e = (i + 1) * _ + (s - 1), t = (i + 1) * _ + s, r = (i + 1) * (_ - 1) + s, c.push((i + 1) * (_ - 1) + (s - 1), e, r), c.push(e, t, r);
                this.setIndex(c), this.setAttribute("position", new B(h, 3)), this.setAttribute("normal", new B(u, 3)), this.setAttribute("uv", new B(p, 2)) }

            function Tn(e, t, n, i, r) { j.call(this), this.type = "TorusGeometry", this.parameters = { radius: e, tube: t, radialSegments: n, tubularSegments: i, arc: r }, this.fromBufferGeometry(new En(e, t, n, i, r)), this.mergeVertices() }

            function En(e, t, n, i, r) { G.call(this), this.type = "TorusBufferGeometry", this.parameters = { radius: e, tube: t, radialSegments: n, tubularSegments: i, arc: r }, e = e || 1, t = t || .4, n = Math.floor(n) || 8, i = Math.floor(i) || 6, r = r || 2 * Math.PI; var a, o, s = [],
                    c = [],
                    h = [],
                    u = [],
                    p = new l,
                    d = new l,
                    f = new l; for (a = 0; a <= n; a++)
                    for (o = 0; o <= i; o++) { var m = o / i * r,
                            g = a / n * Math.PI * 2;
                        d.x = (e + t * Math.cos(g)) * Math.cos(m), d.y = (e + t * Math.cos(g)) * Math.sin(m), d.z = t * Math.sin(g), c.push(d.x, d.y, d.z), p.x = e * Math.cos(m), p.y = e * Math.sin(m), f.subVectors(d, p).normalize(), h.push(f.x, f.y, f.z), u.push(o / i), u.push(a / n) }
                for (a = 1; a <= n; a++)
                    for (o = 1; o <= i; o++) e = (i + 1) * (a - 1) + o - 1, t = (i + 1) * (a - 1) + o, r = (i + 1) * a + o, s.push((i + 1) * a + o - 1, e, r), s.push(e, t, r);
                this.setIndex(s), this.setAttribute("position", new B(c, 3)), this.setAttribute("normal", new B(h, 3)), this.setAttribute("uv", new B(u, 2)) }

            function An(e, t, n, i, r) { for (var a, o = 0, s = t, c = n - i; s < n; s += i) o += (e[c] - e[s]) * (e[s + 1] + e[c + 1]), c = s; if (r === 0 < o)
                    for (r = t; r < n; r += i) a = kn(r, e[r], e[r + 1], a);
                else
                    for (r = n - i; r >= t; r -= i) a = kn(r, e[r], e[r + 1], a); return a && Bn(a, a.next) && (Vn(a), a = a.next), a }

            function Ln(e, t) { if (!e) return e;
                t || (t = e);
                do { var n = !1; if (e.steiner || !Bn(e, e.next) && 0 !== Nn(e.prev, e, e.next)) e = e.next;
                    else { if (Vn(e), (e = t = e.prev) === e.next) break;
                        n = !0 } } while (n || e !== t); return t }

            function Rn(e, t, n, i) { var r = e.prev,
                    a = e.next; if (0 <= Nn(r, e, a)) return !1; var o = r.x > e.x ? r.x > a.x ? r.x : a.x : e.x > a.x ? e.x : a.x,
                    s = r.y > e.y ? r.y > a.y ? r.y : a.y : e.y > a.y ? e.y : a.y,
                    c = On(r.x < e.x ? r.x < a.x ? r.x : a.x : e.x < a.x ? e.x : a.x, r.y < e.y ? r.y < a.y ? r.y : a.y : e.y < a.y ? e.y : a.y, t, n, i); for (t = On(o, s, t, n, i), n = e.prevZ, i = e.nextZ; n && n.z >= c && i && i.z <= t;) { if (n !== e.prev && n !== e.next && In(r.x, r.y, e.x, e.y, a.x, a.y, n.x, n.y) && 0 <= Nn(n.prev, n, n.next)) return !1; if (n = n.prevZ, i !== e.prev && i !== e.next && In(r.x, r.y, e.x, e.y, a.x, a.y, i.x, i.y) && 0 <= Nn(i.prev, i, i.next)) return !1;
                    i = i.nextZ } for (; n && n.z >= c;) { if (n !== e.prev && n !== e.next && In(r.x, r.y, e.x, e.y, a.x, a.y, n.x, n.y) && 0 <= Nn(n.prev, n, n.next)) return !1;
                    n = n.prevZ } for (; i && i.z <= t;) { if (i !== e.prev && i !== e.next && In(r.x, r.y, e.x, e.y, a.x, a.y, i.x, i.y) && 0 <= Nn(i.prev, i, i.next)) return !1;
                    i = i.nextZ } return !0 }

            function Pn(e, t) { return e.x - t.x }

            function Cn(e, t) { var n = t,
                    i = e.x,
                    r = e.y,
                    a = -1 / 0;
                do { if (r <= n.y && r >= n.next.y && n.next.y !== n.y) { var o = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y); if (o <= i && o > a) { if (a = o, o === i) { if (r === n.y) return n; if (r === n.next.y) return n.next } var s = n.x < n.next.x ? n : n.next } } n = n.next } while (n !== t); if (!s) return null; if (i === a) return s;
                t = s, o = s.x; var c = s.y,
                    l = 1 / 0;
                n = s;
                do { if (i >= n.x && n.x >= o && i !== n.x && In(r < c ? i : a, r, o, c, r < c ? a : i, r, n.x, n.y)) { var h, u = Math.abs(r - n.y) / (i - n.x); if ((h = Gn(n, e)) && !(h = u < l) && (h = u === l) && !(h = n.x > s.x) && (h = n.x === s.x)) { var p = n;
                            h = 0 > Nn((h = s).prev, h, p.prev) && 0 > Nn(p.next, h, h.next) } h && (s = n, l = u) } n = n.next } while (n !== t); return s }

            function On(e, t, n, i, r) { return 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1) | (1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1 }

            function Dn(e) { var t = e,
                    n = e;
                do {
                    (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next } while (t !== e); return n }

            function In(e, t, n, i, r, a, o, s) { return 0 <= (r - o) * (t - s) - (e - o) * (a - s) && 0 <= (e - o) * (i - s) - (n - o) * (t - s) && 0 <= (n - o) * (a - s) - (r - o) * (i - s) }

            function Nn(e, t, n) { return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y) }

            function Bn(e, t) { return e.x === t.x && e.y === t.y }

            function zn(e, t, n, i) { var r = Fn(Nn(e, t, n)),
                    a = Fn(Nn(e, t, i)),
                    o = Fn(Nn(n, i, e)),
                    s = Fn(Nn(n, i, t)); return !!(r !== a && o !== s || 0 === r && Un(e, n, t) || 0 === a && Un(e, i, t) || 0 === o && Un(n, e, i) || 0 === s && Un(n, t, i)) }

            function Un(e, t, n) { return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y) }

            function Fn(e) { return 0 < e ? 1 : 0 > e ? -1 : 0 }

            function Gn(e, t) { return 0 > Nn(e.prev, e, e.next) ? 0 <= Nn(e, t, e.next) && 0 <= Nn(e, e.prev, t) : 0 > Nn(e, t, e.prev) || 0 > Nn(e, e.next, t) }

            function Hn(e, t) { var n = new jn(e.i, e.x, e.y),
                    i = new jn(t.i, t.x, t.y),
                    r = e.next,
                    a = t.prev; return e.next = t, t.prev = e, n.next = r, r.prev = n, i.next = n, n.prev = i, a.next = i, i.prev = a, i }

            function kn(e, t, n, i) { return e = new jn(e, t, n), i ? (e.next = i.next, e.prev = i, i.next.prev = e, i.next = e) : (e.prev = e, e.next = e), e }

            function Vn(e) { e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ) }

            function jn(e, t, n) { this.i = e, this.x = t, this.y = n, this.nextZ = this.prevZ = this.z = this.next = this.prev = null, this.steiner = !1 }

            function Wn(e) { var t = e.length;
                2 < t && e[t - 1].equals(e[0]) && e.pop() }

            function qn(e, t) { for (var n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y) }

            function Xn(e, t) { j.call(this), this.type = "ExtrudeGeometry", this.parameters = { shapes: e, options: t }, this.fromBufferGeometry(new Yn(e, t)), this.mergeVertices() }

            function Yn(e, t) {
                function i(e) {
                    function i(e, t, n) { return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(n).add(e) }

                    function s(e, t, i) { var r = e.x - t.x,
                            a = e.y - t.y,
                            o = i.x - e.x,
                            s = i.y - e.y,
                            c = r * r + a * a; if (Math.abs(r * s - a * o) > Number.EPSILON) { var l = Math.sqrt(c),
                                h = Math.sqrt(o * o + s * s); if (c = t.x - a / l, t = t.y + r / l, 2 >= (a = (o = c + r * (s = ((i.x - s / h - c) * s - (i.y + o / h - t) * o) / (r * s - a * o)) - e.x) * o + (r = t + a * s - e.y) * r)) return new n(o, r);
                            a = Math.sqrt(a / 2) } else e = !1, r > Number.EPSILON ? o > Number.EPSILON && (e = !0) : r < -Number.EPSILON ? o < -Number.EPSILON && (e = !0) : Math.sign(a) === Math.sign(s) && (e = !0), e ? (o = -a, a = Math.sqrt(c)) : (o = r, r = a, a = Math.sqrt(c / 2)); return new n(o / a, r / a) }

                    function c(e, t) { for (H = e.length; 0 <= --H;) { var n = H,
                                i = H - 1;
                            0 > i && (i = e.length - 1); var o, s = g + 2 * w; for (o = 0; o < s; o++) { var c = F * o,
                                    l = F * (o + 1),
                                    h = t + i + c,
                                    u = t + i + l;
                                l = t + n + l, p(t + n + c), p(h), p(l), p(h), p(u), p(l), c = a.length / 3, d((c = S.generateSideWallUV(r, a, c - 6, c - 3, c - 2, c - 1))[0]), d(c[1]), d(c[3]), d(c[1]), d(c[2]), d(c[3]) } } }

                    function h(e, t, n) { f.push(e), f.push(t), f.push(n) }

                    function u(e, t, n) { p(e), p(t), p(n), e = a.length / 3, d((e = S.generateTopUV(r, a, e - 3, e - 2, e - 1))[0]), d(e[1]), d(e[2]) }

                    function p(e) { a.push(f[3 * e]), a.push(f[3 * e + 1]), a.push(f[3 * e + 2]) }

                    function d(e) { o.push(e.x), o.push(e.y) } var f = [],
                        m = void 0 !== t.curveSegments ? t.curveSegments : 12,
                        g = void 0 !== t.steps ? t.steps : 1,
                        v = void 0 !== t.depth ? t.depth : 100,
                        y = void 0 === t.bevelEnabled || t.bevelEnabled,
                        x = void 0 !== t.bevelThickness ? t.bevelThickness : 6,
                        _ = void 0 !== t.bevelSize ? t.bevelSize : x - 2,
                        b = void 0 !== t.bevelOffset ? t.bevelOffset : 0,
                        w = void 0 !== t.bevelSegments ? t.bevelSegments : 3,
                        M = t.extrudePath,
                        S = void 0 !== t.UVGenerator ? t.UVGenerator : Ec;
                    void 0 !== t.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), v = t.amount); var T, E = !1; if (M) { var A = M.getSpacedPoints(g);
                        E = !0, y = !1; var L = M.computeFrenetFrames(g, !1),
                            R = new l,
                            P = new l,
                            C = new l } y || (b = _ = x = w = 0), m = e.extractPoints(m), e = m.shape; var O = m.holes; if (!Tc.isClockWise(e)) { e = e.reverse(); var D = 0; for (T = O.length; D < T; D++) { var I = O[D];
                            Tc.isClockWise(I) && (O[D] = I.reverse()) } } var N = Tc.triangulateShape(e, O),
                        B = e; for (D = 0, T = O.length; D < T; D++) I = O[D], e = e.concat(I); var z, U, F = e.length,
                        G = N.length;
                    m = []; var H = 0,
                        k = B.length,
                        V = k - 1; for (z = H + 1; H < k; H++, V++, z++) V === k && (V = 0), z === k && (z = 0), m[H] = s(B[H], B[V], B[z]);
                    M = []; var j = m.concat(); for (D = 0, T = O.length; D < T; D++) { I = O[D]; var W = []; for (H = 0, V = (k = I.length) - 1, z = H + 1; H < k; H++, V++, z++) V === k && (V = 0), z === k && (z = 0), W[H] = s(I[H], I[V], I[z]);
                        M.push(W), j = j.concat(W) } for (V = 0; V < w; V++) { k = V / w; var q = x * Math.cos(k * Math.PI / 2); for (z = _ * Math.sin(k * Math.PI / 2) + b, H = 0, k = B.length; H < k; H++) { var X = i(B[H], m[H], z);
                            h(X.x, X.y, -q) } for (D = 0, T = O.length; D < T; D++)
                            for (I = O[D], W = M[D], H = 0, k = I.length; H < k; H++) h((X = i(I[H], W[H], z)).x, X.y, -q) } for (z = _ + b, H = 0; H < F; H++) X = y ? i(e[H], j[H], z) : e[H], E ? (P.copy(L.normals[0]).multiplyScalar(X.x), R.copy(L.binormals[0]).multiplyScalar(X.y), C.copy(A[0]).add(P).add(R), h(C.x, C.y, C.z)) : h(X.x, X.y, 0); for (k = 1; k <= g; k++)
                        for (H = 0; H < F; H++) X = y ? i(e[H], j[H], z) : e[H], E ? (P.copy(L.normals[k]).multiplyScalar(X.x), R.copy(L.binormals[k]).multiplyScalar(X.y), C.copy(A[k]).add(P).add(R), h(C.x, C.y, C.z)) : h(X.x, X.y, v / g * k); for (V = w - 1; 0 <= V; V--) { for (k = V / w, q = x * Math.cos(k * Math.PI / 2), z = _ * Math.sin(k * Math.PI / 2) + b, H = 0, k = B.length; H < k; H++) h((X = i(B[H], m[H], z)).x, X.y, v + q); for (D = 0, T = O.length; D < T; D++)
                            for (I = O[D], W = M[D], H = 0, k = I.length; H < k; H++) X = i(I[H], W[H], z), E ? h(X.x, X.y + A[g - 1].y, A[g - 1].x + q) : h(X.x, X.y, v + q) }! function() { var e = a.length / 3; if (y) { var t = 0 * F; for (H = 0; H < G; H++) u((U = N[H])[2] + t, U[1] + t, U[0] + t); for (t = F * (g + 2 * w), H = 0; H < G; H++) u((U = N[H])[0] + t, U[1] + t, U[2] + t) } else { for (H = 0; H < G; H++) u((U = N[H])[2], U[1], U[0]); for (H = 0; H < G; H++) u((U = N[H])[0] + F * g, U[1] + F * g, U[2] + F * g) } r.addGroup(e, a.length / 3 - e, 0) }(),
                    function() { var e = a.length / 3,
                            t = 0; for (c(B, t), t += B.length, D = 0, T = O.length; D < T; D++) c(I = O[D], t), t += I.length;
                        r.addGroup(e, a.length / 3 - e, 1) }() } G.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = { shapes: e, options: t }, e = Array.isArray(e) ? e : [e]; for (var r = this, a = [], o = [], s = 0, c = e.length; s < c; s++) i(e[s]);
                this.setAttribute("position", new B(a, 3)), this.setAttribute("uv", new B(o, 2)), this.computeVertexNormals() }

            function Zn(e, t, n) { if (n.shapes = [], Array.isArray(e))
                    for (var i = 0, r = e.length; i < r; i++) n.shapes.push(e[i].uuid);
                else n.shapes.push(e.uuid); return void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON()), n }

            function Jn(e, t) { j.call(this), this.type = "TextGeometry", this.parameters = { text: e, parameters: t }, this.fromBufferGeometry(new Qn(e, t)), this.mergeVertices() }

            function Qn(e, t) { var n = (t = t || {}).font; if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new j;
                e = n.generateShapes(e, t.size), t.depth = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), Yn.call(this, e, t), this.type = "TextBufferGeometry" }

            function Kn(e, t, n, i, r, a, o) { j.call(this), this.type = "SphereGeometry", this.parameters = { radius: e, widthSegments: t, heightSegments: n, phiStart: i, phiLength: r, thetaStart: a, thetaLength: o }, this.fromBufferGeometry(new $n(e, t, n, i, r, a, o)), this.mergeVertices() }

            function $n(e, t, n, i, r, a, o) { G.call(this), this.type = "SphereBufferGeometry", this.parameters = { radius: e, widthSegments: t, heightSegments: n, phiStart: i, phiLength: r, thetaStart: a, thetaLength: o }, e = e || 1, t = Math.max(3, Math.floor(t) || 8), n = Math.max(2, Math.floor(n) || 6), i = void 0 !== i ? i : 0, r = void 0 !== r ? r : 2 * Math.PI, a = void 0 !== a ? a : 0, o = void 0 !== o ? o : Math.PI; var s, c, h = Math.min(a + o, Math.PI),
                    u = 0,
                    p = [],
                    d = new l,
                    f = new l,
                    m = [],
                    g = [],
                    v = [],
                    y = []; for (c = 0; c <= n; c++) { var x = [],
                        _ = c / n,
                        b = 0; for (0 == c && 0 == a ? b = .5 / t : c == n && h == Math.PI && (b = -.5 / t), s = 0; s <= t; s++) { var w = s / t;
                        d.x = -e * Math.cos(i + w * r) * Math.sin(a + _ * o), d.y = e * Math.cos(a + _ * o), d.z = e * Math.sin(i + w * r) * Math.sin(a + _ * o), g.push(d.x, d.y, d.z), f.copy(d).normalize(), v.push(f.x, f.y, f.z), y.push(w + b, 1 - _), x.push(u++) } p.push(x) } for (c = 0; c < n; c++)
                    for (s = 0; s < t; s++) e = p[c][s + 1], i = p[c][s], r = p[c + 1][s], o = p[c + 1][s + 1], (0 !== c || 0 < a) && m.push(e, i, o), (c !== n - 1 || h < Math.PI) && m.push(i, r, o);
                this.setIndex(m), this.setAttribute("position", new B(g, 3)), this.setAttribute("normal", new B(v, 3)), this.setAttribute("uv", new B(y, 2)) }

            function ei(e, t, n, i, r, a) { j.call(this), this.type = "RingGeometry", this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: n, phiSegments: i, thetaStart: r, thetaLength: a }, this.fromBufferGeometry(new ti(e, t, n, i, r, a)), this.mergeVertices() }

            function ti(e, t, i, r, a, o) { G.call(this), this.type = "RingBufferGeometry", this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: i, phiSegments: r, thetaStart: a, thetaLength: o }, e = e || .5, t = t || 1, a = void 0 !== a ? a : 0, o = void 0 !== o ? o : 2 * Math.PI, i = void 0 !== i ? Math.max(3, i) : 8; var s, c, h = [],
                    u = [],
                    p = [],
                    d = [],
                    f = e,
                    m = (t - e) / (r = void 0 !== r ? Math.max(1, r) : 1),
                    g = new l,
                    v = new n; for (s = 0; s <= r; s++) { for (c = 0; c <= i; c++) e = a + c / i * o, g.x = f * Math.cos(e), g.y = f * Math.sin(e), u.push(g.x, g.y, g.z), p.push(0, 0, 1), v.x = (g.x / t + 1) / 2, v.y = (g.y / t + 1) / 2, d.push(v.x, v.y);
                    f += m } for (s = 0; s < r; s++)
                    for (t = s * (i + 1), c = 0; c < i; c++) a = (e = c + t) + i + 1, o = e + i + 2, f = e + 1, h.push(e, a, f), h.push(a, o, f);
                this.setIndex(h), this.setAttribute("position", new B(u, 3)), this.setAttribute("normal", new B(p, 3)), this.setAttribute("uv", new B(d, 2)) }

            function ni(e, t, n, i) { j.call(this), this.type = "LatheGeometry", this.parameters = { points: e, segments: t, phiStart: n, phiLength: i }, this.fromBufferGeometry(new ii(e, t, n, i)), this.mergeVertices() }

            function ii(e, t, i, r) { G.call(this), this.type = "LatheBufferGeometry", this.parameters = { points: e, segments: t, phiStart: i, phiLength: r }, t = Math.floor(t) || 12, i = i || 0, r = r || 2 * Math.PI, r = Ra.clamp(r, 0, 2 * Math.PI); var a, o = [],
                    s = [],
                    c = [],
                    h = 1 / t,
                    u = new l,
                    p = new n; for (a = 0; a <= t; a++) { var d = i + a * h * r,
                        f = Math.sin(d),
                        m = Math.cos(d); for (d = 0; d <= e.length - 1; d++) u.x = e[d].x * f, u.y = e[d].y, u.z = e[d].x * m, s.push(u.x, u.y, u.z), p.x = a / t, p.y = d / (e.length - 1), c.push(p.x, p.y) } for (a = 0; a < t; a++)
                    for (d = 0; d < e.length - 1; d++) h = (i = d + a * e.length) + e.length, u = i + e.length + 1, p = i + 1, o.push(i, h, p), o.push(h, u, p); if (this.setIndex(o), this.setAttribute("position", new B(s, 3)), this.setAttribute("uv", new B(c, 2)), this.computeVertexNormals(), r === 2 * Math.PI)
                    for (r = this.attributes.normal.array, o = new l, s = new l, c = new l, i = t * e.length * 3, d = a = 0; a < e.length; a++, d += 3) o.x = r[d + 0], o.y = r[d + 1], o.z = r[d + 2], s.x = r[i + d + 0], s.y = r[i + d + 1], s.z = r[i + d + 2], c.addVectors(o, s).normalize(), r[d + 0] = r[i + d + 0] = c.x, r[d + 1] = r[i + d + 1] = c.y, r[d + 2] = r[i + d + 2] = c.z }

            function ri(e, t) { j.call(this), this.type = "ShapeGeometry", "object" == typeof t && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), t = t.curveSegments), this.parameters = { shapes: e, curveSegments: t }, this.fromBufferGeometry(new ai(e, t)), this.mergeVertices() }

            function ai(e, t) {
                function n(e) { var n, s = r.length / 3,
                        l = (e = e.extractPoints(t)).shape,
                        h = e.holes; for (!1 === Tc.isClockWise(l) && (l = l.reverse()), e = 0, n = h.length; e < n; e++) { var u = h[e];!0 === Tc.isClockWise(u) && (h[e] = u.reverse()) } var p = Tc.triangulateShape(l, h); for (e = 0, n = h.length; e < n; e++) u = h[e], l = l.concat(u); for (e = 0, n = l.length; e < n; e++) u = l[e], r.push(u.x, u.y, 0), a.push(0, 0, 1), o.push(u.x, u.y); for (e = 0, n = p.length; e < n; e++) l = p[e], i.push(l[0] + s, l[1] + s, l[2] + s), c += 3 } G.call(this), this.type = "ShapeBufferGeometry", this.parameters = { shapes: e, curveSegments: t }, t = t || 12; var i = [],
                    r = [],
                    a = [],
                    o = [],
                    s = 0,
                    c = 0; if (!1 === Array.isArray(e)) n(e);
                else
                    for (var l = 0; l < e.length; l++) n(e[l]), this.addGroup(s, c, l), s += c, c = 0;
                this.setIndex(i), this.setAttribute("position", new B(r, 3)), this.setAttribute("normal", new B(a, 3)), this.setAttribute("uv", new B(o, 2)) }

            function oi(e, t) { if (t.shapes = [], Array.isArray(e))
                    for (var n = 0, i = e.length; n < i; n++) t.shapes.push(e[n].uuid);
                else t.shapes.push(e.uuid); return t }

            function si(e, t) { G.call(this), this.type = "EdgesGeometry", this.parameters = { thresholdAngle: t }; var n = [];
                t = Math.cos(Ra.DEG2RAD * (void 0 !== t ? t : 1)); var i = [0, 0],
                    r = {},
                    a = ["a", "b", "c"]; if (e.isBufferGeometry) { var o = new j;
                    o.fromBufferGeometry(e) } else o = e.clone();
                o.mergeVertices(), o.computeFaceNormals(), e = o.vertices; for (var s = 0, c = (o = o.faces).length; s < c; s++)
                    for (var l = o[s], h = 0; 3 > h; h++) { var u = l[a[h]],
                            p = l[a[(h + 1) % 3]];
                        i[0] = Math.min(u, p), i[1] = Math.max(u, p), void 0 === r[u = i[0] + "," + i[1]] ? r[u] = { index1: i[0], index2: i[1], face1: s, face2: void 0 } : r[u].face2 = s }
                for (u in r)(void 0 === (i = r[u]).face2 || o[i.face1].normal.dot(o[i.face2].normal) <= t) && (a = e[i.index1], n.push(a.x, a.y, a.z), a = e[i.index2], n.push(a.x, a.y, a.z));
                this.setAttribute("position", new B(n, 3)) }

            function ci(e, t, n, i, r, a, o, s) { j.call(this), this.type = "CylinderGeometry", this.parameters = { radiusTop: e, radiusBottom: t, height: n, radialSegments: i, heightSegments: r, openEnded: a, thetaStart: o, thetaLength: s }, this.fromBufferGeometry(new li(e, t, n, i, r, a, o, s)), this.mergeVertices() }

            function li(e, t, i, r, a, o, s, c) {
                function h(i) { var a, o = new n,
                        h = new l,
                        v = 0,
                        _ = !0 === i ? e : t,
                        b = !0 === i ? 1 : -1,
                        w = g; for (a = 1; a <= r; a++) d.push(0, y * b, 0), f.push(0, b, 0), m.push(.5, .5), g++; var M = g; for (a = 0; a <= r; a++) { var S = a / r * c + s,
                            T = Math.cos(S);
                        S = Math.sin(S), h.x = _ * S, h.y = y * b, h.z = _ * T, d.push(h.x, h.y, h.z), f.push(0, b, 0), o.x = .5 * T + .5, o.y = .5 * S * b + .5, m.push(o.x, o.y), g++ } for (a = 0; a < r; a++) o = w + a, h = M + a, !0 === i ? p.push(h, h + 1, o) : p.push(h + 1, h, o), v += 3;
                    u.addGroup(x, v, !0 === i ? 1 : 2), x += v } G.call(this), this.type = "CylinderBufferGeometry", this.parameters = { radiusTop: e, radiusBottom: t, height: i, radialSegments: r, heightSegments: a, openEnded: o, thetaStart: s, thetaLength: c }; var u = this;
                e = void 0 !== e ? e : 1, t = void 0 !== t ? t : 1, i = i || 1, r = Math.floor(r) || 8, a = Math.floor(a) || 1, o = void 0 !== o && o, s = void 0 !== s ? s : 0, c = void 0 !== c ? c : 2 * Math.PI; var p = [],
                    d = [],
                    f = [],
                    m = [],
                    g = 0,
                    v = [],
                    y = i / 2,
                    x = 0;! function() { var n, o, h = new l,
                        _ = new l,
                        b = 0,
                        w = (t - e) / i; for (o = 0; o <= a; o++) { var M = [],
                            S = o / a,
                            T = S * (t - e) + e; for (n = 0; n <= r; n++) { var E = n / r,
                                A = E * c + s,
                                L = Math.sin(A);
                            A = Math.cos(A), _.x = T * L, _.y = -S * i + y, _.z = T * A, d.push(_.x, _.y, _.z), h.set(L, w, A).normalize(), f.push(h.x, h.y, h.z), m.push(E, 1 - S), M.push(g++) } v.push(M) } for (n = 0; n < r; n++)
                        for (o = 0; o < a; o++) h = v[o + 1][n], _ = v[o + 1][n + 1], w = v[o][n + 1], p.push(v[o][n], h, w), p.push(h, _, w), b += 6;
                    u.addGroup(x, b, 0), x += b }(), !1 === o && (0 < e && h(!0), 0 < t && h(!1)), this.setIndex(p), this.setAttribute("position", new B(d, 3)), this.setAttribute("normal", new B(f, 3)), this.setAttribute("uv", new B(m, 2)) }

            function hi(e, t, n, i, r, a, o) { ci.call(this, 0, e, t, n, i, r, a, o), this.type = "ConeGeometry", this.parameters = { radius: e, height: t, radialSegments: n, heightSegments: i, openEnded: r, thetaStart: a, thetaLength: o } }

            function ui(e, t, n, i, r, a, o) { li.call(this, 0, e, t, n, i, r, a, o), this.type = "ConeBufferGeometry", this.parameters = { radius: e, height: t, radialSegments: n, heightSegments: i, openEnded: r, thetaStart: a, thetaLength: o } }

            function pi(e, t, n, i) { j.call(this), this.type = "CircleGeometry", this.parameters = { radius: e, segments: t, thetaStart: n, thetaLength: i }, this.fromBufferGeometry(new di(e, t, n, i)), this.mergeVertices() }

            function di(e, t, i, r) { G.call(this), this.type = "CircleBufferGeometry", this.parameters = { radius: e, segments: t, thetaStart: i, thetaLength: r }, e = e || 1, t = void 0 !== t ? Math.max(3, t) : 8, i = void 0 !== i ? i : 0, r = void 0 !== r ? r : 2 * Math.PI; var a, o = [],
                    s = [],
                    c = [],
                    h = [],
                    u = new l,
                    p = new n;
                s.push(0, 0, 0), c.push(0, 0, 1), h.push(.5, .5); var d = 0; for (a = 3; d <= t; d++, a += 3) { var f = i + d / t * r;
                    u.x = e * Math.cos(f), u.y = e * Math.sin(f), s.push(u.x, u.y, u.z), c.push(0, 0, 1), p.x = (s[a] / e + 1) / 2, p.y = (s[a + 1] / e + 1) / 2, h.push(p.x, p.y) } for (a = 1; a <= t; a++) o.push(a, a + 1, 0);
                this.setIndex(o), this.setAttribute("position", new B(s, 3)), this.setAttribute("normal", new B(c, 3)), this.setAttribute("uv", new B(h, 2)) }

            function fi(e) { E.call(this), this.type = "ShadowMaterial", this.color = new b(0), this.transparent = !0, this.setValues(e) }

            function mi(e) { X.call(this, e), this.type = "RawShaderMaterial" }

            function gi(e) { E.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new b(16777215), this.roughness = 1, this.metalness = 0, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new b(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.vertexTangents = this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e) }

            function vi(e) { gi.call(this), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new n(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, this.sheen = null, this.transparency = 0, this.setValues(e) }

            function yi(e) { E.call(this), this.type = "MeshPhongMaterial", this.color = new b(16777215), this.specular = new b(1118481), this.shininess = 30, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new b(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e) }

            function xi(e) { E.call(this), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new b(16777215), this.specular = new b(1118481), this.shininess = 30, this.lightMap = this.gradientMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new b(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = this.specularMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e) }

            function _i(e) { E.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.fog = !1, this.setValues(e) }

            function bi(e) { E.call(this), this.type = "MeshLambertMaterial", this.color = new b(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new b(0), this.emissiveIntensity = 1, this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e) }

            function wi(e) { E.call(this), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new b(16777215), this.bumpMap = this.map = this.matcap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e) }

            function Mi(e) { Jt.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e) }

            function Si(e, t, n, i) { this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n }

            function Ti(e, t, n, i) { Si.call(this, e, t, n, i), this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0 }

            function Ei(e, t, n, i) { Si.call(this, e, t, n, i) }

            function Ai(e, t, n, i) { Si.call(this, e, t, n, i) }

            function Li(e, t, n, i) { if (void 0 === e) throw Error("THREE.KeyframeTrack: track name is undefined"); if (void 0 === t || 0 === t.length) throw Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                this.name = e, this.times = Rc.convertArray(t, this.TimeBufferType), this.values = Rc.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation) }

            function Ri(e, t, n) { Li.call(this, e, t, n) }

            function Pi(e, t, n, i) { Li.call(this, e, t, n, i) }

            function Ci(e, t, n, i) { Li.call(this, e, t, n, i) }

            function Oi(e, t, n, i) { Si.call(this, e, t, n, i) }

            function Di(e, t, n, i) { Li.call(this, e, t, n, i) }

            function Ii(e, t, n, i) { Li.call(this, e, t, n, i) }

            function Ni(e, t, n, i) { Li.call(this, e, t, n, i) }

            function Bi(e, t, n, i) { this.name = e, this.tracks = n, this.duration = void 0 !== t ? t : -1, this.blendMode = void 0 !== i ? i : 2500, this.uuid = Ra.generateUUID(), 0 > this.duration && this.resetDuration() }

            function zi(e) { if (void 0 === e.type) throw Error("THREE.KeyframeTrack: track type undefined, can not parse"); var t = function(e) { switch (e.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return Ci;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return Ni;
                        case "color":
                            return Pi;
                        case "quaternion":
                            return Di;
                        case "bool":
                        case "boolean":
                            return Ri;
                        case "string":
                            return Ii } throw Error("THREE.KeyframeTrack: Unsupported typeName: " + e) }(e.type); if (void 0 === e.times) { var n = [],
                        i = [];
                    Rc.flattenJSON(e.keys, n, i, "value"), e.times = n, e.values = i } return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation) }

            function Ui(e, t, n) { var i = this,
                    r = !1,
                    a = 0,
                    o = 0,
                    s = void 0,
                    c = [];
                this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(e) { o++, !1 === r && void 0 !== i.onStart && i.onStart(e, a, o), r = !0 }, this.itemEnd = function(e) { a++, void 0 !== i.onProgress && i.onProgress(e, a, o), a === o && (r = !1, void 0 !== i.onLoad) && i.onLoad() }, this.itemError = function(e) { void 0 !== i.onError && i.onError(e) }, this.resolveURL = function(e) { return s ? s(e) : e }, this.setURLModifier = function(e) { return s = e, this }, this.addHandler = function(e, t) { return c.push(e, t), this }, this.removeHandler = function(e) { return -1 !== (e = c.indexOf(e)) && c.splice(e, 2), this }, this.getHandler = function(e) { for (var t = 0, n = c.length; t < n; t += 2) { var i = c[t],
                            r = c[t + 1]; if (i.global && (i.lastIndex = 0), i.test(e)) return r } return null } }

            function Fi(e) { this.manager = void 0 !== e ? e : Cc, this.crossOrigin = "anonymous", this.resourcePath = this.path = "", this.requestHeader = {} }

            function Gi(e) { Fi.call(this, e) }

            function Hi(e) { Fi.call(this, e) }

            function ki(e) { Fi.call(this, e) }

            function Vi(e) { Fi.call(this, e) }

            function ji(e) { Fi.call(this, e) }

            function Wi(e) { Fi.call(this, e) }

            function qi(e) { Fi.call(this, e) }

            function Xi() { this.type = "Curve", this.arcLengthDivisions = 200 }

            function Yi(e, t, n, i, r, a, o, s) { Xi.call(this), this.type = "EllipseCurve", this.aX = e || 0, this.aY = t || 0, this.xRadius = n || 1, this.yRadius = i || 1, this.aStartAngle = r || 0, this.aEndAngle = a || 2 * Math.PI, this.aClockwise = o || !1, this.aRotation = s || 0 }

            function Zi(e, t, n, i, r, a) { Yi.call(this, e, t, n, n, i, r, a), this.type = "ArcCurve" }

            function Ji() { var e = 0,
                    t = 0,
                    n = 0,
                    i = 0; return { initCatmullRom: function(r, a, o, s, c) { e = a, t = r = c * (o - r), n = -3 * a + 3 * o - 2 * r - (s = c * (s - a)), i = 2 * a - 2 * o + r + s }, initNonuniformCatmullRom: function(r, a, o, s, c, l, h) { e = a, t = r = ((a - r) / c - (o - r) / (c + l) + (o - a) / l) * l, n = -3 * a + 3 * o - 2 * r - (s = ((o - a) / l - (s - a) / (l + h) + (s - o) / h) * l), i = 2 * a - 2 * o + r + s }, calc: function(r) { var a = r * r; return e + t * r + n * a + i * a * r } } }

            function Qi(e, t, n, i) { Xi.call(this), this.type = "CatmullRomCurve3", this.points = e || [], this.closed = t || !1, this.curveType = n || "centripetal", this.tension = i || .5 }

            function Ki(e, t, n, i, r) { var a = e * e; return (2 * n - 2 * i + (t = .5 * (i - t)) + (r = .5 * (r - n))) * e * a + (-3 * n + 3 * i - 2 * t - r) * a + t * e + n }

            function $i(e, t, n, i) { var r = 1 - e; return r * r * t + 2 * (1 - e) * e * n + e * e * i }

            function er(e, t, n, i, r) { var a = 1 - e,
                    o = 1 - e; return a * a * a * t + 3 * o * o * e * n + 3 * (1 - e) * e * e * i + e * e * e * r }

            function tr(e, t, i, r) { Xi.call(this), this.type = "CubicBezierCurve", this.v0 = e || new n, this.v1 = t || new n, this.v2 = i || new n, this.v3 = r || new n }

            function nr(e, t, n, i) { Xi.call(this), this.type = "CubicBezierCurve3", this.v0 = e || new l, this.v1 = t || new l, this.v2 = n || new l, this.v3 = i || new l }

            function ir(e, t) { Xi.call(this), this.type = "LineCurve", this.v1 = e || new n, this.v2 = t || new n }

            function rr(e, t) { Xi.call(this), this.type = "LineCurve3", this.v1 = e || new l, this.v2 = t || new l }

            function ar(e, t, i) { Xi.call(this), this.type = "QuadraticBezierCurve", this.v0 = e || new n, this.v1 = t || new n, this.v2 = i || new n }

            function or(e, t, n) { Xi.call(this), this.type = "QuadraticBezierCurve3", this.v0 = e || new l, this.v1 = t || new l, this.v2 = n || new l }

            function sr(e) { Xi.call(this), this.type = "SplineCurve", this.points = e || [] }

            function cr() { Xi.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1 }

            function lr(e) { cr.call(this), this.type = "Path", this.currentPoint = new n, e && this.setFromPoints(e) }

            function hr(e) { lr.call(this, e), this.uuid = Ra.generateUUID(), this.type = "Shape", this.holes = [] }

            function ur(e, t) { d.call(this), this.type = "Light", this.color = new b(e), this.intensity = void 0 !== t ? t : 1, this.receiveShadow = void 0 }

            function pr(e, t, n) { ur.call(this, e, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(d.DefaultUp), this.updateMatrix(), this.groundColor = new b(t) }

            function dr(e) { this.camera = e, this.bias = 0, this.radius = 1, this.mapSize = new n(512, 512), this.mapPass = this.map = null, this.matrix = new h, this._frustum = new $, this._frameExtents = new n(1, 1), this._viewportCount = 1, this._viewports = [new a(0, 0, 1, 1)] }

            function fr() { dr.call(this, new Z(50, 1, .5, 500)) }

            function mr(e, t, n, i, r, a) { ur.call(this, e, t), this.type = "SpotLight", this.position.copy(d.DefaultUp), this.updateMatrix(), this.target = new d, Object.defineProperty(this, "power", { get: function() { return this.intensity * Math.PI }, set: function(e) { this.intensity = e / Math.PI } }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== i ? i : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== a ? a : 1, this.shadow = new fr }

            function gr() { dr.call(this, new Z(90, 1, .5, 500)), this._frameExtents = new n(4, 2), this._viewportCount = 6, this._viewports = [new a(2, 1, 1, 1), new a(0, 1, 1, 1), new a(3, 1, 1, 1), new a(1, 1, 1, 1), new a(3, 0, 1, 1), new a(1, 0, 1, 1)], this._cubeDirections = [new l(1, 0, 0), new l(-1, 0, 0), new l(0, 0, 1), new l(0, 0, -1), new l(0, 1, 0), new l(0, -1, 0)], this._cubeUps = [new l(0, 1, 0), new l(0, 1, 0), new l(0, 1, 0), new l(0, 1, 0), new l(0, 0, 1), new l(0, 0, -1)] }

            function vr(e, t, n, i) { ur.call(this, e, t), this.type = "PointLight", Object.defineProperty(this, "power", { get: function() { return 4 * this.intensity * Math.PI }, set: function(e) { this.intensity = e / (4 * Math.PI) } }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== i ? i : 1, this.shadow = new gr }

            function yr(e, t, n, i, r, a) { Y.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== e ? e : -1, this.right = void 0 !== t ? t : 1, this.top = void 0 !== n ? n : 1, this.bottom = void 0 !== i ? i : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== a ? a : 2e3, this.updateProjectionMatrix() }

            function xr() { dr.call(this, new yr(-5, 5, 5, -5, .5, 500)) }

            function _r(e, t) { ur.call(this, e, t), this.type = "DirectionalLight", this.position.copy(d.DefaultUp), this.updateMatrix(), this.target = new d, this.shadow = new xr }

            function br(e, t) { ur.call(this, e, t), this.type = "AmbientLight", this.castShadow = void 0 }

            function wr(e, t, n, i) { ur.call(this, e, t), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== i ? i : 10 }

            function Mr() { this.coefficients = []; for (var e = 0; 9 > e; e++) this.coefficients.push(new l) }

            function Sr(e, t) { ur.call(this, void 0, t), this.type = "LightProbe", this.sh = void 0 !== e ? e : new Mr }

            function Tr(e) { Fi.call(this, e), this.textures = {} }

            function Er() { G.call(this), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 }

            function Ar(e, t, n, i) { "number" == typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), L.call(this, e, t, n), this.meshPerAttribute = i || 1 }

            function Lr(e) { Fi.call(this, e) }

            function Rr(e) { Fi.call(this, e) }

            function Pr(e) { "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), Fi.call(this, e), this.options = void 0 }

            function Cr() { this.type = "ShapePath", this.color = new b, this.subPaths = [], this.currentPath = null }

            function Or(e) { this.type = "Font", this.data = e }

            function Dr(e) { Fi.call(this, e) }

            function Ir(e) { Fi.call(this, e) }

            function Nr(e, t, n) { Sr.call(this, void 0, n), e = (new b).set(e), n = (new b).set(t), t = new l(e.r, e.g, e.b), e = new l(n.r, n.g, n.b); var i = (n = Math.sqrt(Math.PI)) * Math.sqrt(.75);
                this.sh.coefficients[0].copy(t).add(e).multiplyScalar(n), this.sh.coefficients[1].copy(t).sub(e).multiplyScalar(i) }

            function Br(e, t) { Sr.call(this, void 0, t), e = (new b).set(e), this.sh.coefficients[0].set(e.r, e.g, e.b).multiplyScalar(2 * Math.sqrt(Math.PI)) }

            function zr() { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Z, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Z, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null } }

            function Ur(e) { this.autoStart = void 0 === e || e, this.elapsedTime = this.oldTime = this.startTime = 0, this.running = !1 }

            function Fr() { d.call(this), this.type = "AudioListener", this.context = jc.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Ur }

            function Gr(e) { d.call(this), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.offset = this.loopEnd = this.loopStart = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this._progress = this._startedAt = 0, this.filters = [] }

            function Hr(e) { Gr.call(this, e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain) }

            function kr(e, t) { this.analyser = e.context.createAnalyser(), this.analyser.fftSize = void 0 !== t ? t : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser) }

            function Vr(e, t, n) { switch (this.binding = e, this.valueSize = n, t) {
                    case "quaternion":
                        e = this._slerp, t = this._slerpAdditive; var i = this._setAdditiveIdentityQuaternion;
                        this.buffer = new Float64Array(6 * n), this._workIndex = 5; break;
                    case "string":
                    case "bool":
                        t = e = this._select, i = this._setAdditiveIdentityOther, this.buffer = Array(5 * n); break;
                    default:
                        e = this._lerp, t = this._lerpAdditive, i = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n) } this._mixBufferRegion = e, this._mixBufferRegionAdditive = t, this._setIdentity = i, this._origIndex = 3, this._addIndex = 4, this.referenceCount = this.useCount = this.cumulativeWeightAdditive = this.cumulativeWeight = 0 }

            function jr(e, t, n) { n = n || Wr.parseTrackName(t), this._targetGroup = e, this._bindings = e.subscribe_(t, n) }

            function Wr(e, t, n) { this.path = t, this.parsedPath = n || Wr.parseTrackName(t), this.node = Wr.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e }

            function qr() { this.uuid = Ra.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; var e = {};
                this._indicesByUUID = e; for (var t = 0, n = arguments.length; t !== n; ++t) e[arguments[t].uuid] = t;
                this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; var i = this;
                this.stats = { objects: { get total() { return i._objects.length }, get inUse() { return this.total - i.nCachedObjects_ } }, get bindingsPerObject() { return i._bindings.length } } }

            function Xr(e, t, n, i) { this._mixer = e, this._clip = t, this._localRoot = n || null, this.blendMode = i || t.blendMode, t = (e = t.tracks).length, n = Array(t), i = { endingStart: 2400, endingEnd: 2400 }; for (var r = 0; r !== t; ++r) { var a = e[r].createInterpolant(null);
                    n[r] = a, a.settings = i } this._interpolantSettings = i, this._interpolants = n, this._propertyBindings = Array(t), this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0 }

            function Yr(e) { this._root = e, this._initMemoryManager(), this.time = this._accuIndex = 0, this.timeScale = 1 }

            function Zr(e, t) { "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = t), this.value = e }

            function Jr(e, t, n) { Gt.call(this, e, t), this.meshPerAttribute = n || 1 }

            function Qr(e, t, n, i) { this.ray = new y(e, t), this.near = n || 0, this.far = i || 1 / 0, this.camera = null, this.layers = new p, this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} }, Object.defineProperties(this.params, { PointCloud: { get: function() { return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points } } }) }

            function Kr(e, t) { return e.distance - t.distance }

            function $r(e, t, n, i) { if (e.layers.test(t.layers) && e.raycast(t, n), !0 === i) { i = 0; for (var r = (e = e.children).length; i < r; i++) $r(e[i], t, n, !0) } }

            function ea(e, t, n) { return this.radius = void 0 !== e ? e : 1, this.phi = void 0 !== t ? t : 0, this.theta = void 0 !== n ? n : 0, this }

            function ta(e, t, n) { return this.radius = void 0 !== e ? e : 1, this.theta = void 0 !== t ? t : 0, this.y = void 0 !== n ? n : 0, this }

            function na(e, t) { this.min = void 0 !== e ? e : new n(1 / 0, 1 / 0), this.max = void 0 !== t ? t : new n(-1 / 0, -1 / 0) }

            function ia(e, t) { this.start = void 0 !== e ? e : new l, this.end = void 0 !== t ? t : new l }

            function ra(e) { d.call(this), this.material = e, this.render = function() {}, this.hasUvs = this.hasColors = this.hasNormals = this.hasPositions = !1, this.uvArray = this.colorArray = this.normalArray = this.positionArray = null, this.count = 0 }

            function aa(e, t) { d.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, e = new G, t = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1]; for (var n = 0, i = 1; 32 > n; n++, i++) { var r = n / 32 * Math.PI * 2,
                        a = i / 32 * Math.PI * 2;
                    t.push(Math.cos(r), Math.sin(r), 1, Math.cos(a), Math.sin(a), 1) } e.setAttribute("position", new B(t, 3)), t = new Jt({ fog: !1, toneMapped: !1 }), this.cone = new Kt(e, t), this.add(this.cone), this.update() }

            function oa(e) { for (var t = function e(t) { var n = [];
                        t && t.isBone && n.push(t); for (var i = 0; i < t.children.length; i++) n.push.apply(n, e(t.children[i])); return n }(e), n = new G, i = [], r = [], a = new b(0, 0, 1), o = new b(0, 1, 0), s = 0; s < t.length; s++) { var c = t[s];
                    c.parent && c.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(a.r, a.g, a.b), r.push(o.r, o.g, o.b)) } n.setAttribute("position", new B(i, 3)), n.setAttribute("color", new B(r, 3)), i = new Jt({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 }), Kt.call(this, n, i), this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1 }

            function sa(e, t, n) { this.light = e, this.light.updateMatrixWorld(), this.color = n, e = new $n(t, 4, 2), t = new A({ wireframe: !0, fog: !1, toneMapped: !1 }), H.call(this, e, t), this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update() }

            function ca(e, t, n) { d.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, (e = new gn(t)).rotateY(.5 * Math.PI), this.material = new A({ wireframe: !0, fog: !1, toneMapped: !1 }), void 0 === this.color && (this.material.vertexColors = !0), t = e.getAttribute("position"), t = new Float32Array(3 * t.count), e.setAttribute("color", new L(t, 3)), this.add(new H(e, this.material)), this.update() }

            function la(e, t, n, i) { e = e || 10, t = t || 10, n = new b(void 0 !== n ? n : 4473924), i = new b(void 0 !== i ? i : 8947848); var r = t / 2,
                    a = e / t,
                    o = e / 2;
                e = []; for (var s = [], c = 0, l = 0, h = -o; c <= t; c++, h += a) { e.push(-o, 0, h, o, 0, h), e.push(h, 0, -o, h, 0, o); var u = c === r ? n : i;
                    u.toArray(s, l), l += 3, u.toArray(s, l), l += 3, u.toArray(s, l), l += 3, u.toArray(s, l), l += 3 }(t = new G).setAttribute("position", new B(e, 3)), t.setAttribute("color", new B(s, 3)), n = new Jt({ vertexColors: !0, toneMapped: !1 }), Kt.call(this, t, n), this.type = "GridHelper" }

            function ha(e, t, n, i, r, a) { e = e || 10, t = t || 16, n = n || 8, i = i || 64, r = new b(void 0 !== r ? r : 4473924), a = new b(void 0 !== a ? a : 8947848); var o, s = [],
                    c = []; for (o = 0; o <= t; o++) { var l = o / t * 2 * Math.PI,
                        h = Math.sin(l) * e;
                    l = Math.cos(l) * e, s.push(0, 0, 0), s.push(h, 0, l); var u = 1 & o ? r : a;
                    c.push(u.r, u.g, u.b), c.push(u.r, u.g, u.b) } for (o = 0; o <= n; o++) { u = 1 & o ? r : a; var p = e - e / n * o; for (t = 0; t < i; t++) l = t / i * 2 * Math.PI, h = Math.sin(l) * p, l = Math.cos(l) * p, s.push(h, 0, l), c.push(u.r, u.g, u.b), l = (t + 1) / i * 2 * Math.PI, h = Math.sin(l) * p, l = Math.cos(l) * p, s.push(h, 0, l), c.push(u.r, u.g, u.b) }(e = new G).setAttribute("position", new B(s, 3)), e.setAttribute("color", new B(c, 3)), s = new Jt({ vertexColors: !0, toneMapped: !1 }), Kt.call(this, e, s), this.type = "PolarGridHelper" }

            function ua(e, t, n) { d.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === t && (t = 1), (e = new G).setAttribute("position", new B([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)), t = new Jt({ fog: !1, toneMapped: !1 }), this.lightPlane = new Qt(e, t), this.add(this.lightPlane), (e = new G).setAttribute("position", new B([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Qt(e, t), this.add(this.targetLine), this.update() }

            function pa(e) {
                function t(e, t, i) { n(e, i), n(t, i) }

                function n(e, t) { a.push(0, 0, 0), o.push(t.r, t.g, t.b), void 0 === s[e] && (s[e] = []), s[e].push(a.length / 3 - 1) } var i = new G,
                    r = new Jt({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
                    a = [],
                    o = [],
                    s = {},
                    c = new b(16755200),
                    l = new b(16711680),
                    h = new b(43775),
                    u = new b(16777215),
                    p = new b(3355443);
                t("n1", "n2", c), t("n2", "n4", c), t("n4", "n3", c), t("n3", "n1", c), t("f1", "f2", c), t("f2", "f4", c), t("f4", "f3", c), t("f3", "f1", c), t("n1", "f1", c), t("n2", "f2", c), t("n3", "f3", c), t("n4", "f4", c), t("p", "n1", l), t("p", "n2", l), t("p", "n3", l), t("p", "n4", l), t("u1", "u2", h), t("u2", "u3", h), t("u3", "u1", h), t("c", "t", u), t("p", "c", p), t("cn1", "cn2", p), t("cn3", "cn4", p), t("cf1", "cf2", p), t("cf3", "cf4", p), i.setAttribute("position", new B(a, 3)), i.setAttribute("color", new B(o, 3)), Kt.call(this, i, r), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update() }

            function da(e, t, n, i, r, a, o) { if (wl.set(r, a, o).unproject(i), void 0 !== (e = t[e]))
                    for (n = n.getAttribute("position"), t = 0, i = e.length; t < i; t++) n.setXYZ(e[t], wl.x, wl.y, wl.z) }

            function fa(e, t) { this.object = e, void 0 === t && (t = 16776960), e = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]); var n = new Float32Array(24),
                    i = new G;
                i.setIndex(new L(e, 1)), i.setAttribute("position", new L(n, 3)), Kt.call(this, i, new Jt({ color: t, toneMapped: !1 })), this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update() }

            function ma(e, t) { this.type = "Box3Helper", this.box = e, t = t || 16776960, e = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]); var n = new G;
                n.setIndex(new L(e, 1)), n.setAttribute("position", new B([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), Kt.call(this, n, new Jt({ color: t, toneMapped: !1 })), this.type = "Box3Helper", this.geometry.computeBoundingSphere() }

            function ga(e, t, n) { this.plane = e, this.size = void 0 === t ? 1 : t, e = void 0 !== n ? n : 16776960, (t = new G).setAttribute("position", new B([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), t.computeBoundingSphere(), Qt.call(this, t, new Jt({ color: e, toneMapped: !1 })), this.type = "PlaneHelper", (t = new G).setAttribute("position", new B([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), t.computeBoundingSphere(), this.add(new H(t, new A({ color: e, opacity: .2, transparent: !0, depthWrite: !1, toneMapped: !1 }))) }

            function va(e, t, n, i, r, a) { d.call(this), this.type = "ArrowHelper", void 0 === e && (e = new l(0, 0, 1)), void 0 === t && (t = new l(0, 0, 0)), void 0 === n && (n = 1), void 0 === i && (i = 16776960), void 0 === r && (r = .2 * n), void 0 === a && (a = .2 * r), void 0 === Tl && ((Tl = new G).setAttribute("position", new B([0, 0, 0, 0, 1, 0], 3)), (El = new li(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(t), this.line = new Qt(Tl, new Jt({ color: i, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new H(El, new A({ color: i, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, r, a) }

            function ya(e) { var t = [0, 0, 0, e = e || 1, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e];
                (e = new G).setAttribute("position", new B(t, 3)), e.setAttribute("color", new B([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), t = new Jt({ vertexColors: !0, toneMapped: !1 }), Kt.call(this, e, t), this.type = "AxesHelper" }

            function xa(e) { this._renderer = e, this._pingPongRenderTarget = null, (e = new mi({ defines: { n: 20 }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: e = new Float32Array(20) }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: new l(0, 1, 0) }, inputEncoding: { value: Cl[3e3] }, outputEncoding: { value: Cl[3e3] } }, vertexShader: "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\n\n// RH coordinate system; PMREM face-indexing convention\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\t} else if (face == 2.0) {\n\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\t} else if (face == 5.0) {\n\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\t}\n\treturn direction;\n}\n\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t", fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float mipInt;\nuniform vec3 poleAxis;\n\n\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvec3 getSample(float theta, vec3 axis) {\n\tfloat cosTheta = cos(theta);\n\t// Rodrigues' axis-angle rotation\n\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t+ cross(axis, vOutputDirection) * sin(theta)\n\t\t+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n\treturn bilinearCubeUV(envMap, sampleDirection, mipInt);\n}\n\nvoid main() {\n\tvec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n\tif (all(equal(axis, vec3(0.0))))\n\t\taxis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);\n\taxis = normalize(axis);\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb += weights[0] * getSample(0.0, axis);\n\tfor (int i = 1; i < n; i++) {\n\t\tif (i >= samples)\n\t\t\tbreak;\n\t\tfloat theta = dTheta * float(i);\n\t\tgl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);\n\t\tgl_FragColor.rgb += weights[i] * getSample(theta, axis);\n\t}\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t", blending: 0, depthTest: !1, depthWrite: !1 })).type = "SphericalGaussianBlur", this._blurMaterial = e, this._cubemapShader = this._equirectShader = null, this._compileMaterial(this._blurMaterial) }

            function _a(e) { return (e = new o(3 * Ll, 3 * Ll, e)).texture.mapping = 306, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e }

            function ba(e, t, n, i, r) { e.viewport.set(t, n, i, r), e.scissor.set(t, n, i, r) }

            function wa() { var e = new n(1, 1); return (e = new mi({ uniforms: { envMap: { value: null }, texelSize: { value: e }, inputEncoding: { value: Cl[3e3] }, outputEncoding: { value: Cl[3e3] } }, vertexShader: "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\n\n// RH coordinate system; PMREM face-indexing convention\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\t} else if (face == 2.0) {\n\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\t} else if (face == 5.0) {\n\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\t}\n\treturn direction;\n}\n\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t", fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform vec2 texelSize;\n\n\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t\n\n#include <common>\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tvec3 outputDirection = normalize(vOutputDirection);\n\tvec2 uv = equirectUv( outputDirection );\n\tvec2 f = fract(uv / texelSize - 0.5);\n\tuv -= f * texelSize;\n\tvec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x += texelSize.x;\n\tvec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.y += texelSize.y;\n\tvec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x -= texelSize.x;\n\tvec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tvec3 tm = mix(tl, tr, f.x);\n\tvec3 bm = mix(bl, br, f.x);\n\tgl_FragColor.rgb = mix(tm, bm, f.y);\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t", blending: 0, depthTest: !1, depthWrite: !1 })).type = "EquirectangularToCubeUV", e }

            function Ma() { var e = new mi({ uniforms: { envMap: { value: null }, inputEncoding: { value: Cl[3e3] }, outputEncoding: { value: Cl[3e3] } }, vertexShader: "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\n\n// RH coordinate system; PMREM face-indexing convention\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\t} else if (face == 2.0) {\n\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\t} else if (face == 5.0) {\n\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\t}\n\treturn direction;\n}\n\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t", fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform samplerCube envMap;\n\n\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t", blending: 0, depthTest: !1, depthWrite: !1 }); return e.type = "CubemapToCubeUV", e }

            function Sa(e) { console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Qi.call(this, e), this.type = "catmullrom", this.closed = !0 }

            function Ta(e) { console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Qi.call(this, e), this.type = "catmullrom" }

            function Ea(e) { console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Qi.call(this, e), this.type = "catmullrom" } void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(e) { return "number" == typeof e && isFinite(e) && Math.floor(e) === e }), void 0 === Math.sign && (Math.sign = function(e) { return 0 > e ? -1 : 0 < e ? 1 : +e }), !1 == "name" in Function.prototype && Object.defineProperty(Function.prototype, "name", { get: function() { return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1] } }), void 0 === Object.assign && (Object.assign = function(e) { if (null == e) throw new TypeError("Cannot convert undefined or null to object"); for (var t = Object(e), n = 1; n < arguments.length; n++) { var i = arguments[n]; if (null != i)
                        for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (t[r] = i[r]) } return t }), Object.assign(t.prototype, { addEventListener: function(e, t) { void 0 === this._listeners && (this._listeners = {}); var n = this._listeners;
                    void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t) }, hasEventListener: function(e, t) { if (void 0 === this._listeners) return !1; var n = this._listeners; return void 0 !== n[e] && -1 !== n[e].indexOf(t) }, removeEventListener: function(e, t) { void 0 !== this._listeners && (void 0 !== (e = this._listeners[e]) && (-1 !== (t = e.indexOf(t)) && e.splice(t, 1))) }, dispatchEvent: function(e) { if (void 0 !== this._listeners) { var t = this._listeners[e.type]; if (void 0 !== t) { e.target = this; for (var n = 0, i = (t = t.slice(0)).length; n < i; n++) t[n].call(this, e) } } } }); for (var Aa = [], La = 0; 256 > La; La++) Aa[La] = (16 > La ? "0" : "") + La.toString(16); var Ra = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function() { var e = 4294967295 * Math.random() | 0,
                        t = 4294967295 * Math.random() | 0,
                        n = 4294967295 * Math.random() | 0,
                        i = 4294967295 * Math.random() | 0; return (Aa[255 & e] + Aa[e >> 8 & 255] + Aa[e >> 16 & 255] + Aa[e >> 24 & 255] + "-" + Aa[255 & t] + Aa[t >> 8 & 255] + "-" + Aa[t >> 16 & 15 | 64] + Aa[t >> 24 & 255] + "-" + Aa[63 & n | 128] + Aa[n >> 8 & 255] + "-" + Aa[n >> 16 & 255] + Aa[n >> 24 & 255] + Aa[255 & i] + Aa[i >> 8 & 255] + Aa[i >> 16 & 255] + Aa[i >> 24 & 255]).toUpperCase() }, clamp: function(e, t, n) { return Math.max(t, Math.min(n, e)) }, euclideanModulo: function(e, t) { return (e % t + t) % t }, mapLinear: function(e, t, n, i, r) { return i + (e - t) * (r - i) / (n - t) }, lerp: function(e, t, n) { return (1 - n) * e + n * t }, smoothstep: function(e, t, n) { return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e) }, smootherstep: function(e, t, n) { return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10) }, randInt: function(e, t) { return e + Math.floor(Math.random() * (t - e + 1)) }, randFloat: function(e, t) { return e + Math.random() * (t - e) }, randFloatSpread: function(e) { return e * (.5 - Math.random()) }, degToRad: function(e) { return e * Ra.DEG2RAD }, radToDeg: function(e) { return e * Ra.RAD2DEG }, isPowerOfTwo: function(e) { return 0 == (e & e - 1) && 0 !== e }, ceilPowerOfTwo: function(e) { return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2)) }, floorPowerOfTwo: function(e) { return Math.pow(2, Math.floor(Math.log(e) / Math.LN2)) }, setQuaternionFromProperEuler: function(e, t, n, i, r) { var a = Math.cos,
                        o = Math.sin,
                        s = a(n / 2);
                    n = o(n / 2); var c = a((t + i) / 2),
                        l = o((t + i) / 2),
                        h = a((t - i) / 2),
                        u = o((t - i) / 2); switch (a = a((i - t) / 2), t = o((i - t) / 2), r) {
                        case "XYX":
                            e.set(s * l, n * h, n * u, s * c); break;
                        case "YZY":
                            e.set(n * u, s * l, n * h, s * c); break;
                        case "ZXZ":
                            e.set(n * h, n * u, s * l, s * c); break;
                        case "XZX":
                            e.set(s * l, n * t, n * a, s * c); break;
                        case "YXY":
                            e.set(n * a, s * l, n * t, s * c); break;
                        case "ZYZ":
                            e.set(n * t, n * a, s * l, s * c); break;
                        default:
                            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r) } } };
            Object.defineProperties(n.prototype, { width: { get: function() { return this.x }, set: function(e) { this.x = e } }, height: { get: function() { return this.y }, set: function(e) { this.y = e } } }), Object.assign(n.prototype, { isVector2: !0, set: function(e, t) { return this.x = e, this.y = t, this }, setScalar: function(e) { return this.y = this.x = e, this }, setX: function(e) { return this.x = e, this }, setY: function(e) { return this.y = e, this }, setComponent: function(e, t) { switch (e) {
                        case 0:
                            this.x = t; break;
                        case 1:
                            this.y = t; break;
                        default:
                            throw Error("index is out of range: " + e) } return this }, getComponent: function(e) { switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw Error("index is out of range: " + e) } }, clone: function() { return new this.constructor(this.x, this.y) }, copy: function(e) { return this.x = e.x, this.y = e.y, this }, add: function(e, t) { return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this) }, addScalar: function(e) { return this.x += e, this.y += e, this }, addVectors: function(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this }, addScaledVector: function(e, t) { return this.x += e.x * t, this.y += e.y * t, this }, sub: function(e, t) { return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this) }, subScalar: function(e) { return this.x -= e, this.y -= e, this }, subVectors: function(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this }, multiply: function(e) { return this.x *= e.x, this.y *= e.y, this }, multiplyScalar: function(e) { return this.x *= e, this.y *= e, this }, divide: function(e) { return this.x /= e.x, this.y /= e.y, this }, divideScalar: function(e) { return this.multiplyScalar(1 / e) }, applyMatrix3: function(e) { var t = this.x,
                        n = this.y; return e = e.elements, this.x = e[0] * t + e[3] * n + e[6], this.y = e[1] * t + e[4] * n + e[7], this }, min: function(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this }, max: function(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this }, clamp: function(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this }, clampScalar: function(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this }, clampLength: function(e, t) { var n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) }, floor: function() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this }, ceil: function() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this }, round: function() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this }, roundToZero: function() { return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this }, negate: function() { return this.x = -this.x, this.y = -this.y, this }, dot: function(e) { return this.x * e.x + this.y * e.y }, cross: function(e) { return this.x * e.y - this.y * e.x }, lengthSq: function() { return this.x * this.x + this.y * this.y }, length: function() { return Math.sqrt(this.x * this.x + this.y * this.y) }, manhattanLength: function() { return Math.abs(this.x) + Math.abs(this.y) }, normalize: function() { return this.divideScalar(this.length() || 1) }, angle: function() { return Math.atan2(-this.y, -this.x) + Math.PI }, distanceTo: function(e) { return Math.sqrt(this.distanceToSquared(e)) }, distanceToSquared: function(e) { var t = this.x - e.x; return t * t + (e = this.y - e.y) * e }, manhattanDistanceTo: function(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) }, setLength: function(e) { return this.normalize().multiplyScalar(e) }, lerp: function(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this }, lerpVectors: function(e, t, n) { return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this }, equals: function(e) { return e.x === this.x && e.y === this.y }, fromArray: function(e, t) { return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this }, toArray: function(e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e }, fromBufferAttribute: function(e, t, n) { return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this }, rotateAround: function(e, t) { var n = Math.cos(t);
                    t = Math.sin(t); var i = this.x - e.x,
                        r = this.y - e.y; return this.x = i * n - r * t + e.x, this.y = i * t + r * n + e.y, this }, random: function() { return this.x = Math.random(), this.y = Math.random(), this } }), Object.assign(i.prototype, { isMatrix3: !0, set: function(e, t, n, i, r, a, o, s, c) { var l = this.elements; return l[0] = e, l[1] = i, l[2] = o, l[3] = t, l[4] = r, l[5] = s, l[6] = n, l[7] = a, l[8] = c, this }, identity: function() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this }, clone: function() { return (new this.constructor).fromArray(this.elements) }, copy: function(e) { var t = this.elements; return e = e.elements, t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], this }, extractBasis: function(e, t, n) { return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this }, setFromMatrix4: function(e) { return e = e.elements, this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this }, multiply: function(e) { return this.multiplyMatrices(this, e) }, premultiply: function(e) { return this.multiplyMatrices(e, this) }, multiplyMatrices: function(e, t) { var n = e.elements,
                        i = t.elements;
                    t = this.elements, e = n[0]; var r = n[3],
                        a = n[6],
                        o = n[1],
                        s = n[4],
                        c = n[7],
                        l = n[2],
                        h = n[5];
                    n = n[8]; var u = i[0],
                        p = i[3],
                        d = i[6],
                        f = i[1],
                        m = i[4],
                        g = i[7],
                        v = i[2],
                        y = i[5]; return i = i[8], t[0] = e * u + r * f + a * v, t[3] = e * p + r * m + a * y, t[6] = e * d + r * g + a * i, t[1] = o * u + s * f + c * v, t[4] = o * p + s * m + c * y, t[7] = o * d + s * g + c * i, t[2] = l * u + h * f + n * v, t[5] = l * p + h * m + n * y, t[8] = l * d + h * g + n * i, this }, multiplyScalar: function(e) { var t = this.elements; return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this }, determinant: function() { var e = this.elements,
                        t = e[0],
                        n = e[1],
                        i = e[2],
                        r = e[3],
                        a = e[4],
                        o = e[5],
                        s = e[6],
                        c = e[7]; return t * a * (e = e[8]) - t * o * c - n * r * e + n * o * s + i * r * c - i * a * s }, getInverse: function(e, t) { void 0 !== t && console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate."); var n = e.elements;
                    e = this.elements, t = n[0]; var i = n[1],
                        r = n[2],
                        a = n[3],
                        o = n[4],
                        s = n[5],
                        c = n[6],
                        l = n[7],
                        h = (n = n[8]) * o - s * l,
                        u = s * c - n * a,
                        p = l * a - o * c,
                        d = t * h + i * u + r * p; return 0 === d ? this.set(0, 0, 0, 0, 0, 0, 0, 0, 0) : (d = 1 / d, e[0] = h * d, e[1] = (r * l - n * i) * d, e[2] = (s * i - r * o) * d, e[3] = u * d, e[4] = (n * t - r * c) * d, e[5] = (r * a - s * t) * d, e[6] = p * d, e[7] = (i * c - l * t) * d, e[8] = (o * t - i * a) * d, this) }, transpose: function() { var e = this.elements,
                        t = e[1]; return e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this }, getNormalMatrix: function(e) { return this.setFromMatrix4(e).getInverse(this).transpose() }, transposeIntoArray: function(e) { var t = this.elements; return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this }, setUvTransform: function(e, t, n, i, r, a, o) { var s = Math.cos(r);
                    r = Math.sin(r), this.set(n * s, n * r, -n * (s * a + r * o) + a + e, -i * r, i * s, -i * (-r * a + s * o) + o + t, 0, 0, 1) }, scale: function(e, t) { var n = this.elements; return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this }, rotate: function(e) { var t = Math.cos(e);
                    e = Math.sin(e); var n = this.elements,
                        i = n[0],
                        r = n[3],
                        a = n[6],
                        o = n[1],
                        s = n[4],
                        c = n[7]; return n[0] = t * i + e * o, n[3] = t * r + e * s, n[6] = t * a + e * c, n[1] = -e * i + t * o, n[4] = -e * r + t * s, n[7] = -e * a + t * c, this }, translate: function(e, t) { var n = this.elements; return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this }, equals: function(e) { var t = this.elements;
                    e = e.elements; for (var n = 0; 9 > n; n++)
                        if (t[n] !== e[n]) return !1; return !0 }, fromArray: function(e, t) { void 0 === t && (t = 0); for (var n = 0; 9 > n; n++) this.elements[n] = e[n + t]; return this }, toArray: function(e, t) { void 0 === e && (e = []), void 0 === t && (t = 0); var n = this.elements; return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e } }); var Pa, Ca = { getDataURL: function(e) { if ("undefined" == typeof HTMLCanvasElement) return e.src; if (!(e instanceof HTMLCanvasElement)) { void 0 === Pa && (Pa = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), Pa.width = e.width, Pa.height = e.height; var t = Pa.getContext("2d");
                            e instanceof ImageData ? t.putImageData(e, 0, 0) : t.drawImage(e, 0, 0, e.width, e.height), e = Pa } return 2048 < e.width || 2048 < e.height ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png") } },
                Oa = 0;
            r.DEFAULT_IMAGE = void 0, r.DEFAULT_MAPPING = 300, r.prototype = Object.assign(Object.create(t.prototype), { constructor: r, isTexture: !0, updateMatrix: function() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this }, toJSON: function(e) { var t = void 0 === e || "string" == typeof e; if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid]; var n = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; if (void 0 !== this.image) { var i = this.image; if (void 0 === i.uuid && (i.uuid = Ra.generateUUID()), !t && void 0 === e.images[i.uuid]) { if (Array.isArray(i))
                                for (var r = [], a = 0, o = i.length; a < o; a++) r.push(Ca.getDataURL(i[a]));
                            else r = Ca.getDataURL(i);
                            e.images[i.uuid] = { uuid: i.uuid, url: r } } n.image = i.uuid } return t || (e.textures[this.uuid] = n), n }, dispose: function() { this.dispatchEvent({ type: "dispose" }) }, transformUv: function(e) { if (300 !== this.mapping) return e; if (e.applyMatrix3(this.matrix), 0 > e.x || 1 < e.x) switch (this.wrapS) {
                        case 1e3:
                            e.x -= Math.floor(e.x); break;
                        case 1001:
                            e.x = 0 > e.x ? 0 : 1; break;
                        case 1002:
                            e.x = 1 === Math.abs(Math.floor(e.x) % 2) ? Math.ceil(e.x) - e.x : e.x - Math.floor(e.x) }
                    if (0 > e.y || 1 < e.y) switch (this.wrapT) {
                        case 1e3:
                            e.y -= Math.floor(e.y); break;
                        case 1001:
                            e.y = 0 > e.y ? 0 : 1; break;
                        case 1002:
                            e.y = 1 === Math.abs(Math.floor(e.y) % 2) ? Math.ceil(e.y) - e.y : e.y - Math.floor(e.y) }
                    return this.flipY && (e.y = 1 - e.y), e } }), Object.defineProperty(r.prototype, "needsUpdate", { set: function(e) {!0 === e && this.version++ } }), Object.defineProperties(a.prototype, { width: { get: function() { return this.z }, set: function(e) { this.z = e } }, height: { get: function() { return this.w }, set: function(e) { this.w = e } } }), Object.assign(a.prototype, { isVector4: !0, set: function(e, t, n, i) { return this.x = e, this.y = t, this.z = n, this.w = i, this }, setScalar: function(e) { return this.w = this.z = this.y = this.x = e, this }, setX: function(e) { return this.x = e, this }, setY: function(e) { return this.y = e, this }, setZ: function(e) { return this.z = e, this }, setW: function(e) { return this.w = e, this }, setComponent: function(e, t) { switch (e) {
                        case 0:
                            this.x = t; break;
                        case 1:
                            this.y = t; break;
                        case 2:
                            this.z = t; break;
                        case 3:
                            this.w = t; break;
                        default:
                            throw Error("index is out of range: " + e) } return this }, getComponent: function(e) { switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw Error("index is out of range: " + e) } }, clone: function() { return new this.constructor(this.x, this.y, this.z, this.w) }, copy: function(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this }, add: function(e, t) { return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this) }, addScalar: function(e) { return this.x += e, this.y += e, this.z += e, this.w += e, this }, addVectors: function(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this }, addScaledVector: function(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this }, sub: function(e, t) { return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this) }, subScalar: function(e) { return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this }, subVectors: function(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this }, multiplyScalar: function(e) { return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this }, applyMatrix4: function(e) { var t = this.x,
                        n = this.y,
                        i = this.z,
                        r = this.w; return e = e.elements, this.x = e[0] * t + e[4] * n + e[8] * i + e[12] * r, this.y = e[1] * t + e[5] * n + e[9] * i + e[13] * r, this.z = e[2] * t + e[6] * n + e[10] * i + e[14] * r, this.w = e[3] * t + e[7] * n + e[11] * i + e[15] * r, this }, divideScalar: function(e) { return this.multiplyScalar(1 / e) }, setAxisAngleFromQuaternion: function(e) { this.w = 2 * Math.acos(e.w); var t = Math.sqrt(1 - e.w * e.w); return 1e-4 > t ? (this.x = 1, this.z = this.y = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this }, setAxisAngleFromRotationMatrix: function(e) { var t = (e = e.elements)[0],
                        n = e[4],
                        i = e[8],
                        r = e[1],
                        a = e[5],
                        o = e[9],
                        s = e[2],
                        c = e[6],
                        l = e[10]; return .01 > Math.abs(n - r) && .01 > Math.abs(i - s) && .01 > Math.abs(o - c) ? .1 > Math.abs(n + r) && .1 > Math.abs(i + s) && .1 > Math.abs(o + c) && .1 > Math.abs(t + a + l - 3) ? (this.set(1, 0, 0, 0), this) : (e = Math.PI, l = (l + 1) / 2, n = (n + r) / 4, i = (i + s) / 4, o = (o + c) / 4, (t = (t + 1) / 2) > (a = (a + 1) / 2) && t > l ? .01 > t ? (c = 0, n = s = .707106781) : (s = n / (c = Math.sqrt(t)), n = i / c) : a > l ? .01 > a ? (c = .707106781, s = 0, n = .707106781) : (c = n / (s = Math.sqrt(a)), n = o / s) : .01 > l ? (s = c = .707106781, n = 0) : (c = i / (n = Math.sqrt(l)), s = o / n), this.set(c, s, n, e), this) : (e = Math.sqrt((c - o) * (c - o) + (i - s) * (i - s) + (r - n) * (r - n)), .001 > Math.abs(e) && (e = 1), this.x = (c - o) / e, this.y = (i - s) / e, this.z = (r - n) / e, this.w = Math.acos((t + a + l - 1) / 2), this) }, min: function(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this }, max: function(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this }, clamp: function(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this }, clampScalar: function(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this }, clampLength: function(e, t) { var n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) }, floor: function() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this }, ceil: function() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this }, round: function() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this }, roundToZero: function() { return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), this }, negate: function() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this }, dot: function(e) { return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w }, lengthSq: function() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w }, length: function() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) }, manhattanLength: function() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) }, normalize: function() { return this.divideScalar(this.length() || 1) }, setLength: function(e) { return this.normalize().multiplyScalar(e) }, lerp: function(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this }, lerpVectors: function(e, t, n) { return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this }, equals: function(e) { return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w }, fromArray: function(e, t) { return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this }, toArray: function(e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e }, fromBufferAttribute: function(e, t, n) { return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this }, random: function() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } }), o.prototype = Object.assign(Object.create(t.prototype), { constructor: o, isWebGLRenderTarget: !0, setSize: function(e, t) { this.width === e && this.height === t || (this.width = e, this.height = t, this.texture.image.width = e, this.texture.image.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t) }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this }, dispose: function() { this.dispatchEvent({ type: "dispose" }) } }), s.prototype = Object.assign(Object.create(o.prototype), { constructor: s, isWebGLMultisampleRenderTarget: !0, copy: function(e) { return o.prototype.copy.call(this, e), this.samples = e.samples, this } }), Object.assign(c, { slerp: function(e, t, n, i) { return n.copy(e).slerp(t, i) }, slerpFlat: function(e, t, n, i, r, a, o) { var s = n[i + 0],
                        c = n[i + 1],
                        l = n[i + 2];
                    n = n[i + 3], i = r[a + 0]; var h = r[a + 1],
                        u = r[a + 2]; if (n !== (r = r[a + 3]) || s !== i || c !== h || l !== u) { a = 1 - o; var p = s * i + c * h + l * u + n * r,
                            d = 0 <= p ? 1 : -1,
                            f = 1 - p * p;
                        f > Number.EPSILON && (f = Math.sqrt(f), p = Math.atan2(f, p * d), a = Math.sin(a * p) / f, o = Math.sin(o * p) / f), s = s * a + i * (d *= o), c = c * a + h * d, l = l * a + u * d, n = n * a + r * d, a === 1 - o && (s *= o = 1 / Math.sqrt(s * s + c * c + l * l + n * n), c *= o, l *= o, n *= o) } e[t] = s, e[t + 1] = c, e[t + 2] = l, e[t + 3] = n }, multiplyQuaternionsFlat: function(e, t, n, i, r, a) { var o = n[i],
                        s = n[i + 1],
                        c = n[i + 2];
                    n = n[i + 3], i = r[a]; var l = r[a + 1],
                        h = r[a + 2]; return r = r[a + 3], e[t] = o * r + n * i + s * h - c * l, e[t + 1] = s * r + n * l + c * i - o * h, e[t + 2] = c * r + n * h + o * l - s * i, e[t + 3] = n * r - o * i - s * l - c * h, e } }), Object.defineProperties(c.prototype, { x: { get: function() { return this._x }, set: function(e) { this._x = e, this._onChangeCallback() } }, y: { get: function() { return this._y }, set: function(e) { this._y = e, this._onChangeCallback() } }, z: { get: function() { return this._z }, set: function(e) { this._z = e, this._onChangeCallback() } }, w: { get: function() { return this._w }, set: function(e) { this._w = e, this._onChangeCallback() } } }), Object.assign(c.prototype, { isQuaternion: !0, set: function(e, t, n, i) { return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this }, clone: function() { return new this.constructor(this._x, this._y, this._z, this._w) }, copy: function(e) { return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this }, setFromEuler: function(e, t) { if (!e || !e.isEuler) throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."); var n = e._x,
                        i = e._y,
                        r = e._z;
                    e = e.order; var a = Math.cos,
                        o = Math.sin,
                        s = a(n / 2),
                        c = a(i / 2); switch (a = a(r / 2), n = o(n / 2), i = o(i / 2), r = o(r / 2), e) {
                        case "XYZ":
                            this._x = n * c * a + s * i * r, this._y = s * i * a - n * c * r, this._z = s * c * r + n * i * a, this._w = s * c * a - n * i * r; break;
                        case "YXZ":
                            this._x = n * c * a + s * i * r, this._y = s * i * a - n * c * r, this._z = s * c * r - n * i * a, this._w = s * c * a + n * i * r; break;
                        case "ZXY":
                            this._x = n * c * a - s * i * r, this._y = s * i * a + n * c * r, this._z = s * c * r + n * i * a, this._w = s * c * a - n * i * r; break;
                        case "ZYX":
                            this._x = n * c * a - s * i * r, this._y = s * i * a + n * c * r, this._z = s * c * r - n * i * a, this._w = s * c * a + n * i * r; break;
                        case "YZX":
                            this._x = n * c * a + s * i * r, this._y = s * i * a + n * c * r, this._z = s * c * r - n * i * a, this._w = s * c * a - n * i * r; break;
                        case "XZY":
                            this._x = n * c * a - s * i * r, this._y = s * i * a - n * c * r, this._z = s * c * r + n * i * a, this._w = s * c * a + n * i * r; break;
                        default:
                            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + e) } return !1 !== t && this._onChangeCallback(), this }, setFromAxisAngle: function(e, t) { t /= 2; var n = Math.sin(t); return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(t), this._onChangeCallback(), this }, setFromRotationMatrix: function(e) { var t = e.elements,
                        n = t[0];
                    e = t[4]; var i = t[8],
                        r = t[1],
                        a = t[5],
                        o = t[9],
                        s = t[2],
                        c = t[6],
                        l = n + a + (t = t[10]); return 0 < l ? (n = .5 / Math.sqrt(l + 1), this._w = .25 / n, this._x = (c - o) * n, this._y = (i - s) * n, this._z = (r - e) * n) : n > a && n > t ? (n = 2 * Math.sqrt(1 + n - a - t), this._w = (c - o) / n, this._x = .25 * n, this._y = (e + r) / n, this._z = (i + s) / n) : a > t ? (n = 2 * Math.sqrt(1 + a - n - t), this._w = (i - s) / n, this._x = (e + r) / n, this._y = .25 * n, this._z = (o + c) / n) : (n = 2 * Math.sqrt(1 + t - n - a), this._w = (r - e) / n, this._x = (i + s) / n, this._y = (o + c) / n, this._z = .25 * n), this._onChangeCallback(), this }, setFromUnitVectors: function(e, t) { var n = e.dot(t) + 1; return 1e-6 > n ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0) : (this._x = 0, this._y = -e.z, this._z = e.y)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x), this._w = n, this.normalize() }, angleTo: function(e) { return 2 * Math.acos(Math.abs(Ra.clamp(this.dot(e), -1, 1))) }, rotateTowards: function(e, t) { var n = this.angleTo(e); return 0 === n ? this : (this.slerp(e, Math.min(1, t / n)), this) }, inverse: function() { return this.conjugate() }, conjugate: function() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this }, dot: function(e) { return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w }, lengthSq: function() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w }, length: function() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) }, normalize: function() { var e = this.length(); return 0 === e ? (this._z = this._y = this._x = 0, this._w = 1) : (e = 1 / e, this._x *= e, this._y *= e, this._z *= e, this._w *= e), this._onChangeCallback(), this }, multiply: function(e, t) { return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e) }, premultiply: function(e) { return this.multiplyQuaternions(e, this) }, multiplyQuaternions: function(e, t) { var n = e._x,
                        i = e._y,
                        r = e._z;
                    e = e._w; var a = t._x,
                        o = t._y,
                        s = t._z; return t = t._w, this._x = n * t + e * a + i * s - r * o, this._y = i * t + e * o + r * a - n * s, this._z = r * t + e * s + n * o - i * a, this._w = e * t - n * a - i * o - r * s, this._onChangeCallback(), this }, slerp: function(e, t) { if (0 === t) return this; if (1 === t) return this.copy(e); var n = this._x,
                        i = this._y,
                        r = this._z,
                        a = this._w,
                        o = a * e._w + n * e._x + i * e._y + r * e._z; if (0 > o ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), 1 <= o) return this._w = a, this._x = n, this._y = i, this._z = r, this; if ((e = 1 - o * o) <= Number.EPSILON) return o = 1 - t, this._w = o * a + t * this._w, this._x = o * n + t * this._x, this._y = o * i + t * this._y, this._z = o * r + t * this._z, this.normalize(), this._onChangeCallback(), this;
                    e = Math.sqrt(e); var s = Math.atan2(e, o); return o = Math.sin((1 - t) * s) / e, t = Math.sin(t * s) / e, this._w = a * o + this._w * t, this._x = n * o + this._x * t, this._y = i * o + this._y * t, this._z = r * o + this._z * t, this._onChangeCallback(), this }, equals: function(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w }, fromArray: function(e, t) { return void 0 === t && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this }, toArray: function(e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e }, fromBufferAttribute: function(e, t) { return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this }, _onChange: function(e) { return this._onChangeCallback = e, this }, _onChangeCallback: function() {} }); var Da = new l,
                Ia = new c;
            Object.assign(l.prototype, { isVector3: !0, set: function(e, t, n) { return this.x = e, this.y = t, this.z = n, this }, setScalar: function(e) { return this.z = this.y = this.x = e, this }, setX: function(e) { return this.x = e, this }, setY: function(e) { return this.y = e, this }, setZ: function(e) { return this.z = e, this }, setComponent: function(e, t) { switch (e) {
                        case 0:
                            this.x = t; break;
                        case 1:
                            this.y = t; break;
                        case 2:
                            this.z = t; break;
                        default:
                            throw Error("index is out of range: " + e) } return this }, getComponent: function(e) { switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw Error("index is out of range: " + e) } }, clone: function() { return new this.constructor(this.x, this.y, this.z) }, copy: function(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this }, add: function(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this) }, addScalar: function(e) { return this.x += e, this.y += e, this.z += e, this }, addVectors: function(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this }, addScaledVector: function(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this }, sub: function(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this) }, subScalar: function(e) { return this.x -= e, this.y -= e, this.z -= e, this }, subVectors: function(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this }, multiply: function(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this) }, multiplyScalar: function(e) { return this.x *= e, this.y *= e, this.z *= e, this }, multiplyVectors: function(e, t) { return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this }, applyEuler: function(e) { return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Ia.setFromEuler(e)) }, applyAxisAngle: function(e, t) { return this.applyQuaternion(Ia.setFromAxisAngle(e, t)) }, applyMatrix3: function(e) { var t = this.x,
                        n = this.y,
                        i = this.z; return e = e.elements, this.x = e[0] * t + e[3] * n + e[6] * i, this.y = e[1] * t + e[4] * n + e[7] * i, this.z = e[2] * t + e[5] * n + e[8] * i, this }, applyNormalMatrix: function(e) { return this.applyMatrix3(e).normalize() }, applyMatrix4: function(e) { var t = this.x,
                        n = this.y,
                        i = this.z,
                        r = 1 / ((e = e.elements)[3] * t + e[7] * n + e[11] * i + e[15]); return this.x = (e[0] * t + e[4] * n + e[8] * i + e[12]) * r, this.y = (e[1] * t + e[5] * n + e[9] * i + e[13]) * r, this.z = (e[2] * t + e[6] * n + e[10] * i + e[14]) * r, this }, applyQuaternion: function(e) { var t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.x,
                        a = e.y,
                        o = e.z,
                        s = (e = e.w) * t + a * i - o * n,
                        c = e * n + o * t - r * i,
                        l = e * i + r * n - a * t; return t = -r * t - a * n - o * i, this.x = s * e + t * -r + c * -o - l * -a, this.y = c * e + t * -a + l * -r - s * -o, this.z = l * e + t * -o + s * -a - c * -r, this }, project: function(e) { return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix) }, unproject: function(e) { return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld) }, transformDirection: function(e) { var t = this.x,
                        n = this.y,
                        i = this.z; return e = e.elements, this.x = e[0] * t + e[4] * n + e[8] * i, this.y = e[1] * t + e[5] * n + e[9] * i, this.z = e[2] * t + e[6] * n + e[10] * i, this.normalize() }, divide: function(e) { return this.x /= e.x, this.y /= e.y, this.z /= e.z, this }, divideScalar: function(e) { return this.multiplyScalar(1 / e) }, min: function(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this }, max: function(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this }, clamp: function(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this }, clampScalar: function(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this }, clampLength: function(e, t) { var n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) }, floor: function() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this }, ceil: function() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this }, round: function() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this }, roundToZero: function() { return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this }, negate: function() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this }, dot: function(e) { return this.x * e.x + this.y * e.y + this.z * e.z }, lengthSq: function() { return this.x * this.x + this.y * this.y + this.z * this.z }, length: function() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) }, manhattanLength: function() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) }, normalize: function() { return this.divideScalar(this.length() || 1) }, setLength: function(e) { return this.normalize().multiplyScalar(e) }, lerp: function(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this }, lerpVectors: function(e, t, n) { return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this }, cross: function(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e) }, crossVectors: function(e, t) { var n = e.x,
                        i = e.y;
                    e = e.z; var r = t.x,
                        a = t.y; return t = t.z, this.x = i * t - e * a, this.y = e * r - n * t, this.z = n * a - i * r, this }, projectOnVector: function(e) { var t = e.lengthSq(); return 0 === t ? this.set(0, 0, 0) : (t = e.dot(this) / t, this.copy(e).multiplyScalar(t)) }, projectOnPlane: function(e) { return Da.copy(this).projectOnVector(e), this.sub(Da) }, reflect: function(e) { return this.sub(Da.copy(e).multiplyScalar(2 * this.dot(e))) }, angleTo: function(e) { var t = Math.sqrt(this.lengthSq() * e.lengthSq()); return 0 === t ? Math.PI / 2 : (e = this.dot(e) / t, Math.acos(Ra.clamp(e, -1, 1))) }, distanceTo: function(e) { return Math.sqrt(this.distanceToSquared(e)) }, distanceToSquared: function(e) { var t = this.x - e.x,
                        n = this.y - e.y; return t * t + n * n + (e = this.z - e.z) * e }, manhattanDistanceTo: function(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z) }, setFromSpherical: function(e) { return this.setFromSphericalCoords(e.radius, e.phi, e.theta) }, setFromSphericalCoords: function(e, t, n) { var i = Math.sin(t) * e; return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this }, setFromCylindrical: function(e) { return this.setFromCylindricalCoords(e.radius, e.theta, e.y) }, setFromCylindricalCoords: function(e, t, n) { return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this }, setFromMatrixPosition: function(e) { return e = e.elements, this.x = e[12], this.y = e[13], this.z = e[14], this }, setFromMatrixScale: function(e) { var t = this.setFromMatrixColumn(e, 0).length(),
                        n = this.setFromMatrixColumn(e, 1).length(); return e = this.setFromMatrixColumn(e, 2).length(), this.x = t, this.y = n, this.z = e, this }, setFromMatrixColumn: function(e, t) { return this.fromArray(e.elements, 4 * t) }, setFromMatrix3Column: function(e, t) { return this.fromArray(e.elements, 3 * t) }, equals: function(e) { return e.x === this.x && e.y === this.y && e.z === this.z }, fromArray: function(e, t) { return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this }, toArray: function(e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e }, fromBufferAttribute: function(e, t, n) { return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this }, random: function() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } }); var Na = new l,
                Ba = new h,
                za = new l(0, 0, 0),
                Ua = new l(1, 1, 1),
                Fa = new l,
                Ga = new l,
                Ha = new l;
            Object.assign(h.prototype, { isMatrix4: !0, set: function(e, t, n, i, r, a, o, s, c, l, h, u, p, d, f, m) { var g = this.elements; return g[0] = e, g[4] = t, g[8] = n, g[12] = i, g[1] = r, g[5] = a, g[9] = o, g[13] = s, g[2] = c, g[6] = l, g[10] = h, g[14] = u, g[3] = p, g[7] = d, g[11] = f, g[15] = m, this }, identity: function() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this }, clone: function() { return (new h).fromArray(this.elements) }, copy: function(e) { var t = this.elements; return e = e.elements, t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], this }, copyPosition: function(e) { var t = this.elements; return e = e.elements, t[12] = e[12], t[13] = e[13], t[14] = e[14], this }, extractBasis: function(e, t, n) { return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this }, makeBasis: function(e, t, n) { return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this }, extractRotation: function(e) { var t = this.elements,
                        n = e.elements,
                        i = 1 / Na.setFromMatrixColumn(e, 0).length(),
                        r = 1 / Na.setFromMatrixColumn(e, 1).length(); return e = 1 / Na.setFromMatrixColumn(e, 2).length(), t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * e, t[9] = n[9] * e, t[10] = n[10] * e, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this }, makeRotationFromEuler: function(e) { e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."); var t = this.elements,
                        n = e.x,
                        i = e.y,
                        r = e.z,
                        a = Math.cos(n);
                    n = Math.sin(n); var o = Math.cos(i);
                    i = Math.sin(i); var s = Math.cos(r); if (r = Math.sin(r), "XYZ" === e.order) { e = a * s; var c = a * r,
                            l = n * s,
                            h = n * r;
                        t[0] = o * s, t[4] = -o * r, t[8] = i, t[1] = c + l * i, t[5] = e - h * i, t[9] = -n * o, t[2] = h - e * i, t[6] = l + c * i, t[10] = a * o } else "YXZ" === e.order ? (e = o * s, c = o * r, l = i * s, h = i * r, t[0] = e + h * n, t[4] = l * n - c, t[8] = a * i, t[1] = a * r, t[5] = a * s, t[9] = -n, t[2] = c * n - l, t[6] = h + e * n, t[10] = a * o) : "ZXY" === e.order ? (e = o * s, c = o * r, l = i * s, h = i * r, t[0] = e - h * n, t[4] = -a * r, t[8] = l + c * n, t[1] = c + l * n, t[5] = a * s, t[9] = h - e * n, t[2] = -a * i, t[6] = n, t[10] = a * o) : "ZYX" === e.order ? (e = a * s, c = a * r, l = n * s, h = n * r, t[0] = o * s, t[4] = l * i - c, t[8] = e * i + h, t[1] = o * r, t[5] = h * i + e, t[9] = c * i - l, t[2] = -i, t[6] = n * o, t[10] = a * o) : "YZX" === e.order ? (e = a * o, c = a * i, l = n * o, h = n * i, t[0] = o * s, t[4] = h - e * r, t[8] = l * r + c, t[1] = r, t[5] = a * s, t[9] = -n * s, t[2] = -i * s, t[6] = c * r + l, t[10] = e - h * r) : "XZY" === e.order && (e = a * o, c = a * i, l = n * o, h = n * i, t[0] = o * s, t[4] = -r, t[8] = i * s, t[1] = e * r + h, t[5] = a * s, t[9] = c * r - l, t[2] = l * r - c, t[6] = n * s, t[10] = h * r + e); return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this }, makeRotationFromQuaternion: function(e) { return this.compose(za, e, Ua) }, lookAt: function(e, t, n) { var i = this.elements; return Ha.subVectors(e, t), 0 === Ha.lengthSq() && (Ha.z = 1), Ha.normalize(), Fa.crossVectors(n, Ha), 0 === Fa.lengthSq() && (1 === Math.abs(n.z) ? Ha.x += 1e-4 : Ha.z += 1e-4, Ha.normalize(), Fa.crossVectors(n, Ha)), Fa.normalize(), Ga.crossVectors(Ha, Fa), i[0] = Fa.x, i[4] = Ga.x, i[8] = Ha.x, i[1] = Fa.y, i[5] = Ga.y, i[9] = Ha.y, i[2] = Fa.z, i[6] = Ga.z, i[10] = Ha.z, this }, multiply: function(e, t) { return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e) }, premultiply: function(e) { return this.multiplyMatrices(e, this) }, multiplyMatrices: function(e, t) { var n = e.elements,
                        i = t.elements;
                    t = this.elements, e = n[0]; var r = n[4],
                        a = n[8],
                        o = n[12],
                        s = n[1],
                        c = n[5],
                        l = n[9],
                        h = n[13],
                        u = n[2],
                        p = n[6],
                        d = n[10],
                        f = n[14],
                        m = n[3],
                        g = n[7],
                        v = n[11];
                    n = n[15]; var y = i[0],
                        x = i[4],
                        _ = i[8],
                        b = i[12],
                        w = i[1],
                        M = i[5],
                        S = i[9],
                        T = i[13],
                        E = i[2],
                        A = i[6],
                        L = i[10],
                        R = i[14],
                        P = i[3],
                        C = i[7],
                        O = i[11]; return i = i[15], t[0] = e * y + r * w + a * E + o * P, t[4] = e * x + r * M + a * A + o * C, t[8] = e * _ + r * S + a * L + o * O, t[12] = e * b + r * T + a * R + o * i, t[1] = s * y + c * w + l * E + h * P, t[5] = s * x + c * M + l * A + h * C, t[9] = s * _ + c * S + l * L + h * O, t[13] = s * b + c * T + l * R + h * i, t[2] = u * y + p * w + d * E + f * P, t[6] = u * x + p * M + d * A + f * C, t[10] = u * _ + p * S + d * L + f * O, t[14] = u * b + p * T + d * R + f * i, t[3] = m * y + g * w + v * E + n * P, t[7] = m * x + g * M + v * A + n * C, t[11] = m * _ + g * S + v * L + n * O, t[15] = m * b + g * T + v * R + n * i, this }, multiplyScalar: function(e) { var t = this.elements; return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this }, determinant: function() { var e = this.elements,
                        t = e[0],
                        n = e[4],
                        i = e[8],
                        r = e[12],
                        a = e[1],
                        o = e[5],
                        s = e[9],
                        c = e[13],
                        l = e[2],
                        h = e[6],
                        u = e[10],
                        p = e[14]; return e[3] * (+r * s * h - i * c * h - r * o * u + n * c * u + i * o * p - n * s * p) + e[7] * (+t * s * p - t * c * u + r * a * u - i * a * p + i * c * l - r * s * l) + e[11] * (+t * c * h - t * o * p - r * a * h + n * a * p + r * o * l - n * c * l) + e[15] * (-i * o * l - t * s * h + t * o * u + i * a * h - n * a * u + n * s * l) }, transpose: function() { var e = this.elements,
                        t = e[1]; return e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this }, setPosition: function(e, t, n) { var i = this.elements; return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this }, getInverse: function(e, t) { void 0 !== t && console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate."), t = this.elements; var n = e.elements;
                    e = n[0]; var i = n[1],
                        r = n[2],
                        a = n[3],
                        o = n[4],
                        s = n[5],
                        c = n[6],
                        l = n[7],
                        h = n[8],
                        u = n[9],
                        p = n[10],
                        d = n[11],
                        f = n[12],
                        m = n[13],
                        g = n[14],
                        v = u * g * l - m * p * l + m * c * d - s * g * d - u * c * (n = n[15]) + s * p * n,
                        y = f * p * l - h * g * l - f * c * d + o * g * d + h * c * n - o * p * n,
                        x = h * m * l - f * u * l + f * s * d - o * m * d - h * s * n + o * u * n,
                        _ = f * u * c - h * m * c - f * s * p + o * m * p + h * s * g - o * u * g,
                        b = e * v + i * y + r * x + a * _; return 0 === b ? this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) : (b = 1 / b, t[0] = v * b, t[1] = (m * p * a - u * g * a - m * r * d + i * g * d + u * r * n - i * p * n) * b, t[2] = (s * g * a - m * c * a + m * r * l - i * g * l - s * r * n + i * c * n) * b, t[3] = (u * c * a - s * p * a - u * r * l + i * p * l + s * r * d - i * c * d) * b, t[4] = y * b, t[5] = (h * g * a - f * p * a + f * r * d - e * g * d - h * r * n + e * p * n) * b, t[6] = (f * c * a - o * g * a - f * r * l + e * g * l + o * r * n - e * c * n) * b, t[7] = (o * p * a - h * c * a + h * r * l - e * p * l - o * r * d + e * c * d) * b, t[8] = x * b, t[9] = (f * u * a - h * m * a - f * i * d + e * m * d + h * i * n - e * u * n) * b, t[10] = (o * m * a - f * s * a + f * i * l - e * m * l - o * i * n + e * s * n) * b, t[11] = (h * s * a - o * u * a - h * i * l + e * u * l + o * i * d - e * s * d) * b, t[12] = _ * b, t[13] = (h * m * r - f * u * r + f * i * p - e * m * p - h * i * g + e * u * g) * b, t[14] = (f * s * r - o * m * r - f * i * c + e * m * c + o * i * g - e * s * g) * b, t[15] = (o * u * r - h * s * r + h * i * c - e * u * c - o * i * p + e * s * p) * b, this) }, scale: function(e) { var t = this.elements,
                        n = e.x,
                        i = e.y; return e = e.z, t[0] *= n, t[4] *= i, t[8] *= e, t[1] *= n, t[5] *= i, t[9] *= e, t[2] *= n, t[6] *= i, t[10] *= e, t[3] *= n, t[7] *= i, t[11] *= e, this }, getMaxScaleOnAxis: function() { var e = this.elements; return Math.sqrt(Math.max(e[0] * e[0] + e[1] * e[1] + e[2] * e[2], e[4] * e[4] + e[5] * e[5] + e[6] * e[6], e[8] * e[8] + e[9] * e[9] + e[10] * e[10])) }, makeTranslation: function(e, t, n) { return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this }, makeRotationX: function(e) { var t = Math.cos(e); return e = Math.sin(e), this.set(1, 0, 0, 0, 0, t, -e, 0, 0, e, t, 0, 0, 0, 0, 1), this }, makeRotationY: function(e) { var t = Math.cos(e); return e = Math.sin(e), this.set(t, 0, e, 0, 0, 1, 0, 0, -e, 0, t, 0, 0, 0, 0, 1), this }, makeRotationZ: function(e) { var t = Math.cos(e); return e = Math.sin(e), this.set(t, -e, 0, 0, e, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this }, makeRotationAxis: function(e, t) { var n = Math.cos(t);
                    t = Math.sin(t); var i = 1 - n,
                        r = e.x,
                        a = e.y;
                    e = e.z; var o = i * r,
                        s = i * a; return this.set(o * r + n, o * a - t * e, o * e + t * a, 0, o * a + t * e, s * a + n, s * e - t * r, 0, o * e - t * a, s * e + t * r, i * e * e + n, 0, 0, 0, 0, 1), this }, makeScale: function(e, t, n) { return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this }, makeShear: function(e, t, n) { return this.set(1, t, n, 0, e, 1, n, 0, e, t, 1, 0, 0, 0, 0, 1), this }, compose: function(e, t, n) { var i = this.elements,
                        r = t._x,
                        a = t._y,
                        o = t._z,
                        s = t._w,
                        c = r + r,
                        l = a + a,
                        h = o + o;
                    t = r * c; var u = r * l;
                    r *= h; var p = a * l;
                    a *= h, o *= h, c *= s, l *= s, s *= h, h = n.x; var d = n.y; return n = n.z, i[0] = (1 - (p + o)) * h, i[1] = (u + s) * h, i[2] = (r - l) * h, i[3] = 0, i[4] = (u - s) * d, i[5] = (1 - (t + o)) * d, i[6] = (a + c) * d, i[7] = 0, i[8] = (r + l) * n, i[9] = (a - c) * n, i[10] = (1 - (t + p)) * n, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this }, decompose: function(e, t, n) { var i = this.elements,
                        r = Na.set(i[0], i[1], i[2]).length(),
                        a = Na.set(i[4], i[5], i[6]).length(),
                        o = Na.set(i[8], i[9], i[10]).length();
                    0 > this.determinant() && (r = -r), e.x = i[12], e.y = i[13], e.z = i[14], Ba.copy(this), e = 1 / r, i = 1 / a; var s = 1 / o; return Ba.elements[0] *= e, Ba.elements[1] *= e, Ba.elements[2] *= e, Ba.elements[4] *= i, Ba.elements[5] *= i, Ba.elements[6] *= i, Ba.elements[8] *= s, Ba.elements[9] *= s, Ba.elements[10] *= s, t.setFromRotationMatrix(Ba), n.x = r, n.y = a, n.z = o, this }, makePerspective: function(e, t, n, i, r, a) { void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."); var o = this.elements; return o[0] = 2 * r / (t - e), o[4] = 0, o[8] = (t + e) / (t - e), o[12] = 0, o[1] = 0, o[5] = 2 * r / (n - i), o[9] = (n + i) / (n - i), o[13] = 0, o[2] = 0, o[6] = 0, o[10] = -(a + r) / (a - r), o[14] = -2 * a * r / (a - r), o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this }, makeOrthographic: function(e, t, n, i, r, a) { var o = this.elements,
                        s = 1 / (t - e),
                        c = 1 / (n - i),
                        l = 1 / (a - r); return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -(t + e) * s, o[1] = 0, o[5] = 2 * c, o[9] = 0, o[13] = -(n + i) * c, o[2] = 0, o[6] = 0, o[10] = -2 * l, o[14] = -(a + r) * l, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this }, equals: function(e) { var t = this.elements;
                    e = e.elements; for (var n = 0; 16 > n; n++)
                        if (t[n] !== e[n]) return !1; return !0 }, fromArray: function(e, t) { void 0 === t && (t = 0); for (var n = 0; 16 > n; n++) this.elements[n] = e[n + t]; return this }, toArray: function(e, t) { void 0 === e && (e = []), void 0 === t && (t = 0); var n = this.elements; return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e } }); var ka = new h,
                Va = new c;
            u.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), u.DefaultOrder = "XYZ", Object.defineProperties(u.prototype, { x: { get: function() { return this._x }, set: function(e) { this._x = e, this._onChangeCallback() } }, y: { get: function() { return this._y }, set: function(e) { this._y = e, this._onChangeCallback() } }, z: { get: function() { return this._z }, set: function(e) { this._z = e, this._onChangeCallback() } }, order: { get: function() { return this._order }, set: function(e) { this._order = e, this._onChangeCallback() } } }), Object.assign(u.prototype, { isEuler: !0, set: function(e, t, n, i) { return this._x = e, this._y = t, this._z = n, this._order = i || this._order, this._onChangeCallback(), this }, clone: function() { return new this.constructor(this._x, this._y, this._z, this._order) }, copy: function(e) { return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this }, setFromRotationMatrix: function(e, t, n) { var i = Ra.clamp,
                        r = e.elements;
                    e = r[0]; var a = r[4],
                        o = r[8],
                        s = r[1],
                        c = r[5],
                        l = r[9],
                        h = r[2],
                        u = r[6]; switch (r = r[10], t = t || this._order) {
                        case "XYZ":
                            this._y = Math.asin(i(o, -1, 1)), .9999999 > Math.abs(o) ? (this._x = Math.atan2(-l, r), this._z = Math.atan2(-a, e)) : (this._x = Math.atan2(u, c), this._z = 0); break;
                        case "YXZ":
                            this._x = Math.asin(-i(l, -1, 1)), .9999999 > Math.abs(l) ? (this._y = Math.atan2(o, r), this._z = Math.atan2(s, c)) : (this._y = Math.atan2(-h, e), this._z = 0); break;
                        case "ZXY":
                            this._x = Math.asin(i(u, -1, 1)), .9999999 > Math.abs(u) ? (this._y = Math.atan2(-h, r), this._z = Math.atan2(-a, c)) : (this._y = 0, this._z = Math.atan2(s, e)); break;
                        case "ZYX":
                            this._y = Math.asin(-i(h, -1, 1)), .9999999 > Math.abs(h) ? (this._x = Math.atan2(u, r), this._z = Math.atan2(s, e)) : (this._x = 0, this._z = Math.atan2(-a, c)); break;
                        case "YZX":
                            this._z = Math.asin(i(s, -1, 1)), .9999999 > Math.abs(s) ? (this._x = Math.atan2(-l, c), this._y = Math.atan2(-h, e)) : (this._x = 0, this._y = Math.atan2(o, r)); break;
                        case "XZY":
                            this._z = Math.asin(-i(a, -1, 1)), .9999999 > Math.abs(a) ? (this._x = Math.atan2(u, c), this._y = Math.atan2(o, e)) : (this._x = Math.atan2(-l, r), this._y = 0); break;
                        default:
                            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t) } return this._order = t, !1 !== n && this._onChangeCallback(), this }, setFromQuaternion: function(e, t, n) { return ka.makeRotationFromQuaternion(e), this.setFromRotationMatrix(ka, t, n) }, setFromVector3: function(e, t) { return this.set(e.x, e.y, e.z, t || this._order) }, reorder: function(e) { return Va.setFromEuler(this), this.setFromQuaternion(Va, e) }, equals: function(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order }, fromArray: function(e) { return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this }, toArray: function(e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e }, toVector3: function(e) { return e ? e.set(this._x, this._y, this._z) : new l(this._x, this._y, this._z) }, _onChange: function(e) { return this._onChangeCallback = e, this }, _onChangeCallback: function() {} }), Object.assign(p.prototype, { set: function(e) { this.mask = 1 << e | 0 }, enable: function(e) { this.mask = this.mask | 1 << e | 0 }, enableAll: function() { this.mask = -1 }, toggle: function(e) { this.mask ^= 1 << e | 0 }, disable: function(e) { this.mask &= ~(1 << e | 0) }, disableAll: function() { this.mask = 0 }, test: function(e) { return 0 != (this.mask & e.mask) } }); var ja = 0,
                Wa = new l,
                qa = new c,
                Xa = new h,
                Ya = new l,
                Za = new l,
                Ja = new l,
                Qa = new c,
                Ka = new l(1, 0, 0),
                $a = new l(0, 1, 0),
                eo = new l(0, 0, 1),
                to = { type: "added" },
                no = { type: "removed" };
            d.DefaultUp = new l(0, 1, 0), d.DefaultMatrixAutoUpdate = !0, d.prototype = Object.assign(Object.create(t.prototype), { constructor: d, isObject3D: !0, onBeforeRender: function() {}, onAfterRender: function() {}, applyMatrix4: function(e) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale) }, applyQuaternion: function(e) { return this.quaternion.premultiply(e), this }, setRotationFromAxisAngle: function(e, t) { this.quaternion.setFromAxisAngle(e, t) }, setRotationFromEuler: function(e) { this.quaternion.setFromEuler(e, !0) }, setRotationFromMatrix: function(e) { this.quaternion.setFromRotationMatrix(e) }, setRotationFromQuaternion: function(e) { this.quaternion.copy(e) }, rotateOnAxis: function(e, t) { return qa.setFromAxisAngle(e, t), this.quaternion.multiply(qa), this }, rotateOnWorldAxis: function(e, t) { return qa.setFromAxisAngle(e, t), this.quaternion.premultiply(qa), this }, rotateX: function(e) { return this.rotateOnAxis(Ka, e) }, rotateY: function(e) { return this.rotateOnAxis($a, e) }, rotateZ: function(e) { return this.rotateOnAxis(eo, e) }, translateOnAxis: function(e, t) { return Wa.copy(e).applyQuaternion(this.quaternion), this.position.add(Wa.multiplyScalar(t)), this }, translateX: function(e) { return this.translateOnAxis(Ka, e) }, translateY: function(e) { return this.translateOnAxis($a, e) }, translateZ: function(e) { return this.translateOnAxis(eo, e) }, localToWorld: function(e) { return e.applyMatrix4(this.matrixWorld) }, worldToLocal: function(e) { return e.applyMatrix4(Xa.getInverse(this.matrixWorld)) }, lookAt: function(e, t, n) { e.isVector3 ? Ya.copy(e) : Ya.set(e, t, n), e = this.parent, this.updateWorldMatrix(!0, !1), Za.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Xa.lookAt(Za, Ya, this.up) : Xa.lookAt(Ya, Za, this.up), this.quaternion.setFromRotationMatrix(Xa), e && (Xa.extractRotation(e.matrixWorld), qa.setFromRotationMatrix(Xa), this.quaternion.premultiply(qa.inverse())) }, add: function(e) { if (1 < arguments.length) { for (var t = 0; t < arguments.length; t++) this.add(arguments[t]); return this } return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(to)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this) }, remove: function(e) { if (1 < arguments.length) { for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]); return this } return -1 !== (t = this.children.indexOf(e)) && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(no)), this }, attach: function(e) { return this.updateWorldMatrix(!0, !1), Xa.getInverse(this.matrixWorld), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), Xa.multiply(e.parent.matrixWorld)), e.applyMatrix4(Xa), e.updateWorldMatrix(!1, !1), this.add(e), this }, getObjectById: function(e) { return this.getObjectByProperty("id", e) }, getObjectByName: function(e) { return this.getObjectByProperty("name", e) }, getObjectByProperty: function(e, t) { if (this[e] === t) return this; for (var n = 0, i = this.children.length; n < i; n++) { var r = this.children[n].getObjectByProperty(e, t); if (void 0 !== r) return r } }, getWorldPosition: function(e) { return void 0 === e && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), e = new l), this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld) }, getWorldQuaternion: function(e) { return void 0 === e && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), e = new c), this.updateMatrixWorld(!0), this.matrixWorld.decompose(Za, e, Ja), e }, getWorldScale: function(e) { return void 0 === e && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), e = new l), this.updateMatrixWorld(!0), this.matrixWorld.decompose(Za, Qa, e), e }, getWorldDirection: function(e) { void 0 === e && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), e = new l), this.updateMatrixWorld(!0); var t = this.matrixWorld.elements; return e.set(t[8], t[9], t[10]).normalize() }, raycast: function() {}, traverse: function(e) { e(this); for (var t = this.children, n = 0, i = t.length; n < i; n++) t[n].traverse(e) }, traverseVisible: function(e) { if (!1 !== this.visible) { e(this); for (var t = this.children, n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e) } }, traverseAncestors: function(e) { var t = this.parent;
                    null !== t && (e(t), t.traverseAncestors(e)) }, updateMatrix: function() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 }, updateMatrixWorld: function(e) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0); for (var t = this.children, n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e) }, updateWorldMatrix: function(e, t) { var n = this.parent; if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t)
                        for (t = 0, n = (e = this.children).length; t < n; t++) e[t].updateWorldMatrix(!1, !0) }, toJSON: function(e) {
                    function t(t, n) { return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid }

                    function n(e) { var t, n = []; for (t in e) { var i = e[t];
                            delete i.metadata, n.push(i) } return n } var i = void 0 === e || "string" == typeof e,
                        r = {};
                    i && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {} }, r.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }); var a = {}; if (a.uuid = this.uuid, a.type = this.type, "" !== this.name && (a.name = this.name), !0 === this.castShadow && (a.castShadow = !0), !0 === this.receiveShadow && (a.receiveShadow = !0), !1 === this.visible && (a.visible = !1), !1 === this.frustumCulled && (a.frustumCulled = !1), 0 !== this.renderOrder && (a.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (a.userData = this.userData), a.layers = this.layers.mask, a.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (a.matrixAutoUpdate = !1), this.isInstancedMesh && (a.type = "InstancedMesh", a.count = this.count, a.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) { a.geometry = t(e.geometries, this.geometry); var o = this.geometry.parameters; if (void 0 !== o && void 0 !== o.shapes)
                            if (o = o.shapes, Array.isArray(o))
                                for (var s = 0, c = o.length; s < c; s++) t(e.shapes, o[s]);
                            else t(e.shapes, o) } if (void 0 !== this.material)
                        if (Array.isArray(this.material)) { for (o = [], s = 0, c = this.material.length; s < c; s++) o.push(t(e.materials, this.material[s]));
                            a.material = o } else a.material = t(e.materials, this.material); if (0 < this.children.length)
                        for (a.children = [], s = 0; s < this.children.length; s++) a.children.push(this.children[s].toJSON(e).object); if (i) { i = n(e.geometries), s = n(e.materials), c = n(e.textures); var l = n(e.images);
                        o = n(e.shapes), 0 < i.length && (r.geometries = i), 0 < s.length && (r.materials = s), 0 < c.length && (r.textures = c), 0 < l.length && (r.images = l), 0 < o.length && (r.shapes = o) } return r.object = a, r }, clone: function(e) { return (new this.constructor).copy(this, e) }, copy: function(e, t) { if (void 0 === t && (t = !0), this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                        for (t = 0; t < e.children.length; t++) this.add(e.children[t].clone()); return this } }), f.prototype = Object.assign(Object.create(d.prototype), { constructor: f, isScene: !0, copy: function(e, t) { return d.prototype.copy.call(this, e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this }, toJSON: function(e) { var t = d.prototype.toJSON.call(this, e); return null !== this.background && (t.object.background = this.background.toJSON(e)), null !== this.environment && (t.object.environment = this.environment.toJSON(e)), null !== this.fog && (t.object.fog = this.fog.toJSON()), t }, dispose: function() { this.dispatchEvent({ type: "dispose" }) } }); var io = [new l, new l, new l, new l, new l, new l, new l, new l],
                ro = new l,
                ao = new m,
                oo = new l,
                so = new l,
                co = new l,
                lo = new l,
                ho = new l,
                uo = new l,
                po = new l,
                fo = new l,
                mo = new l,
                go = new l;
            Object.assign(m.prototype, { isBox3: !0, set: function(e, t) { return this.min.copy(e), this.max.copy(t), this }, setFromArray: function(e) { for (var t = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, c = e.length; s < c; s += 3) { var l = e[s],
                            h = e[s + 1],
                            u = e[s + 2];
                        l < t && (t = l), h < n && (n = h), u < i && (i = u), l > r && (r = l), h > a && (a = h), u > o && (o = u) } return this.min.set(t, n, i), this.max.set(r, a, o), this }, setFromBufferAttribute: function(e) { for (var t = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, c = e.count; s < c; s++) { var l = e.getX(s),
                            h = e.getY(s),
                            u = e.getZ(s);
                        l < t && (t = l), h < n && (n = h), u < i && (i = u), l > r && (r = l), h > a && (a = h), u > o && (o = u) } return this.min.set(t, n, i), this.max.set(r, a, o), this }, setFromPoints: function(e) { this.makeEmpty(); for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]); return this }, setFromCenterAndSize: function(e, t) { return t = ro.copy(t).multiplyScalar(.5), this.min.copy(e).sub(t), this.max.copy(e).add(t), this }, setFromObject: function(e) { return this.makeEmpty(), this.expandByObject(e) }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.min.copy(e.min), this.max.copy(e.max), this }, makeEmpty: function() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this }, isEmpty: function() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z }, getCenter: function(e) { return void 0 === e && (console.warn("THREE.Box3: .getCenter() target is now required"), e = new l), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) }, getSize: function(e) { return void 0 === e && (console.warn("THREE.Box3: .getSize() target is now required"), e = new l), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min) }, expandByPoint: function(e) { return this.min.min(e), this.max.max(e), this }, expandByVector: function(e) { return this.min.sub(e), this.max.add(e), this }, expandByScalar: function(e) { return this.min.addScalar(-e), this.max.addScalar(e), this }, expandByObject: function(e) { e.updateWorldMatrix(!1, !1); var t = e.geometry;
                    void 0 !== t && (null === t.boundingBox && t.computeBoundingBox(), ao.copy(t.boundingBox), ao.applyMatrix4(e.matrixWorld), this.union(ao)), t = 0; for (var n = (e = e.children).length; t < n; t++) this.expandByObject(e[t]); return this }, containsPoint: function(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z) }, containsBox: function(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z }, getParameter: function(e, t) { return void 0 === t && (console.warn("THREE.Box3: .getParameter() target is now required"), t = new l), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z)) }, intersectsBox: function(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z) }, intersectsSphere: function(e) { return this.clampPoint(e.center, ro), ro.distanceToSquared(e.center) <= e.radius * e.radius }, intersectsPlane: function(e) { if (0 < e.normal.x) var t = e.normal.x * this.min.x,
                        n = e.normal.x * this.max.x;
                    else t = e.normal.x * this.max.x, n = e.normal.x * this.min.x; return 0 < e.normal.y ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), 0 < e.normal.z ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant }, intersectsTriangle: function(e) { return !this.isEmpty() && (this.getCenter(po), fo.subVectors(this.max, po), oo.subVectors(e.a, po), so.subVectors(e.b, po), co.subVectors(e.c, po), lo.subVectors(so, oo), ho.subVectors(co, so), uo.subVectors(oo, co), !!g(e = [0, -lo.z, lo.y, 0, -ho.z, ho.y, 0, -uo.z, uo.y, lo.z, 0, -lo.x, ho.z, 0, -ho.x, uo.z, 0, -uo.x, -lo.y, lo.x, 0, -ho.y, ho.x, 0, -uo.y, uo.x, 0], oo, so, co, fo) && (!!g(e = [1, 0, 0, 0, 1, 0, 0, 0, 1], oo, so, co, fo) && (mo.crossVectors(lo, ho), g(e = [mo.x, mo.y, mo.z], oo, so, co, fo)))) }, clampPoint: function(e, t) { return void 0 === t && (console.warn("THREE.Box3: .clampPoint() target is now required"), t = new l), t.copy(e).clamp(this.min, this.max) }, distanceToPoint: function(e) { return ro.copy(e).clamp(this.min, this.max).sub(e).length() }, getBoundingSphere: function(e) { return void 0 === e && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(e.center), e.radius = .5 * this.getSize(ro).length(), e }, intersect: function(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this }, union: function(e) { return this.min.min(e.min), this.max.max(e.max), this }, applyMatrix4: function(e) { return this.isEmpty() ? this : (io[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), io[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), io[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), io[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), io[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), io[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), io[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), io[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(io), this) }, translate: function(e) { return this.min.add(e), this.max.add(e), this }, equals: function(e) { return e.min.equals(this.min) && e.max.equals(this.max) } }); var vo = new m;
            Object.assign(v.prototype, { set: function(e, t) { return this.center.copy(e), this.radius = t, this }, setFromPoints: function(e, t) { var n = this.center;
                    void 0 !== t ? n.copy(t) : vo.setFromPoints(e).getCenter(n); for (var i = t = 0, r = e.length; i < r; i++) t = Math.max(t, n.distanceToSquared(e[i])); return this.radius = Math.sqrt(t), this }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.center.copy(e.center), this.radius = e.radius, this }, isEmpty: function() { return 0 > this.radius }, makeEmpty: function() { return this.center.set(0, 0, 0), this.radius = -1, this }, containsPoint: function(e) { return e.distanceToSquared(this.center) <= this.radius * this.radius }, distanceToPoint: function(e) { return e.distanceTo(this.center) - this.radius }, intersectsSphere: function(e) { var t = this.radius + e.radius; return e.center.distanceToSquared(this.center) <= t * t }, intersectsBox: function(e) { return e.intersectsSphere(this) }, intersectsPlane: function(e) { return Math.abs(e.distanceToPoint(this.center)) <= this.radius }, clampPoint: function(e, t) { var n = this.center.distanceToSquared(e); return void 0 === t && (console.warn("THREE.Sphere: .clampPoint() target is now required"), t = new l), t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t }, getBoundingBox: function(e) { return void 0 === e && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), e = new m), this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e) }, applyMatrix4: function(e) { return this.center.applyMatrix4(e), this.radius *= e.getMaxScaleOnAxis(), this }, translate: function(e) { return this.center.add(e), this }, equals: function(e) { return e.center.equals(this.center) && e.radius === this.radius } }); var yo = new l,
                xo = new l,
                _o = new l,
                bo = new l,
                wo = new l,
                Mo = new l,
                So = new l;
            Object.assign(y.prototype, { set: function(e, t) { return this.origin.copy(e), this.direction.copy(t), this }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.origin.copy(e.origin), this.direction.copy(e.direction), this }, at: function(e, t) { return void 0 === t && (console.warn("THREE.Ray: .at() target is now required"), t = new l), t.copy(this.direction).multiplyScalar(e).add(this.origin) }, lookAt: function(e) { return this.direction.copy(e).sub(this.origin).normalize(), this }, recast: function(e) { return this.origin.copy(this.at(e, yo)), this }, closestPointToPoint: function(e, t) { return void 0 === t && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), t = new l), t.subVectors(e, this.origin), 0 > (e = t.dot(this.direction)) ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(e).add(this.origin) }, distanceToPoint: function(e) { return Math.sqrt(this.distanceSqToPoint(e)) }, distanceSqToPoint: function(e) { var t = yo.subVectors(e, this.origin).dot(this.direction); return 0 > t ? this.origin.distanceToSquared(e) : (yo.copy(this.direction).multiplyScalar(t).add(this.origin), yo.distanceToSquared(e)) }, distanceSqToSegment: function(e, t, n, i) { xo.copy(e).add(t).multiplyScalar(.5), _o.copy(t).sub(e).normalize(), bo.copy(this.origin).sub(xo); var r = .5 * e.distanceTo(t),
                        a = -this.direction.dot(_o),
                        o = bo.dot(this.direction),
                        s = -bo.dot(_o),
                        c = bo.lengthSq(),
                        l = Math.abs(1 - a * a); if (0 < l) { t = a * o - s; var h = r * l;
                        0 <= (e = a * s - o) ? t >= -h ? t <= h ? a = (e *= r = 1 / l) * (e + a * (t *= r) + 2 * o) + t * (a * e + t + 2 * s) + c : (t = r, a = -(e = Math.max(0, -(a * t + o))) * e + t * (t + 2 * s) + c) : (t = -r, a = -(e = Math.max(0, -(a * t + o))) * e + t * (t + 2 * s) + c) : t <= -h ? a = -(e = Math.max(0, -(-a * r + o))) * e + (t = 0 < e ? -r : Math.min(Math.max(-r, -s), r)) * (t + 2 * s) + c : t <= h ? (e = 0, a = (t = Math.min(Math.max(-r, -s), r)) * (t + 2 * s) + c) : a = -(e = Math.max(0, -(a * r + o))) * e + (t = 0 < e ? r : Math.min(Math.max(-r, -s), r)) * (t + 2 * s) + c } else t = 0 < a ? -r : r, a = -(e = Math.max(0, -(a * t + o))) * e + t * (t + 2 * s) + c; return n && n.copy(this.direction).multiplyScalar(e).add(this.origin), i && i.copy(_o).multiplyScalar(t).add(xo), a }, intersectSphere: function(e, t) { yo.subVectors(e.center, this.origin); var n = yo.dot(this.direction),
                        i = yo.dot(yo) - n * n; return i > (e = e.radius * e.radius) ? null : (i = n - (e = Math.sqrt(e - i)), n += e, 0 > i && 0 > n ? null : 0 > i ? this.at(n, t) : this.at(i, t)) }, intersectsSphere: function(e) { return this.distanceSqToPoint(e.center) <= e.radius * e.radius }, distanceToPlane: function(e) { var t = e.normal.dot(this.direction); return 0 === t ? 0 === e.distanceToPoint(this.origin) ? 0 : null : 0 <= (e = -(this.origin.dot(e.normal) + e.constant) / t) ? e : null }, intersectPlane: function(e, t) { return null === (e = this.distanceToPlane(e)) ? null : this.at(e, t) }, intersectsPlane: function(e) { var t = e.distanceToPoint(this.origin); return 0 === t || 0 > e.normal.dot(this.direction) * t }, intersectBox: function(e, t) { var n = 1 / this.direction.x,
                        i = 1 / this.direction.y,
                        r = 1 / this.direction.z,
                        a = this.origin; if (0 <= n) { var o = (e.min.x - a.x) * n;
                        n *= e.max.x - a.x } else o = (e.max.x - a.x) * n, n *= e.min.x - a.x; if (0 <= i) { var s = (e.min.y - a.y) * i;
                        i *= e.max.y - a.y } else s = (e.max.y - a.y) * i, i *= e.min.y - a.y; return o > i || s > n ? null : ((s > o || o != o) && (o = s), (i < n || n != n) && (n = i), 0 <= r ? (s = (e.min.z - a.z) * r, e = (e.max.z - a.z) * r) : (s = (e.max.z - a.z) * r, e = (e.min.z - a.z) * r), o > e || s > n ? null : ((s > o || o != o) && (o = s), (e < n || n != n) && (n = e), 0 > n ? null : this.at(0 <= o ? o : n, t))) }, intersectsBox: function(e) { return null !== this.intersectBox(e, yo) }, intersectTriangle: function(e, t, n, i, r) { if (wo.subVectors(t, e), Mo.subVectors(n, e), So.crossVectors(wo, Mo), 0 < (t = this.direction.dot(So))) { if (i) return null;
                        i = 1 } else { if (!(0 > t)) return null;
                        i = -1, t = -t } return bo.subVectors(this.origin, e), 0 > (e = i * this.direction.dot(Mo.crossVectors(bo, Mo))) ? null : 0 > (n = i * this.direction.dot(wo.cross(bo))) || e + n > t ? null : 0 > (e = -i * bo.dot(So)) ? null : this.at(e / t, r) }, applyMatrix4: function(e) { return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this }, equals: function(e) { return e.origin.equals(this.origin) && e.direction.equals(this.direction) } }); var To = new l,
                Eo = new l,
                Ao = new i;
            Object.assign(x.prototype, { isPlane: !0, set: function(e, t) { return this.normal.copy(e), this.constant = t, this }, setComponents: function(e, t, n, i) { return this.normal.set(e, t, n), this.constant = i, this }, setFromNormalAndCoplanarPoint: function(e, t) { return this.normal.copy(e), this.constant = -t.dot(this.normal), this }, setFromCoplanarPoints: function(e, t, n) { return t = To.subVectors(n, t).cross(Eo.subVectors(e, t)).normalize(), this.setFromNormalAndCoplanarPoint(t, e), this }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.normal.copy(e.normal), this.constant = e.constant, this }, normalize: function() { var e = 1 / this.normal.length(); return this.normal.multiplyScalar(e), this.constant *= e, this }, negate: function() { return this.constant *= -1, this.normal.negate(), this }, distanceToPoint: function(e) { return this.normal.dot(e) + this.constant }, distanceToSphere: function(e) { return this.distanceToPoint(e.center) - e.radius }, projectPoint: function(e, t) { return void 0 === t && (console.warn("THREE.Plane: .projectPoint() target is now required"), t = new l), t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e) }, intersectLine: function(e, t) { void 0 === t && (console.warn("THREE.Plane: .intersectLine() target is now required"), t = new l); var n = e.delta(To),
                        i = this.normal.dot(n); if (0 === i) { if (0 === this.distanceToPoint(e.start)) return t.copy(e.start) } else if (!(0 > (i = -(e.start.dot(this.normal) + this.constant) / i) || 1 < i)) return t.copy(n).multiplyScalar(i).add(e.start) }, intersectsLine: function(e) { var t = this.distanceToPoint(e.start); return e = this.distanceToPoint(e.end), 0 > t && 0 < e || 0 > e && 0 < t }, intersectsBox: function(e) { return e.intersectsPlane(this) }, intersectsSphere: function(e) { return e.intersectsPlane(this) }, coplanarPoint: function(e) { return void 0 === e && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), e = new l), e.copy(this.normal).multiplyScalar(-this.constant) }, applyMatrix4: function(e, t) { return t = t || Ao.getNormalMatrix(e), e = this.coplanarPoint(To).applyMatrix4(e), t = this.normal.applyMatrix3(t).normalize(), this.constant = -e.dot(t), this }, translate: function(e) { return this.constant -= e.dot(this.normal), this }, equals: function(e) { return e.normal.equals(this.normal) && e.constant === this.constant } }); var Lo = new l,
                Ro = new l,
                Po = new l,
                Co = new l,
                Oo = new l,
                Do = new l,
                Io = new l,
                No = new l,
                Bo = new l,
                zo = new l;
            Object.assign(_, { getNormal: function(e, t, n, i) { return void 0 === i && (console.warn("THREE.Triangle: .getNormal() target is now required"), i = new l), i.subVectors(n, t), Lo.subVectors(e, t), i.cross(Lo), 0 < (e = i.lengthSq()) ? i.multiplyScalar(1 / Math.sqrt(e)) : i.set(0, 0, 0) }, getBarycoord: function(e, t, n, i, r) { Lo.subVectors(i, t), Ro.subVectors(n, t), Po.subVectors(e, t), e = Lo.dot(Lo), t = Lo.dot(Ro), n = Lo.dot(Po); var a = Ro.dot(Ro);
                    i = Ro.dot(Po); var o = e * a - t * t; return void 0 === r && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), r = new l), 0 === o ? r.set(-2, -1, -1) : (a = (a * n - t * i) * (o = 1 / o), e = (e * i - t * n) * o, r.set(1 - a - e, e, a)) }, containsPoint: function(e, t, n, i) { return _.getBarycoord(e, t, n, i, Co), 0 <= Co.x && 0 <= Co.y && 1 >= Co.x + Co.y }, getUV: function(e, t, n, i, r, a, o, s) { return this.getBarycoord(e, t, n, i, Co), s.set(0, 0), s.addScaledVector(r, Co.x), s.addScaledVector(a, Co.y), s.addScaledVector(o, Co.z), s }, isFrontFacing: function(e, t, n, i) { return Lo.subVectors(n, t), Ro.subVectors(e, t), 0 > Lo.cross(Ro).dot(i) } }), Object.assign(_.prototype, { set: function(e, t, n) { return this.a.copy(e), this.b.copy(t), this.c.copy(n), this }, setFromPointsAndIndices: function(e, t, n, i) { return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this }, getArea: function() { return Lo.subVectors(this.c, this.b), Ro.subVectors(this.a, this.b), .5 * Lo.cross(Ro).length() }, getMidpoint: function(e) { return void 0 === e && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), e = new l), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) }, getNormal: function(e) { return _.getNormal(this.a, this.b, this.c, e) }, getPlane: function(e) { return void 0 === e && (console.warn("THREE.Triangle: .getPlane() target is now required"), e = new x), e.setFromCoplanarPoints(this.a, this.b, this.c) }, getBarycoord: function(e, t) { return _.getBarycoord(e, this.a, this.b, this.c, t) }, getUV: function(e, t, n, i, r) { return _.getUV(e, this.a, this.b, this.c, t, n, i, r) }, containsPoint: function(e) { return _.containsPoint(e, this.a, this.b, this.c) }, isFrontFacing: function(e) { return _.isFrontFacing(this.a, this.b, this.c, e) }, intersectsBox: function(e) { return e.intersectsTriangle(this) }, closestPointToPoint: function(e, t) { void 0 === t && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), t = new l); var n = this.a,
                        i = this.b,
                        r = this.c;
                    Oo.subVectors(i, n), Do.subVectors(r, n), No.subVectors(e, n); var a = Oo.dot(No),
                        o = Do.dot(No); if (0 >= a && 0 >= o) return t.copy(n);
                    Bo.subVectors(e, i); var s = Oo.dot(Bo),
                        c = Do.dot(Bo); if (0 <= s && c <= s) return t.copy(i); var h = a * c - s * o; if (0 >= h && 0 <= a && 0 >= s) return i = a / (a - s), t.copy(n).addScaledVector(Oo, i);
                    zo.subVectors(e, r), e = Oo.dot(zo); var u = Do.dot(zo); return 0 <= u && e <= u ? t.copy(r) : 0 >= (a = e * o - a * u) && 0 <= o && 0 >= u ? (h = o / (o - u), t.copy(n).addScaledVector(Do, h)) : 0 >= (o = s * u - e * c) && 0 <= c - s && 0 <= e - u ? (Io.subVectors(r, i), h = (c - s) / (c - s + (e - u)), t.copy(i).addScaledVector(Io, h)) : (i = a * (r = 1 / (o + a + h)), h *= r, t.copy(n).addScaledVector(Oo, i).addScaledVector(Do, h)) }, equals: function(e) { return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c) } }); var Uo = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 },
                Fo = { h: 0, s: 0, l: 0 },
                Go = { h: 0, s: 0, l: 0 };
            Object.assign(b.prototype, { isColor: !0, r: 1, g: 1, b: 1, set: function(e) { return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this }, setScalar: function(e) { return this.b = this.g = this.r = e, this }, setHex: function(e) { return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this }, setRGB: function(e, t, n) { return this.r = e, this.g = t, this.b = n, this }, setHSL: function(e, t, n) { return e = Ra.euclideanModulo(e, 1), t = Ra.clamp(t, 0, 1), n = Ra.clamp(n, 0, 1), 0 === t ? this.r = this.g = this.b = n : (n = 2 * n - (t = .5 >= n ? n * (1 + t) : n + t - n * t), this.r = w(n, t, e + 1 / 3), this.g = w(n, t, e), this.b = w(n, t, e - 1 / 3)), this }, setStyle: function(e) {
                    function t(t) { void 0 !== t && 1 > parseFloat(t) && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.") } var n; if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) { var i = n[2]; switch (n[1]) {
                            case "rgb":
                            case "rgba":
                                if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(i)) return this.r = Math.min(255, parseInt(n[1], 10)) / 255, this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, t(n[5]), this; if (n = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(i)) return this.r = Math.min(100, parseInt(n[1], 10)) / 100, this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, t(n[5]), this; break;
                            case "hsl":
                            case "hsla":
                                if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(i)) { i = parseFloat(n[1]) / 360; var r = parseInt(n[2], 10) / 100,
                                        a = parseInt(n[3], 10) / 100; return t(n[5]), this.setHSL(i, r, a) } } } else if (n = /^#([A-Fa-f0-9]+)$/.exec(e)) { if (3 === (i = (n = n[1]).length)) return this.r = parseInt(n.charAt(0) + n.charAt(0), 16) / 255, this.g = parseInt(n.charAt(1) + n.charAt(1), 16) / 255, this.b = parseInt(n.charAt(2) + n.charAt(2), 16) / 255, this; if (6 === i) return this.r = parseInt(n.charAt(0) + n.charAt(1), 16) / 255, this.g = parseInt(n.charAt(2) + n.charAt(3), 16) / 255, this.b = parseInt(n.charAt(4) + n.charAt(5), 16) / 255, this } return e && 0 < e.length ? this.setColorName(e) : this }, setColorName: function(e) { var t = Uo[e]; return void 0 !== t ? this.setHex(t) : console.warn("THREE.Color: Unknown color " + e), this }, clone: function() { return new this.constructor(this.r, this.g, this.b) }, copy: function(e) { return this.r = e.r, this.g = e.g, this.b = e.b, this }, copyGammaToLinear: function(e, t) { return void 0 === t && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this }, copyLinearToGamma: function(e, t) { return void 0 === t && (t = 2), t = 0 < t ? 1 / t : 1, this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this }, convertGammaToLinear: function(e) { return this.copyGammaToLinear(this, e), this }, convertLinearToGamma: function(e) { return this.copyLinearToGamma(this, e), this }, copySRGBToLinear: function(e) { return this.r = M(e.r), this.g = M(e.g), this.b = M(e.b), this }, copyLinearToSRGB: function(e) { return this.r = S(e.r), this.g = S(e.g), this.b = S(e.b), this }, convertSRGBToLinear: function() { return this.copySRGBToLinear(this), this }, convertLinearToSRGB: function() { return this.copyLinearToSRGB(this), this }, getHex: function() { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 }, getHexString: function() { return ("000000" + this.getHex().toString(16)).slice(-6) }, getHSL: function(e) { void 0 === e && (console.warn("THREE.Color: .getHSL() target is now required"), e = { h: 0, s: 0, l: 0 }); var t, n = this.r,
                        i = this.g,
                        r = this.b,
                        a = Math.max(n, i, r),
                        o = Math.min(n, i, r),
                        s = (o + a) / 2; if (o === a) o = t = 0;
                    else { var c = a - o; switch (o = .5 >= s ? c / (a + o) : c / (2 - a - o), a) {
                            case n:
                                t = (i - r) / c + (i < r ? 6 : 0); break;
                            case i:
                                t = (r - n) / c + 2; break;
                            case r:
                                t = (n - i) / c + 4 } t /= 6 } return e.h = t, e.s = o, e.l = s, e }, getStyle: function() { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")" }, offsetHSL: function(e, t, n) { return this.getHSL(Fo), Fo.h += e, Fo.s += t, Fo.l += n, this.setHSL(Fo.h, Fo.s, Fo.l), this }, add: function(e) { return this.r += e.r, this.g += e.g, this.b += e.b, this }, addColors: function(e, t) { return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this }, addScalar: function(e) { return this.r += e, this.g += e, this.b += e, this }, sub: function(e) { return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this }, multiply: function(e) { return this.r *= e.r, this.g *= e.g, this.b *= e.b, this }, multiplyScalar: function(e) { return this.r *= e, this.g *= e, this.b *= e, this }, lerp: function(e, t) { return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this }, lerpHSL: function(e, t) { this.getHSL(Fo), e.getHSL(Go), e = Ra.lerp(Fo.h, Go.h, t); var n = Ra.lerp(Fo.s, Go.s, t); return t = Ra.lerp(Fo.l, Go.l, t), this.setHSL(e, n, t), this }, equals: function(e) { return e.r === this.r && e.g === this.g && e.b === this.b }, fromArray: function(e, t) { return void 0 === t && (t = 0), this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this }, toArray: function(e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e }, toJSON: function() { return this.getHex() } }), b.NAMES = Uo, Object.assign(T.prototype, { clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex; for (var t = 0, n = e.vertexNormals.length; t < n; t++) this.vertexNormals[t] = e.vertexNormals[t].clone(); for (t = 0, n = e.vertexColors.length; t < n; t++) this.vertexColors[t] = e.vertexColors[t].clone(); return this } }); var Ho = 0;
            E.prototype = Object.assign(Object.create(t.prototype), { constructor: E, isMaterial: !0, onBeforeCompile: function() {}, setValues: function(e) { if (void 0 !== e)
                        for (var t in e) { var n = e[t]; if (void 0 === n) console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                            else if ("shading" === t) console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
                            else { var i = this[t];
                                void 0 === i ? console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.") : i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n } } }, toJSON: function(e) {
                    function t(e) { var t, n = []; for (t in e) { var i = e[t];
                            delete i.metadata, n.push(i) } return n } var n = void 0 === e || "string" == typeof e;
                    n && (e = { textures: {}, images: {} }); var i = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } }; return i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), this.sheen && this.sheen.isColor && (i.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, i.reflectivity = this.reflectivity, i.refractionRatio = this.refractionRatio, void 0 !== this.combine && (i.combine = this.combine), void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.size && (i.size = this.size), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (i.blending = this.blending), !0 === this.flatShading && (i.flatShading = this.flatShading), 0 !== this.side && (i.side = this.side), this.vertexColors && (i.vertexColors = !0), 1 > this.opacity && (i.opacity = this.opacity), !0 === this.transparent && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, i.stencilWrite = this.stencilWrite, i.stencilWriteMask = this.stencilWriteMask, i.stencilFunc = this.stencilFunc, i.stencilRef = this.stencilRef, i.stencilFuncMask = this.stencilFuncMask, i.stencilFail = this.stencilFail, i.stencilZFail = this.stencilZFail, i.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (i.rotation = this.rotation), !0 === this.polygonOffset && (i.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize && (i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this.gapSize), void 0 !== this.scale && (i.scale = this.scale), !0 === this.dithering && (i.dithering = !0), 0 < this.alphaTest && (i.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (i.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (i.morphTargets = !0), !0 === this.morphNormals && (i.morphNormals = !0), !0 === this.skinning && (i.skinning = !0), !1 === this.visible && (i.visible = !1), !1 === this.toneMapped && (i.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), n && (n = t(e.textures), e = t(e.images), 0 < n.length && (i.textures = n), 0 < e.length && (i.images = e)), i }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { this.name = e.name, this.fog = e.fog, this.blending = e.blending, this.side = e.side, this.flatShading = e.flatShading, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite; var t = e.clippingPlanes,
                        n = null; if (null !== t) { var i = t.length;
                        n = Array(i); for (var r = 0; r !== i; ++r) n[r] = t[r].clone() } return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this }, dispose: function() { this.dispatchEvent({ type: "dispose" }) } }), Object.defineProperty(E.prototype, "needsUpdate", { set: function(e) {!0 === e && this.version++ } }), A.prototype = Object.create(E.prototype), A.prototype.constructor = A, A.prototype.isMeshBasicMaterial = !0, A.prototype.copy = function(e) { return E.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this }; var ko = new l;
            Object.defineProperty(L.prototype, "needsUpdate", { set: function(e) {!0 === e && this.version++ } }), Object.assign(L.prototype, { isBufferAttribute: !0, onUploadCallback: function() {}, setUsage: function(e) { return this.usage = e, this }, copy: function(e) { return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this }, copyAt: function(e, t, n) { e *= this.itemSize, n *= t.itemSize; for (var i = 0, r = this.itemSize; i < r; i++) this.array[e + i] = t.array[n + i]; return this }, copyArray: function(e) { return this.array.set(e), this }, copyColorsArray: function(e) { for (var t = this.array, n = 0, i = 0, r = e.length; i < r; i++) { var a = e[i];
                        void 0 === a && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), a = new b), t[n++] = a.r, t[n++] = a.g, t[n++] = a.b } return this }, copyVector2sArray: function(e) { for (var t = this.array, i = 0, r = 0, a = e.length; r < a; r++) { var o = e[r];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), o = new n), t[i++] = o.x, t[i++] = o.y } return this }, copyVector3sArray: function(e) { for (var t = this.array, n = 0, i = 0, r = e.length; i < r; i++) { var a = e[i];
                        void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), a = new l), t[n++] = a.x, t[n++] = a.y, t[n++] = a.z } return this }, copyVector4sArray: function(e) { for (var t = this.array, n = 0, i = 0, r = e.length; i < r; i++) { var o = e[i];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), o = new a), t[n++] = o.x, t[n++] = o.y, t[n++] = o.z, t[n++] = o.w } return this }, applyMatrix3: function(e) { for (var t = 0, n = this.count; t < n; t++) ko.x = this.getX(t), ko.y = this.getY(t), ko.z = this.getZ(t), ko.applyMatrix3(e), this.setXYZ(t, ko.x, ko.y, ko.z); return this }, applyMatrix4: function(e) { for (var t = 0, n = this.count; t < n; t++) ko.x = this.getX(t), ko.y = this.getY(t), ko.z = this.getZ(t), ko.applyMatrix4(e), this.setXYZ(t, ko.x, ko.y, ko.z); return this }, applyNormalMatrix: function(e) { for (var t = 0, n = this.count; t < n; t++) ko.x = this.getX(t), ko.y = this.getY(t), ko.z = this.getZ(t), ko.applyNormalMatrix(e), this.setXYZ(t, ko.x, ko.y, ko.z); return this }, transformDirection: function(e) { for (var t = 0, n = this.count; t < n; t++) ko.x = this.getX(t), ko.y = this.getY(t), ko.z = this.getZ(t), ko.transformDirection(e), this.setXYZ(t, ko.x, ko.y, ko.z); return this }, set: function(e, t) { return void 0 === t && (t = 0), this.array.set(e, t), this }, getX: function(e) { return this.array[e * this.itemSize] }, setX: function(e, t) { return this.array[e * this.itemSize] = t, this }, getY: function(e) { return this.array[e * this.itemSize + 1] }, setY: function(e, t) { return this.array[e * this.itemSize + 1] = t, this }, getZ: function(e) { return this.array[e * this.itemSize + 2] }, setZ: function(e, t) { return this.array[e * this.itemSize + 2] = t, this }, getW: function(e) { return this.array[e * this.itemSize + 3] }, setW: function(e, t) { return this.array[e * this.itemSize + 3] = t, this }, setXY: function(e, t, n) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this }, setXYZ: function(e, t, n, i) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this }, setXYZW: function(e, t, n, i, r) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = r, this }, onUpload: function(e) { return this.onUploadCallback = e, this }, clone: function() { return new this.constructor(this.array, this.itemSize).copy(this) }, toJSON: function() { return { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized } } }), R.prototype = Object.create(L.prototype), R.prototype.constructor = R, P.prototype = Object.create(L.prototype), P.prototype.constructor = P, C.prototype = Object.create(L.prototype), C.prototype.constructor = C, O.prototype = Object.create(L.prototype), O.prototype.constructor = O, D.prototype = Object.create(L.prototype), D.prototype.constructor = D, I.prototype = Object.create(L.prototype), I.prototype.constructor = I, N.prototype = Object.create(L.prototype), N.prototype.constructor = N, B.prototype = Object.create(L.prototype), B.prototype.constructor = B, z.prototype = Object.create(L.prototype), z.prototype.constructor = z, Object.assign(U.prototype, { computeGroups: function(e) { var t = [],
                        n = void 0;
                    e = e.faces; for (var i = 0; i < e.length; i++) { var r = e[i]; if (r.materialIndex !== n) { n = r.materialIndex, void 0 !== a && (a.count = 3 * i - a.start, t.push(a)); var a = { start: 3 * i, materialIndex: n } } } void 0 !== a && (a.count = 3 * i - a.start, t.push(a)), this.groups = t }, fromGeometry: function(e) { var t = e.faces,
                        i = e.vertices,
                        r = e.faceVertexUvs,
                        a = r[0] && 0 < r[0].length,
                        o = r[1] && 0 < r[1].length,
                        s = e.morphTargets,
                        c = s.length; if (0 < c) { for (var l = [], h = 0; h < c; h++) l[h] = { name: s[h].name, data: [] };
                        this.morphTargets.position = l } var u = e.morphNormals,
                        p = u.length; if (0 < p) { var d = []; for (h = 0; h < p; h++) d[h] = { name: u[h].name, data: [] };
                        this.morphTargets.normal = d } var f = e.skinIndices,
                        m = e.skinWeights,
                        g = f.length === i.length,
                        v = m.length === i.length; for (0 < i.length && 0 === t.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported."), h = 0; h < t.length; h++) { var y = t[h];
                        this.vertices.push(i[y.a], i[y.b], i[y.c]); var x = y.vertexNormals; for (3 === x.length ? this.normals.push(x[0], x[1], x[2]) : (x = y.normal, this.normals.push(x, x, x)), 3 === (x = y.vertexColors).length ? this.colors.push(x[0], x[1], x[2]) : (x = y.color, this.colors.push(x, x, x)), !0 === a && (void 0 !== (x = r[0][h]) ? this.uvs.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h), this.uvs.push(new n, new n, new n))), !0 === o && (void 0 !== (x = r[1][h]) ? this.uvs2.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h), this.uvs2.push(new n, new n, new n))), x = 0; x < c; x++) { var _ = s[x].vertices;
                            l[x].data.push(_[y.a], _[y.b], _[y.c]) } for (x = 0; x < p; x++) _ = u[x].vertexNormals[h], d[x].data.push(_.a, _.b, _.c);
                        g && this.skinIndices.push(f[y.a], f[y.b], f[y.c]), v && this.skinWeights.push(m[y.a], m[y.b], m[y.c]) } return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this } }); var Vo = 1,
                jo = new h,
                Wo = new d,
                qo = new l,
                Xo = new m,
                Yo = new m,
                Zo = new l;
            G.prototype = Object.assign(Object.create(t.prototype), { constructor: G, isBufferGeometry: !0, getIndex: function() { return this.index }, setIndex: function(e) { Array.isArray(e) ? this.index = new(65535 < F(e) ? N : D)(e, 1) : this.index = e }, getAttribute: function(e) { return this.attributes[e] }, setAttribute: function(e, t) { return this.attributes[e] = t, this }, deleteAttribute: function(e) { return delete this.attributes[e], this }, addGroup: function(e, t, n) { this.groups.push({ start: e, count: t, materialIndex: void 0 !== n ? n : 0 }) }, clearGroups: function() { this.groups = [] }, setDrawRange: function(e, t) { this.drawRange.start = e, this.drawRange.count = t }, applyMatrix4: function(e) { var t = this.attributes.position; if (void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0), void 0 !== (t = this.attributes.normal)) { var n = (new i).getNormalMatrix(e);
                        t.applyNormalMatrix(n), t.needsUpdate = !0 } return void 0 !== (t = this.attributes.tangent) && (t.transformDirection(e), t.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this }, rotateX: function(e) { return jo.makeRotationX(e), this.applyMatrix4(jo), this }, rotateY: function(e) { return jo.makeRotationY(e), this.applyMatrix4(jo), this }, rotateZ: function(e) { return jo.makeRotationZ(e), this.applyMatrix4(jo), this }, translate: function(e, t, n) { return jo.makeTranslation(e, t, n), this.applyMatrix4(jo), this }, scale: function(e, t, n) { return jo.makeScale(e, t, n), this.applyMatrix4(jo), this }, lookAt: function(e) { return Wo.lookAt(e), Wo.updateMatrix(), this.applyMatrix4(Wo.matrix), this }, center: function() { return this.computeBoundingBox(), this.boundingBox.getCenter(qo).negate(), this.translate(qo.x, qo.y, qo.z), this }, setFromObject: function(e) { var t = e.geometry; if (e.isPoints || e.isLine) { e = new B(3 * t.vertices.length, 3); var n = new B(3 * t.colors.length, 3);
                        this.setAttribute("position", e.copyVector3sArray(t.vertices)), this.setAttribute("color", n.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length && (e = new B(t.lineDistances.length, 1), this.setAttribute("lineDistance", e.copyArray(t.lineDistances))), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()) } else e.isMesh && t && t.isGeometry && this.fromGeometry(t); return this }, setFromPoints: function(e) { for (var t = [], n = 0, i = e.length; n < i; n++) { var r = e[n];
                        t.push(r.x, r.y, r.z || 0) } return this.setAttribute("position", new B(t, 3)), this }, updateFromObject: function(e) { var t = e.geometry; if (e.isMesh) { var n = t.__directGeometry; if (!0 === t.elementsNeedUpdate && (n = void 0, t.elementsNeedUpdate = !1), void 0 === n) return this.fromGeometry(t);
                        n.verticesNeedUpdate = t.verticesNeedUpdate, n.normalsNeedUpdate = t.normalsNeedUpdate, n.colorsNeedUpdate = t.colorsNeedUpdate, n.uvsNeedUpdate = t.uvsNeedUpdate, n.groupsNeedUpdate = t.groupsNeedUpdate, t.verticesNeedUpdate = !1, t.normalsNeedUpdate = !1, t.colorsNeedUpdate = !1, t.uvsNeedUpdate = !1, t.groupsNeedUpdate = !1, t = n } return !0 === t.verticesNeedUpdate && (void 0 !== (n = this.attributes.position) && (n.copyVector3sArray(t.vertices), n.needsUpdate = !0), t.verticesNeedUpdate = !1), !0 === t.normalsNeedUpdate && (void 0 !== (n = this.attributes.normal) && (n.copyVector3sArray(t.normals), n.needsUpdate = !0), t.normalsNeedUpdate = !1), !0 === t.colorsNeedUpdate && (void 0 !== (n = this.attributes.color) && (n.copyColorsArray(t.colors), n.needsUpdate = !0), t.colorsNeedUpdate = !1), t.uvsNeedUpdate && (void 0 !== (n = this.attributes.uv) && (n.copyVector2sArray(t.uvs), n.needsUpdate = !0), t.uvsNeedUpdate = !1), t.lineDistancesNeedUpdate && (void 0 !== (n = this.attributes.lineDistance) && (n.copyArray(t.lineDistances), n.needsUpdate = !0), t.lineDistancesNeedUpdate = !1), t.groupsNeedUpdate && (t.computeGroups(e.geometry), this.groups = t.groups, t.groupsNeedUpdate = !1), this }, fromGeometry: function(e) { return e.__directGeometry = (new U).fromGeometry(e), this.fromDirectGeometry(e.__directGeometry) }, fromDirectGeometry: function(e) { var t = new Float32Array(3 * e.vertices.length); for (var n in this.setAttribute("position", new L(t, 3).copyVector3sArray(e.vertices)), 0 < e.normals.length && (t = new Float32Array(3 * e.normals.length), this.setAttribute("normal", new L(t, 3).copyVector3sArray(e.normals))), 0 < e.colors.length && (t = new Float32Array(3 * e.colors.length), this.setAttribute("color", new L(t, 3).copyColorsArray(e.colors))), 0 < e.uvs.length && (t = new Float32Array(2 * e.uvs.length), this.setAttribute("uv", new L(t, 2).copyVector2sArray(e.uvs))), 0 < e.uvs2.length && (t = new Float32Array(2 * e.uvs2.length), this.setAttribute("uv2", new L(t, 2).copyVector2sArray(e.uvs2))), this.groups = e.groups, e.morphTargets) { t = []; for (var i = e.morphTargets[n], r = 0, a = i.length; r < a; r++) { var o = i[r],
                                s = new B(3 * o.data.length, 3);
                            s.name = o.name, t.push(s.copyVector3sArray(o.data)) } this.morphAttributes[n] = t } return 0 < e.skinIndices.length && (n = new B(4 * e.skinIndices.length, 4), this.setAttribute("skinIndex", n.copyVector4sArray(e.skinIndices))), 0 < e.skinWeights.length && (n = new B(4 * e.skinWeights.length, 4), this.setAttribute("skinWeight", n.copyVector4sArray(e.skinWeights))), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this }, computeBoundingBox: function() { null === this.boundingBox && (this.boundingBox = new m); var e = this.attributes.position,
                        t = this.morphAttributes.position; if (void 0 !== e) { if (this.boundingBox.setFromBufferAttribute(e), t) { e = 0; for (var n = t.length; e < n; e++) Xo.setFromBufferAttribute(t[e]), this.morphTargetsRelative ? (Zo.addVectors(this.boundingBox.min, Xo.min), this.boundingBox.expandByPoint(Zo), Zo.addVectors(this.boundingBox.max, Xo.max), this.boundingBox.expandByPoint(Zo)) : (this.boundingBox.expandByPoint(Xo.min), this.boundingBox.expandByPoint(Xo.max)) } } else this.boundingBox.makeEmpty();
                    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) }, computeBoundingSphere: function() { null === this.boundingSphere && (this.boundingSphere = new v); var e = this.attributes.position,
                        t = this.morphAttributes.position; if (e) { var n = this.boundingSphere.center; if (Xo.setFromBufferAttribute(e), t)
                            for (var i = 0, r = t.length; i < r; i++) { var a = t[i];
                                Yo.setFromBufferAttribute(a), this.morphTargetsRelative ? (Zo.addVectors(Xo.min, Yo.min), Xo.expandByPoint(Zo), Zo.addVectors(Xo.max, Yo.max), Xo.expandByPoint(Zo)) : (Xo.expandByPoint(Yo.min), Xo.expandByPoint(Yo.max)) } Xo.getCenter(n); var o = 0; for (i = 0, r = e.count; i < r; i++) Zo.fromBufferAttribute(e, i), o = Math.max(o, n.distanceToSquared(Zo)); if (t)
                            for (i = 0, r = t.length; i < r; i++) { a = t[i]; for (var s = this.morphTargetsRelative, c = 0, l = a.count; c < l; c++) Zo.fromBufferAttribute(a, c), s && (qo.fromBufferAttribute(e, c), Zo.add(qo)), o = Math.max(o, n.distanceToSquared(Zo)) } this.boundingSphere.radius = Math.sqrt(o), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } }, computeFaceNormals: function() {}, computeVertexNormals: function() { var e = this.index,
                        t = this.attributes; if (t.position) { var n = t.position.array; if (void 0 === t.normal) this.setAttribute("normal", new L(new Float32Array(n.length), 3));
                        else
                            for (var i = t.normal.array, r = 0, a = i.length; r < a; r++) i[r] = 0;
                        i = t.normal.array; var o = new l,
                            s = new l,
                            c = new l,
                            h = new l,
                            u = new l; if (e) { var p = e.array; for (r = 0, a = e.count; r < a; r += 3) { e = 3 * p[r + 0]; var d = 3 * p[r + 1],
                                    f = 3 * p[r + 2];
                                o.fromArray(n, e), s.fromArray(n, d), c.fromArray(n, f), h.subVectors(c, s), u.subVectors(o, s), h.cross(u), i[e] += h.x, i[e + 1] += h.y, i[e + 2] += h.z, i[d] += h.x, i[d + 1] += h.y, i[d + 2] += h.z, i[f] += h.x, i[f + 1] += h.y, i[f + 2] += h.z } } else
                            for (r = 0, a = n.length; r < a; r += 9) o.fromArray(n, r), s.fromArray(n, r + 3), c.fromArray(n, r + 6), h.subVectors(c, s), u.subVectors(o, s), h.cross(u), i[r] = h.x, i[r + 1] = h.y, i[r + 2] = h.z, i[r + 3] = h.x, i[r + 4] = h.y, i[r + 5] = h.z, i[r + 6] = h.x, i[r + 7] = h.y, i[r + 8] = h.z;
                        this.normalizeNormals(), t.normal.needsUpdate = !0 } }, merge: function(e, t) { if (e && e.isBufferGeometry) { void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.")); var n, i = this.attributes; for (n in i)
                            if (void 0 !== e.attributes[n]) { var r = i[n].array,
                                    a = e.attributes[n],
                                    o = a.array,
                                    s = a.itemSize * t;
                                a = Math.min(o.length, r.length - s); for (var c = 0; c < a; c++, s++) r[s] = o[c] } return this } console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e) }, normalizeNormals: function() { for (var e = this.attributes.normal, t = 0, n = e.count; t < n; t++) Zo.x = e.getX(t), Zo.y = e.getY(t), Zo.z = e.getZ(t), Zo.normalize(), e.setXYZ(t, Zo.x, Zo.y, Zo.z) }, toNonIndexed: function() {
                    function e(e, t) { var n = e.array,
                            i = e.itemSize;
                        e = e.normalized; for (var r, a = new n.constructor(t.length * i), o = 0, s = 0, c = t.length; s < c; s++) { r = t[s] * i; for (var l = 0; l < i; l++) a[o++] = n[r++] } return new L(a, i, e) } if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this; var t, n = new G,
                        i = this.index.array,
                        r = this.attributes; for (t in r) { var a = r[t];
                        a = e(a, i), n.setAttribute(t, a) } var o = this.morphAttributes; for (t in o) { var s = [],
                            c = o[t];
                        r = 0; for (var l = c.length; r < l; r++) a = e(a = c[r], i), s.push(a);
                        n.morphAttributes[t] = s } for (n.morphTargetsRelative = this.morphTargetsRelative, r = 0, t = (i = this.groups).length; r < t; r++) a = i[r], n.addGroup(a.start, a.count, a.materialIndex); return n }, toJSON: function() { var e = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), 0 < Object.keys(this.userData).length && (e.userData = this.userData), void 0 !== this.parameters) { var t = this.parameters; for (l in t) void 0 !== t[l] && (e[l] = t[l]); return e } e.data = { attributes: {} }, null !== (t = this.index) && (e.data.index = { type: t.array.constructor.name, array: Array.prototype.slice.call(t.array) }); var n = this.attributes; for (l in n) { var i = (t = n[l]).toJSON(); "" !== t.name && (i.name = t.name), e.data.attributes[l] = i } n = {}; var r = !1; for (l in this.morphAttributes) { for (var a = this.morphAttributes[l], o = [], s = 0, c = a.length; s < c; s++) i = (t = a[s]).toJSON(), "" !== t.name && (i.name = t.name), o.push(i);
                        0 < o.length && (n[l] = o, r = !0) } r && (e.data.morphAttributes = n, e.data.morphTargetsRelative = this.morphTargetsRelative); var l = this.groups; return 0 < l.length && (e.data.groups = JSON.parse(JSON.stringify(l))), null !== (l = this.boundingSphere) && (e.data.boundingSphere = { center: l.center.toArray(), radius: l.radius }), e }, clone: function() { return (new G).copy(this) }, copy: function(e) { var t;
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.name = e.name; var n = e.index; for (o in null !== n && this.setIndex(n.clone()), n = e.attributes) this.setAttribute(o, n[o].clone()); var i = e.morphAttributes; for (o in i) { var r = [],
                            a = i[o]; for (n = 0, t = a.length; n < t; n++) r.push(a[n].clone());
                        this.morphAttributes[o] = r } this.morphTargetsRelative = e.morphTargetsRelative; var o = e.groups; for (n = 0, t = o.length; n < t; n++) i = o[n], this.addGroup(i.start, i.count, i.materialIndex); return null !== (o = e.boundingBox) && (this.boundingBox = o.clone()), null !== (o = e.boundingSphere) && (this.boundingSphere = o.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this }, dispose: function() { this.dispatchEvent({ type: "dispose" }) } }); var Jo = new h,
                Qo = new y,
                Ko = new v,
                $o = new l,
                es = new l,
                ts = new l,
                ns = new l,
                is = new l,
                rs = new l,
                as = new l,
                os = new l,
                ss = new l,
                cs = new n,
                ls = new n,
                hs = new n,
                us = new l,
                ps = new l;
            H.prototype = Object.assign(Object.create(d.prototype), { constructor: H, isMesh: !0, copy: function(e) { return d.prototype.copy.call(this, e), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this }, updateMorphTargets: function() { var e = this.geometry; if (e.isBufferGeometry) { e = e.morphAttributes; var t = Object.keys(e); if (0 < t.length) { var n = e[t[0]]; if (void 0 !== n)
                                for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = n.length; e < t; e++) { var i = n[e].name || String(e);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = e } } } else void 0 !== (e = e.morphTargets) && 0 < e.length && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") }, raycast: function(e, t) { var i = this.geometry,
                        r = this.material,
                        a = this.matrixWorld; if (void 0 !== r && (null === i.boundingSphere && i.computeBoundingSphere(), Ko.copy(i.boundingSphere), Ko.applyMatrix4(a), !1 !== e.ray.intersectsSphere(Ko) && (Jo.getInverse(a), Qo.copy(e.ray).applyMatrix4(Jo), null === i.boundingBox || !1 !== Qo.intersectsBox(i.boundingBox))))
                        if (i.isBufferGeometry) { var o = i.index;
                            a = i.attributes.position; var s, c, l = i.morphAttributes.position,
                                h = i.morphTargetsRelative,
                                u = i.attributes.uv,
                                p = i.attributes.uv2,
                                d = i.groups,
                                f = i.drawRange; if (null !== o)
                                if (Array.isArray(r)) { var m = 0; for (s = d.length; m < s; m++) { var g = d[m],
                                            v = r[g.materialIndex],
                                            y = Math.max(g.start, f.start); for (c = i = Math.min(g.start + g.count, f.start + f.count); y < c; y += 3) { i = o.getX(y); var x = o.getX(y + 1),
                                                b = o.getX(y + 2);
                                            (i = V(this, v, e, Qo, a, l, h, u, p, i, x, b)) && (i.faceIndex = Math.floor(y / 3), i.face.materialIndex = g.materialIndex, t.push(i)) } } } else
                                    for (m = y = Math.max(0, f.start), s = i = Math.min(o.count, f.start + f.count); m < s; m += 3) i = o.getX(m), x = o.getX(m + 1), b = o.getX(m + 2), (i = V(this, r, e, Qo, a, l, h, u, p, i, x, b)) && (i.faceIndex = Math.floor(m / 3), t.push(i));
                            else if (void 0 !== a)
                                if (Array.isArray(r))
                                    for (m = 0, s = d.length; m < s; m++)
                                        for (v = r[(g = d[m]).materialIndex], y = Math.max(g.start, f.start), c = i = Math.min(g.start + g.count, f.start + f.count); y < c; y += 3)(i = V(this, v, e, Qo, a, l, h, u, p, i = y, x = y + 1, b = y + 2)) && (i.faceIndex = Math.floor(y / 3), i.face.materialIndex = g.materialIndex, t.push(i));
                                else
                                    for (m = y = Math.max(0, f.start), s = i = Math.min(a.count, f.start + f.count); m < s; m += 3)(i = V(this, r, e, Qo, a, l, h, u, p, i = m, x = m + 1, b = m + 2)) && (i.faceIndex = Math.floor(m / 3), t.push(i)) } else if (i.isGeometry)
                        for (a = Array.isArray(r), l = i.vertices, h = i.faces, 0 < (i = i.faceVertexUvs[0]).length && (o = i), f = 0, m = h.length; f < m; f++) s = h[f], void 0 !== (i = a ? r[s.materialIndex] : r) && (u = l[s.a], p = l[s.b], d = l[s.c], i = k(this, i, e, Qo, u, p, d, us)) && (o && o[f] && (g = o[f], cs.copy(g[0]), ls.copy(g[1]), hs.copy(g[2]), i.uv = _.getUV(us, u, p, d, cs, ls, hs, new n)), i.face = s, i.faceIndex = f, t.push(i)) }, clone: function() { return new this.constructor(this.geometry, this.material).copy(this) } }); var ds = 0,
                fs = new h,
                ms = new d,
                gs = new l;
            j.prototype = Object.assign(Object.create(t.prototype), { constructor: j, isGeometry: !0, applyMatrix4: function(e) { for (var t = (new i).getNormalMatrix(e), n = 0, r = this.vertices.length; n < r; n++) this.vertices[n].applyMatrix4(e); for (n = 0, r = this.faces.length; n < r; n++) {
                        (e = this.faces[n]).normal.applyMatrix3(t).normalize(); for (var a = 0, o = e.vertexNormals.length; a < o; a++) e.vertexNormals[a].applyMatrix3(t).normalize() } return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.normalsNeedUpdate = this.verticesNeedUpdate = !0, this }, rotateX: function(e) { return fs.makeRotationX(e), this.applyMatrix4(fs), this }, rotateY: function(e) { return fs.makeRotationY(e), this.applyMatrix4(fs), this }, rotateZ: function(e) { return fs.makeRotationZ(e), this.applyMatrix4(fs), this }, translate: function(e, t, n) { return fs.makeTranslation(e, t, n), this.applyMatrix4(fs), this }, scale: function(e, t, n) { return fs.makeScale(e, t, n), this.applyMatrix4(fs), this }, lookAt: function(e) { return ms.lookAt(e), ms.updateMatrix(), this.applyMatrix4(ms.matrix), this }, fromBufferGeometry: function(e) {
                    function t(e, t, r, a) { var o = void 0 === c ? [] : [i.colors[e].clone(), i.colors[t].clone(), i.colors[r].clone()];
                        a = new T(e, t, r, void 0 === s ? [] : [(new l).fromArray(s, 3 * e), (new l).fromArray(s, 3 * t), (new l).fromArray(s, 3 * r)], o, a), i.faces.push(a), void 0 !== h && i.faceVertexUvs[0].push([(new n).fromArray(h, 2 * e), (new n).fromArray(h, 2 * t), (new n).fromArray(h, 2 * r)]), void 0 !== u && i.faceVertexUvs[1].push([(new n).fromArray(u, 2 * e), (new n).fromArray(u, 2 * t), (new n).fromArray(u, 2 * r)]) } var i = this,
                        r = null !== e.index ? e.index.array : void 0,
                        a = e.attributes; if (void 0 === a.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this; var o = a.position.array,
                        s = void 0 !== a.normal ? a.normal.array : void 0,
                        c = void 0 !== a.color ? a.color.array : void 0,
                        h = void 0 !== a.uv ? a.uv.array : void 0,
                        u = void 0 !== a.uv2 ? a.uv2.array : void 0; for (void 0 !== u && (this.faceVertexUvs[1] = []), a = 0; a < o.length; a += 3) i.vertices.push((new l).fromArray(o, a)), void 0 !== c && i.colors.push((new b).fromArray(c, a)); var p = e.groups; if (0 < p.length)
                        for (a = 0; a < p.length; a++) { var d = (o = p[a]).start,
                                f = d; for (d += o.count; f < d; f += 3) void 0 !== r ? t(r[f], r[f + 1], r[f + 2], o.materialIndex) : t(f, f + 1, f + 2, o.materialIndex) } else if (void 0 !== r)
                            for (a = 0; a < r.length; a += 3) t(r[a], r[a + 1], r[a + 2]);
                        else
                            for (a = 0; a < o.length / 3; a += 3) t(a, a + 1, a + 2); return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this }, center: function() { return this.computeBoundingBox(), this.boundingBox.getCenter(gs).negate(), this.translate(gs.x, gs.y, gs.z), this }, normalize: function() { this.computeBoundingSphere(); var e = this.boundingSphere.center,
                        t = this.boundingSphere.radius;
                    t = 0 === t ? 1 : 1 / t; var n = new h; return n.set(t, 0, 0, -t * e.x, 0, t, 0, -t * e.y, 0, 0, t, -t * e.z, 0, 0, 0, 1), this.applyMatrix4(n), this }, computeFaceNormals: function() { for (var e = new l, t = new l, n = 0, i = this.faces.length; n < i; n++) { var r = this.faces[n],
                            a = this.vertices[r.a],
                            o = this.vertices[r.b];
                        e.subVectors(this.vertices[r.c], o), t.subVectors(a, o), e.cross(t), e.normalize(), r.normal.copy(e) } }, computeVertexNormals: function(e) { var t;
                    void 0 === e && (e = !0); var n = Array(this.vertices.length),
                        i = 0; for (t = this.vertices.length; i < t; i++) n[i] = new l; if (e) { var r = new l,
                            a = new l; for (e = 0, i = this.faces.length; e < i; e++) { t = this.faces[e]; var o = this.vertices[t.a],
                                s = this.vertices[t.b],
                                c = this.vertices[t.c];
                            r.subVectors(c, s), a.subVectors(o, s), r.cross(a), n[t.a].add(r), n[t.b].add(r), n[t.c].add(r) } } else
                        for (this.computeFaceNormals(), e = 0, i = this.faces.length; e < i; e++) n[(t = this.faces[e]).a].add(t.normal), n[t.b].add(t.normal), n[t.c].add(t.normal); for (i = 0, t = this.vertices.length; i < t; i++) n[i].normalize(); for (e = 0, i = this.faces.length; e < i; e++) 3 === (o = (t = this.faces[e]).vertexNormals).length ? (o[0].copy(n[t.a]), o[1].copy(n[t.b]), o[2].copy(n[t.c])) : (o[0] = n[t.a].clone(), o[1] = n[t.b].clone(), o[2] = n[t.c].clone());
                    0 < this.faces.length && (this.normalsNeedUpdate = !0) }, computeFlatVertexNormals: function() { var e;
                    this.computeFaceNormals(); var t = 0; for (e = this.faces.length; t < e; t++) { var n = this.faces[t],
                            i = n.vertexNormals;
                        3 === i.length ? (i[0].copy(n.normal), i[1].copy(n.normal), i[2].copy(n.normal)) : (i[0] = n.normal.clone(), i[1] = n.normal.clone(), i[2] = n.normal.clone()) } 0 < this.faces.length && (this.normalsNeedUpdate = !0) }, computeMorphNormals: function() { var e, t, n = 0; for (t = this.faces.length; n < t; n++) { var i = this.faces[n];
                        i.__originalFaceNormal ? i.__originalFaceNormal.copy(i.normal) : i.__originalFaceNormal = i.normal.clone(), i.__originalVertexNormals || (i.__originalVertexNormals = []); var r = 0; for (e = i.vertexNormals.length; r < e; r++) i.__originalVertexNormals[r] ? i.__originalVertexNormals[r].copy(i.vertexNormals[r]) : i.__originalVertexNormals[r] = i.vertexNormals[r].clone() } var a = new j; for (a.faces = this.faces, r = 0, e = this.morphTargets.length; r < e; r++) { if (!this.morphNormals[r]) { this.morphNormals[r] = {}, this.morphNormals[r].faceNormals = [], this.morphNormals[r].vertexNormals = [], i = this.morphNormals[r].faceNormals; var o = this.morphNormals[r].vertexNormals; for (n = 0, t = this.faces.length; n < t; n++) { var s = new l,
                                    c = { a: new l, b: new l, c: new l };
                                i.push(s), o.push(c) } } for (o = this.morphNormals[r], a.vertices = this.morphTargets[r].vertices, a.computeFaceNormals(), a.computeVertexNormals(), n = 0, t = this.faces.length; n < t; n++) i = this.faces[n], s = o.faceNormals[n], c = o.vertexNormals[n], s.copy(i.normal), c.a.copy(i.vertexNormals[0]), c.b.copy(i.vertexNormals[1]), c.c.copy(i.vertexNormals[2]) } for (n = 0, t = this.faces.length; n < t; n++)(i = this.faces[n]).normal = i.__originalFaceNormal, i.vertexNormals = i.__originalVertexNormals }, computeBoundingBox: function() { null === this.boundingBox && (this.boundingBox = new m), this.boundingBox.setFromPoints(this.vertices) }, computeBoundingSphere: function() { null === this.boundingSphere && (this.boundingSphere = new v), this.boundingSphere.setFromPoints(this.vertices) }, merge: function(e, t, n) { if (e && e.isGeometry) { var r, a = this.vertices.length,
                            o = this.vertices,
                            s = e.vertices,
                            c = this.faces,
                            l = e.faces,
                            h = this.colors,
                            u = e.colors;
                        void 0 === n && (n = 0), void 0 !== t && (r = (new i).getNormalMatrix(t)); for (var p = 0, d = s.length; p < d; p++) { var f = s[p].clone();
                            void 0 !== t && f.applyMatrix4(t), o.push(f) } for (p = 0, d = u.length; p < d; p++) h.push(u[p].clone()); for (p = 0, d = l.length; p < d; p++) { var m = (s = l[p]).vertexNormals; for (u = s.vertexColors, (h = new T(s.a + a, s.b + a, s.c + a)).normal.copy(s.normal), void 0 !== r && h.normal.applyMatrix3(r).normalize(), t = 0, o = m.length; t < o; t++) f = m[t].clone(), void 0 !== r && f.applyMatrix3(r).normalize(), h.vertexNormals.push(f); for (h.color.copy(s.color), t = 0, o = u.length; t < o; t++) f = u[t], h.vertexColors.push(f.clone());
                            h.materialIndex = s.materialIndex + n, c.push(h) } for (p = 0, d = e.faceVertexUvs.length; p < d; p++)
                            for (n = e.faceVertexUvs[p], void 0 === this.faceVertexUvs[p] && (this.faceVertexUvs[p] = []), t = 0, o = n.length; t < o; t++) { for (a = [], c = 0, l = (r = n[t]).length; c < l; c++) a.push(r[c].clone());
                                this.faceVertexUvs[p].push(a) } } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e) }, mergeMesh: function(e) { e && e.isMesh ? (e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e) }, mergeVertices: function() { var e, t = {},
                        n = [],
                        i = [],
                        r = Math.pow(10, 4),
                        a = 0; for (e = this.vertices.length; a < e; a++) { var o = this.vertices[a];
                        void 0 === t[o = Math.round(o.x * r) + "_" + Math.round(o.y * r) + "_" + Math.round(o.z * r)] ? (t[o] = a, n.push(this.vertices[a]), i[a] = n.length - 1) : i[a] = i[t[o]] } for (t = [], a = 0, e = this.faces.length; a < e; a++)
                        for ((r = this.faces[a]).a = i[r.a], r.b = i[r.b], r.c = i[r.c], r = [r.a, r.b, r.c], o = 0; 3 > o; o++)
                            if (r[o] === r[(o + 1) % 3]) { t.push(a); break } for (a = t.length - 1; 0 <= a; a--)
                        for (r = t[a], this.faces.splice(r, 1), i = 0, e = this.faceVertexUvs.length; i < e; i++) this.faceVertexUvs[i].splice(r, 1); return a = this.vertices.length - n.length, this.vertices = n, a }, setFromPoints: function(e) { this.vertices = []; for (var t = 0, n = e.length; t < n; t++) { var i = e[t];
                        this.vertices.push(new l(i.x, i.y, i.z || 0)) } return this }, sortFacesByMaterialIndex: function() { for (var e = this.faces, t = e.length, n = 0; n < t; n++) e[n]._id = n;
                    e.sort(function(e, t) { return e.materialIndex - t.materialIndex }); var i, r, a = this.faceVertexUvs[0],
                        o = this.faceVertexUvs[1]; for (a && a.length === t && (i = []), o && o.length === t && (r = []), n = 0; n < t; n++) { var s = e[n]._id;
                        i && i.push(a[s]), r && r.push(o[s]) } i && (this.faceVertexUvs[0] = i), r && (this.faceVertexUvs[1] = r) }, toJSON: function() {
                    function e(e, t, n) { return n ? e | 1 << t : e & ~(1 << t) }

                    function t(e) { var t = e.x.toString() + e.y.toString() + e.z.toString(); return void 0 !== l[t] ? l[t] : (l[t] = c.length / 3, c.push(e.x, e.y, e.z), l[t]) }

                    function n(e) { var t = e.r.toString() + e.g.toString() + e.b.toString(); return void 0 !== u[t] ? u[t] : (u[t] = h.length, h.push(e.getHex()), u[t]) }

                    function i(e) { var t = e.x.toString() + e.y.toString(); return void 0 !== d[t] ? d[t] : (d[t] = p.length / 2, p.push(e.x, e.y), d[t]) } var r = { metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } }; if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), void 0 !== this.parameters) { var a, o = this.parameters; for (a in o) void 0 !== o[a] && (r[a] = o[a]); return r } for (o = [], a = 0; a < this.vertices.length; a++) { var s = this.vertices[a];
                        o.push(s.x, s.y, s.z) } s = []; var c = [],
                        l = {},
                        h = [],
                        u = {},
                        p = [],
                        d = {}; for (a = 0; a < this.faces.length; a++) { var f = this.faces[a],
                            m = void 0 !== this.faceVertexUvs[0][a],
                            g = 0 < f.normal.length(),
                            v = 0 < f.vertexNormals.length,
                            y = 1 !== f.color.r || 1 !== f.color.g || 1 !== f.color.b,
                            x = 0 < f.vertexColors.length,
                            _ = 0;
                        _ = e(_, 0, 0), _ = e(_, 1, !0), _ = e(_, 2, !1), _ = e(_, 3, m), _ = e(_, 4, g), _ = e(_, 5, v), _ = e(_, 6, y), _ = e(_, 7, x), s.push(_), s.push(f.a, f.b, f.c), s.push(f.materialIndex), m && (m = this.faceVertexUvs[0][a], s.push(i(m[0]), i(m[1]), i(m[2]))), g && s.push(t(f.normal)), v && (g = f.vertexNormals, s.push(t(g[0]), t(g[1]), t(g[2]))), y && s.push(n(f.color)), x && (f = f.vertexColors, s.push(n(f[0]), n(f[1]), n(f[2]))) } return r.data = {}, r.data.vertices = o, r.data.normals = c, 0 < h.length && (r.data.colors = h), 0 < p.length && (r.data.uvs = [p]), r.data.faces = s, r }, clone: function() { return (new j).copy(this) }, copy: function(e) { var t, n, i;
                    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                        []
                    ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.name = e.name; var r = e.vertices,
                        a = 0; for (t = r.length; a < t; a++) this.vertices.push(r[a].clone()); for (a = 0, t = (r = e.colors).length; a < t; a++) this.colors.push(r[a].clone()); for (a = 0, t = (r = e.faces).length; a < t; a++) this.faces.push(r[a].clone()); for (a = 0, t = e.faceVertexUvs.length; a < t; a++) { var o = e.faceVertexUvs[a]; for (void 0 === this.faceVertexUvs[a] && (this.faceVertexUvs[a] = []), r = 0, n = o.length; r < n; r++) { var s = o[r],
                                c = [],
                                l = 0; for (i = s.length; l < i; l++) c.push(s[l].clone());
                            this.faceVertexUvs[a].push(c) } } for (a = 0, t = (l = e.morphTargets).length; a < t; a++) { if ((i = {}).name = l[a].name, void 0 !== l[a].vertices)
                            for (i.vertices = [], r = 0, n = l[a].vertices.length; r < n; r++) i.vertices.push(l[a].vertices[r].clone()); if (void 0 !== l[a].normals)
                            for (i.normals = [], r = 0, n = l[a].normals.length; r < n; r++) i.normals.push(l[a].normals[r].clone());
                        this.morphTargets.push(i) } for (a = 0, t = (l = e.morphNormals).length; a < t; a++) { if (i = {}, void 0 !== l[a].vertexNormals)
                            for (i.vertexNormals = [], r = 0, n = l[a].vertexNormals.length; r < n; r++) o = l[a].vertexNormals[r], (s = {}).a = o.a.clone(), s.b = o.b.clone(), s.c = o.c.clone(), i.vertexNormals.push(s); if (void 0 !== l[a].faceNormals)
                            for (i.faceNormals = [], r = 0, n = l[a].faceNormals.length; r < n; r++) i.faceNormals.push(l[a].faceNormals[r].clone());
                        this.morphNormals.push(i) } for (a = 0, t = (r = e.skinWeights).length; a < t; a++) this.skinWeights.push(r[a].clone()); for (a = 0, t = (r = e.skinIndices).length; a < t; a++) this.skinIndices.push(r[a].clone()); for (a = 0, t = (r = e.lineDistances).length; a < t; a++) this.lineDistances.push(r[a]); return null !== (a = e.boundingBox) && (this.boundingBox = a.clone()), null !== (a = e.boundingSphere) && (this.boundingSphere = a.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this }, dispose: function() { this.dispatchEvent({ type: "dispose" }) } }); var vs = function(e) {
                    function t(t, n, i, r, a, o) { e.call(this), this.type = "BoxGeometry", this.parameters = { width: t, height: n, depth: i, widthSegments: r, heightSegments: a, depthSegments: o }, this.fromBufferGeometry(new ys(t, n, i, r, a, o)), this.mergeVertices() } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t }(j),
                ys = function(e) {
                    function t(t, n, i, r, a, o) {
                        function s(e, t, n, i, r, a, o, s, g, v, y) { var x = a / g,
                                _ = o / v,
                                b = a / 2,
                                w = o / 2,
                                M = s / 2;
                            o = g + 1; for (var S = v + 1, T = a = 0, E = new l, A = 0; A < S; A++)
                                for (var L = A * _ - w, R = 0; R < o; R++) E[e] = (R * x - b) * i, E[t] = L * r, E[n] = M, u.push(E.x, E.y, E.z), E[e] = 0, E[t] = 0, E[n] = 0 < s ? 1 : -1, p.push(E.x, E.y, E.z), d.push(R / g), d.push(1 - A / v), a += 1; for (e = 0; e < v; e++)
                                for (t = 0; t < g; t++) n = f + t + o * (e + 1), i = f + (t + 1) + o * (e + 1), r = f + (t + 1) + o * e, h.push(f + t + o * e, n, r), h.push(n, i, r), T += 6;
                            c.addGroup(m, T, y), m += T, f += a } e.call(this), this.type = "BoxBufferGeometry", this.parameters = { width: t, height: n, depth: i, widthSegments: r, heightSegments: a, depthSegments: o }; var c = this;
                        t = t || 1, n = n || 1, i = i || 1, r = Math.floor(r) || 1, a = Math.floor(a) || 1, o = Math.floor(o) || 1; var h = [],
                            u = [],
                            p = [],
                            d = [],
                            f = 0,
                            m = 0;
                        s("z", "y", "x", -1, -1, i, n, t, o, a, 0), s("z", "y", "x", 1, -1, i, n, -t, o, a, 1), s("x", "z", "y", 1, 1, t, i, n, r, o, 2), s("x", "z", "y", 1, -1, t, i, -n, r, o, 3), s("x", "y", "z", 1, -1, t, n, i, r, a, 4), s("x", "y", "z", -1, -1, t, n, -i, r, a, 5), this.setIndex(h), this.setAttribute("position", new B(u, 3)), this.setAttribute("normal", new B(p, 3)), this.setAttribute("uv", new B(d, 2)) } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t }(G),
                xs = { clone: W, merge: q };
            X.prototype = Object.create(E.prototype), X.prototype.constructor = X, X.prototype.isShaderMaterial = !0, X.prototype.copy = function(e) { return E.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = W(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = Object.assign({}, e.extensions), this }, X.prototype.toJSON = function(e) { var t = E.prototype.toJSON.call(this, e); for (var n in t.uniforms = {}, this.uniforms) { var i = this.uniforms[n].value;
                    t.uniforms[n] = i && i.isTexture ? { type: "t", value: i.toJSON(e).uuid } : i && i.isColor ? { type: "c", value: i.getHex() } : i && i.isVector2 ? { type: "v2", value: i.toArray() } : i && i.isVector3 ? { type: "v3", value: i.toArray() } : i && i.isVector4 ? { type: "v4", value: i.toArray() } : i && i.isMatrix3 ? { type: "m3", value: i.toArray() } : i && i.isMatrix4 ? { type: "m4", value: i.toArray() } : { value: i } } for (var r in 0 < Object.keys(this.defines).length && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, e = {}, this.extensions) !0 === this.extensions[r] && (e[r] = !0); return 0 < Object.keys(e).length && (t.extensions = e), t }, Y.prototype = Object.assign(Object.create(d.prototype), { constructor: Y, isCamera: !0, copy: function(e, t) { return d.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this }, getWorldDirection: function(e) { void 0 === e && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), e = new l), this.updateMatrixWorld(!0); var t = this.matrixWorld.elements; return e.set(-t[8], -t[9], -t[10]).normalize() }, updateMatrixWorld: function(e) { d.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.getInverse(this.matrixWorld) }, updateWorldMatrix: function(e, t) { d.prototype.updateWorldMatrix.call(this, e, t), this.matrixWorldInverse.getInverse(this.matrixWorld) }, clone: function() { return (new this.constructor).copy(this) } }), Z.prototype = Object.assign(Object.create(Y.prototype), { constructor: Z, isPerspectiveCamera: !0, copy: function(e, t) { return Y.prototype.copy.call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this }, setFocalLength: function(e) { e = .5 * this.getFilmHeight() / e, this.fov = 2 * Ra.RAD2DEG * Math.atan(e), this.updateProjectionMatrix() }, getFocalLength: function() { var e = Math.tan(.5 * Ra.DEG2RAD * this.fov); return .5 * this.getFilmHeight() / e }, getEffectiveFOV: function() { return 2 * Ra.RAD2DEG * Math.atan(Math.tan(.5 * Ra.DEG2RAD * this.fov) / this.zoom) }, getFilmWidth: function() { return this.filmGauge * Math.min(this.aspect, 1) }, getFilmHeight: function() { return this.filmGauge / Math.max(this.aspect, 1) }, setViewOffset: function(e, t, n, i, r, a) { this.aspect = e / t, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix() }, clearViewOffset: function() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }, updateProjectionMatrix: function() { var e = this.near,
                        t = e * Math.tan(.5 * Ra.DEG2RAD * this.fov) / this.zoom,
                        n = 2 * t,
                        i = this.aspect * n,
                        r = -.5 * i,
                        a = this.view; if (null !== this.view && this.view.enabled) { var o = a.fullWidth,
                            s = a.fullHeight;
                        r += a.offsetX * i / o, t -= a.offsetY * n / s, i *= a.width / o, n *= a.height / s } 0 !== (a = this.filmOffset) && (r += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix) }, toJSON: function(e) { return (e = d.prototype.toJSON.call(this, e)).object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e } }), J.prototype = Object.create(d.prototype), J.prototype.constructor = J, Q.prototype = Object.create(o.prototype), Q.prototype.constructor = Q, Q.prototype.isWebGLCubeRenderTarget = !0, Q.prototype.fromEquirectangularTexture = function(e, t) { this.texture.type = t.type, this.texture.format = t.format, this.texture.encoding = t.encoding; var n = new f,
                    i = new X({ type: "CubemapFromEquirect", uniforms: W({ tEquirect: { value: null } }), vertexShader: "varying vec3 vWorldDirection;\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", fragmentShader: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}", side: 1, blending: 0 }); return i.uniforms.tEquirect.value = t, t = new H(new ys(5, 5, 5), i), n.add(t), new J(1, 10, this).update(e, n), t.geometry.dispose(), t.material.dispose(), this }, K.prototype = Object.create(r.prototype), K.prototype.constructor = K, K.prototype.isDataTexture = !0; var _s = new v,
                bs = new l;
            Object.assign($.prototype, { set: function(e, t, n, i, r, a) { var o = this.planes; return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(i), o[4].copy(r), o[5].copy(a), this }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { for (var t = this.planes, n = 0; 6 > n; n++) t[n].copy(e.planes[n]); return this }, setFromProjectionMatrix: function(e) { var t = this.planes,
                        n = e.elements;
                    e = n[0]; var i = n[1],
                        r = n[2],
                        a = n[3],
                        o = n[4],
                        s = n[5],
                        c = n[6],
                        l = n[7],
                        h = n[8],
                        u = n[9],
                        p = n[10],
                        d = n[11],
                        f = n[12],
                        m = n[13],
                        g = n[14]; return n = n[15], t[0].setComponents(a - e, l - o, d - h, n - f).normalize(), t[1].setComponents(a + e, l + o, d + h, n + f).normalize(), t[2].setComponents(a + i, l + s, d + u, n + m).normalize(), t[3].setComponents(a - i, l - s, d - u, n - m).normalize(), t[4].setComponents(a - r, l - c, d - p, n - g).normalize(), t[5].setComponents(a + r, l + c, d + p, n + g).normalize(), this }, intersectsObject: function(e) { var t = e.geometry; return null === t.boundingSphere && t.computeBoundingSphere(), _s.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(_s) }, intersectsSprite: function(e) { return _s.center.set(0, 0, 0), _s.radius = .7071067811865476, _s.applyMatrix4(e.matrixWorld), this.intersectsSphere(_s) }, intersectsSphere: function(e) { var t = this.planes,
                        n = e.center;
                    e = -e.radius; for (var i = 0; 6 > i; i++)
                        if (t[i].distanceToPoint(n) < e) return !1; return !0 }, intersectsBox: function(e) { for (var t = this.planes, n = 0; 6 > n; n++) { var i = t[n]; if (bs.x = 0 < i.normal.x ? e.max.x : e.min.x, bs.y = 0 < i.normal.y ? e.max.y : e.min.y, bs.z = 0 < i.normal.z ? e.max.z : e.min.z, 0 > i.distanceToPoint(bs)) return !1 } return !0 }, containsPoint: function(e) { for (var t = this.planes, n = 0; 6 > n; n++)
                        if (0 > t[n].distanceToPoint(e)) return !1; return !0 } }); var ws = { common: { diffuse: { value: new b(15658734) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new i }, uv2Transform: { value: new i }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: .98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new n(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new b(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } } }, points: { diffuse: { value: new b(15658734) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new i } }, sprite: { diffuse: { value: new b(15658734) }, opacity: { value: 1 }, center: { value: new n(.5, .5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new i } } };
            ne.prototype = Object.create(j.prototype), ne.prototype.constructor = ne, ie.prototype = Object.create(G.prototype), ie.prototype.constructor = ie; var Ms = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif", common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);    } else if (face == 1.0) {\n      uv = vec2(-direction.x, -direction.z) / abs(direction.y);    } else if (face == 2.0) {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);    } else if (face == 3.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);    } else if (face == 4.0) {\n      uv = vec2(-direction.x, direction.z) / abs(direction.y);    } else {\n      uv = vec2(direction.x, direction.y) / abs(direction.z);    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif", map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif", normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif", clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}" },
                Ss = { basic: { uniforms: q([ws.common, ws.specularmap, ws.envmap, ws.aomap, ws.lightmap, ws.fog]), vertexShader: Ms.meshbasic_vert, fragmentShader: Ms.meshbasic_frag }, lambert: { uniforms: q([ws.common, ws.specularmap, ws.envmap, ws.aomap, ws.lightmap, ws.emissivemap, ws.fog, ws.lights, { emissive: { value: new b(0) } }]), vertexShader: Ms.meshlambert_vert, fragmentShader: Ms.meshlambert_frag }, phong: { uniforms: q([ws.common, ws.specularmap, ws.envmap, ws.aomap, ws.lightmap, ws.emissivemap, ws.bumpmap, ws.normalmap, ws.displacementmap, ws.fog, ws.lights, { emissive: { value: new b(0) }, specular: { value: new b(1118481) }, shininess: { value: 30 } }]), vertexShader: Ms.meshphong_vert, fragmentShader: Ms.meshphong_frag }, standard: { uniforms: q([ws.common, ws.envmap, ws.aomap, ws.lightmap, ws.emissivemap, ws.bumpmap, ws.normalmap, ws.displacementmap, ws.roughnessmap, ws.metalnessmap, ws.fog, ws.lights, { emissive: { value: new b(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: Ms.meshphysical_vert, fragmentShader: Ms.meshphysical_frag }, toon: { uniforms: q([ws.common, ws.specularmap, ws.aomap, ws.lightmap, ws.emissivemap, ws.bumpmap, ws.normalmap, ws.displacementmap, ws.gradientmap, ws.fog, ws.lights, { emissive: { value: new b(0) }, specular: { value: new b(1118481) }, shininess: { value: 30 } }]), vertexShader: Ms.meshtoon_vert, fragmentShader: Ms.meshtoon_frag }, matcap: { uniforms: q([ws.common, ws.bumpmap, ws.normalmap, ws.displacementmap, ws.fog, { matcap: { value: null } }]), vertexShader: Ms.meshmatcap_vert, fragmentShader: Ms.meshmatcap_frag }, points: { uniforms: q([ws.points, ws.fog]), vertexShader: Ms.points_vert, fragmentShader: Ms.points_frag }, dashed: { uniforms: q([ws.common, ws.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: Ms.linedashed_vert, fragmentShader: Ms.linedashed_frag }, depth: { uniforms: q([ws.common, ws.displacementmap]), vertexShader: Ms.depth_vert, fragmentShader: Ms.depth_frag }, normal: { uniforms: q([ws.common, ws.bumpmap, ws.normalmap, ws.displacementmap, { opacity: { value: 1 } }]), vertexShader: Ms.normal_vert, fragmentShader: Ms.normal_frag }, sprite: { uniforms: q([ws.sprite, ws.fog]), vertexShader: Ms.sprite_vert, fragmentShader: Ms.sprite_frag }, background: { uniforms: { uvTransform: { value: new i }, t2D: { value: null } }, vertexShader: Ms.background_vert, fragmentShader: Ms.background_frag }, cube: { uniforms: q([ws.envmap, { opacity: { value: 1 } }]), vertexShader: Ms.cube_vert, fragmentShader: Ms.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: Ms.equirect_vert, fragmentShader: Ms.equirect_frag }, distanceRGBA: { uniforms: q([ws.common, ws.displacementmap, { referencePosition: { value: new l }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: Ms.distanceRGBA_vert, fragmentShader: Ms.distanceRGBA_frag }, shadow: { uniforms: q([ws.lights, ws.fog, { color: { value: new b(0) }, opacity: { value: 1 } }]), vertexShader: Ms.shadow_vert, fragmentShader: Ms.shadow_frag } };
            Ss.physical = { uniforms: q([Ss.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new n(1, 1) }, clearcoatNormalMap: { value: null }, sheen: { value: new b(0) }, transparency: { value: 0 } }]), vertexShader: Ms.meshphysical_vert, fragmentShader: Ms.meshphysical_frag }, me.prototype = Object.create(r.prototype), me.prototype.constructor = me, me.prototype.isCubeTexture = !0, Object.defineProperty(me.prototype, "images", { get: function() { return this.image }, set: function(e) { this.image = e } }), ge.prototype = Object.create(r.prototype), ge.prototype.constructor = ge, ge.prototype.isDataTexture2DArray = !0, ve.prototype = Object.create(r.prototype), ve.prototype.constructor = ve, ve.prototype.isDataTexture3D = !0; var Ts = new r,
                Es = new ge,
                As = new ve,
                Ls = new me,
                Rs = [],
                Ps = [],
                Cs = new Float32Array(16),
                Os = new Float32Array(9),
                Ds = new Float32Array(4);
            Ke.prototype.updateCache = function(e) { var t = this.cache;
                e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), _e(t, e) }, $e.prototype.setValue = function(e, t, n) { for (var i = this.seq, r = 0, a = i.length; r !== a; ++r) { var o = i[r];
                    o.setValue(e, t[o.id], n) } }; var Is = /([\w\d_]+)(\])?(\[|\.)?/g;
            et.prototype.setValue = function(e, t, n, i) { void 0 !== (t = this.map[t]) && t.setValue(e, n, i) }, et.prototype.setOptional = function(e, t, n) { void 0 !== (t = t[n]) && this.setValue(e, n, t) }, et.upload = function(e, t, n, i) { for (var r = 0, a = t.length; r !== a; ++r) { var o = t[r],
                        s = n[o.id];!1 !== s.needsUpdate && o.setValue(e, s.value, i) } }, et.seqWithValue = function(e, t) { for (var n = [], i = 0, r = e.length; i !== r; ++i) { var a = e[i];
                    a.id in t && n.push(a) } return n }; var Ns = 0,
                Bs = /^[ \t]*#include +<([\w\d./]+)>/gm,
                zs = /#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
                Us = /#pragma unroll_loop_start[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g,
                Fs = 0;
            Et.prototype = Object.create(E.prototype), Et.prototype.constructor = Et, Et.prototype.isMeshDepthMaterial = !0, Et.prototype.copy = function(e) { return E.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this }, At.prototype = Object.create(E.prototype), At.prototype.constructor = At, At.prototype.isMeshDistanceMaterial = !0, At.prototype.copy = function(e) { return E.prototype.copy.call(this, e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this }, Ot.prototype = Object.assign(Object.create(Z.prototype), { constructor: Ot, isArrayCamera: !0 }), Dt.prototype = Object.assign(Object.create(d.prototype), { constructor: Dt, isGroup: !0 }), Object.assign(It.prototype, { constructor: It, getTargetRaySpace: function() { return null === this._targetRay && (this._targetRay = new Dt, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1), this._targetRay }, getGripSpace: function() { return null === this._grip && (this._grip = new Dt, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1), this._grip }, dispatchEvent: function(e) { return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), this }, disconnect: function(e) { return this.dispatchEvent({ type: "disconnected", data: e }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), this }, update: function(e, t, n) { var i = null,
                        r = null,
                        a = this._targetRay,
                        o = this._grip; return e && (null !== a && (null !== (i = t.getPose(e.targetRaySpace, n)) && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale))), null !== o && e.gripSpace && (null !== (r = t.getPose(e.gripSpace, n)) && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale)))), null !== a && (a.visible = null !== i), null !== o && (o.visible = null !== r), this } }), Object.assign(Nt.prototype, t.prototype), Object.assign(Ut.prototype, { isFogExp2: !0, clone: function() { return new Ut(this.color, this.density) }, toJSON: function() { return { type: "FogExp2", color: this.color.getHex(), density: this.density } } }), Object.assign(Ft.prototype, { isFog: !0, clone: function() { return new Ft(this.color, this.near, this.far) }, toJSON: function() { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } } }), Object.defineProperty(Gt.prototype, "needsUpdate", { set: function(e) {!0 === e && this.version++ } }), Object.assign(Gt.prototype, { isInterleavedBuffer: !0, onUploadCallback: function() {}, setUsage: function(e) { return this.usage = e, this }, copy: function(e) { return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this }, copyAt: function(e, t, n) { e *= this.stride, n *= t.stride; for (var i = 0, r = this.stride; i < r; i++) this.array[e + i] = t.array[n + i]; return this }, set: function(e, t) { return void 0 === t && (t = 0), this.array.set(e, t), this }, clone: function() { return (new this.constructor).copy(this) }, onUpload: function(e) { return this.onUploadCallback = e, this } }); var Gs = new l;
            Object.defineProperties(Ht.prototype, { count: { get: function() { return this.data.count } }, array: { get: function() { return this.data.array } } }), Object.assign(Ht.prototype, { isInterleavedBufferAttribute: !0, applyMatrix4: function(e) { for (var t = 0, n = this.data.count; t < n; t++) Gs.x = this.getX(t), Gs.y = this.getY(t), Gs.z = this.getZ(t), Gs.applyMatrix4(e), this.setXYZ(t, Gs.x, Gs.y, Gs.z); return this }, setX: function(e, t) { return this.data.array[e * this.data.stride + this.offset] = t, this }, setY: function(e, t) { return this.data.array[e * this.data.stride + this.offset + 1] = t, this }, setZ: function(e, t) { return this.data.array[e * this.data.stride + this.offset + 2] = t, this }, setW: function(e, t) { return this.data.array[e * this.data.stride + this.offset + 3] = t, this }, getX: function(e) { return this.data.array[e * this.data.stride + this.offset] }, getY: function(e) { return this.data.array[e * this.data.stride + this.offset + 1] }, getZ: function(e) { return this.data.array[e * this.data.stride + this.offset + 2] }, getW: function(e) { return this.data.array[e * this.data.stride + this.offset + 3] }, setXY: function(e, t, n) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this }, setXYZ: function(e, t, n, i) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this }, setXYZW: function(e, t, n, i, r) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = r, this }, clone: function() { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."); for (var e = [], t = 0; t < this.count; t++)
                        for (var n = t * this.data.stride + this.offset, i = 0; i < this.itemSize; i++) e.push(this.data.array[n + i]); return new L(new this.array.constructor(e), this.itemSize, this.normalized) }, toJSON: function() { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."); for (var e = [], t = 0; t < this.count; t++)
                        for (var n = t * this.data.stride + this.offset, i = 0; i < this.itemSize; i++) e.push(this.data.array[n + i]); return { itemSize: this.itemSize, type: this.array.constructor.name, array: e, normalized: this.normalized } } }), kt.prototype = Object.create(E.prototype), kt.prototype.constructor = kt, kt.prototype.isSpriteMaterial = !0, kt.prototype.copy = function(e) { return E.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this }; var Hs, ks = new l,
                Vs = new l,
                js = new l,
                Ws = new n,
                qs = new n,
                Xs = new h,
                Ys = new l,
                Zs = new l,
                Js = new l,
                Qs = new n,
                Ks = new n,
                $s = new n;
            Vt.prototype = Object.assign(Object.create(d.prototype), { constructor: Vt, isSprite: !0, raycast: function(e, t) { null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Vs.setFromMatrixScale(this.matrixWorld), Xs.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), js.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Vs.multiplyScalar(-js.z); var i = this.material.rotation; if (0 !== i) var r = Math.cos(i),
                        a = Math.sin(i);
                    i = this.center, jt(Ys.set(-.5, -.5, 0), js, i, Vs, a, r), jt(Zs.set(.5, -.5, 0), js, i, Vs, a, r), jt(Js.set(.5, .5, 0), js, i, Vs, a, r), Qs.set(0, 0), Ks.set(1, 0), $s.set(1, 1); var o = e.ray.intersectTriangle(Ys, Zs, Js, !1, ks);
                    null === o && (jt(Zs.set(-.5, .5, 0), js, i, Vs, a, r), Ks.set(0, 1), null === (o = e.ray.intersectTriangle(Ys, Js, Zs, !1, ks))) || (a = e.ray.origin.distanceTo(ks)) < e.near || a > e.far || t.push({ distance: a, point: ks.clone(), uv: _.getUV(ks, Ys, Zs, Js, Qs, Ks, $s, new n), face: null, object: this }) }, clone: function() { return new this.constructor(this.material).copy(this) }, copy: function(e) { return d.prototype.copy.call(this, e), void 0 !== e.center && this.center.copy(e.center), this } }); var ec, tc, nc, ic, rc, ac = new l,
                oc = new l;
            Wt.prototype = Object.assign(Object.create(d.prototype), { constructor: Wt, isLOD: !0, copy: function(e) { d.prototype.copy.call(this, e, !1); for (var t = e.levels, n = 0, i = t.length; n < i; n++) { var r = t[n];
                        this.addLevel(r.object.clone(), r.distance) } return this.autoUpdate = e.autoUpdate, this }, addLevel: function(e, t) { void 0 === t && (t = 0), t = Math.abs(t); for (var n = this.levels, i = 0; i < n.length && !(t < n[i].distance); i++); return n.splice(i, 0, { distance: t, object: e }), this.add(e), this }, getCurrentLevel: function() { return this._currentLevel }, getObjectForDistance: function(e) { var t = this.levels; if (0 < t.length) { for (var n = 1, i = t.length; n < i && !(e < t[n].distance); n++); return t[n - 1].object } return null }, raycast: function(e, t) { if (0 < this.levels.length) { ac.setFromMatrixPosition(this.matrixWorld); var n = e.ray.origin.distanceTo(ac);
                        this.getObjectForDistance(n).raycast(e, t) } }, update: function(e) { var t = this.levels; if (1 < t.length) { ac.setFromMatrixPosition(e.matrixWorld), oc.setFromMatrixPosition(this.matrixWorld), e = ac.distanceTo(oc) / e.zoom, t[0].object.visible = !0; for (var n = 1, i = t.length; n < i && e >= t[n].distance; n++) t[n - 1].object.visible = !1, t[n].object.visible = !0; for (this._currentLevel = n - 1; n < i; n++) t[n].object.visible = !1 } }, toJSON: function(e) { e = d.prototype.toJSON.call(this, e), !1 === this.autoUpdate && (e.object.autoUpdate = !1), e.object.levels = []; for (var t = this.levels, n = 0, i = t.length; n < i; n++) { var r = t[n];
                        e.object.levels.push({ object: r.object.uuid, distance: r.distance }) } return e } }), qt.prototype = Object.assign(Object.create(H.prototype), { constructor: qt, isSkinnedMesh: !0, bind: function(e, t) { this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t) }, pose: function() { this.skeleton.pose() }, normalizeSkinWeights: function() { for (var e = new a, t = this.geometry.attributes.skinWeight, n = 0, i = t.count; n < i; n++) { e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.w = t.getW(n); var r = 1 / e.manhattanLength();
                        1 / 0 !== r ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w) } }, updateMatrixWorld: function(e) { H.prototype.updateMatrixWorld.call(this, e), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) }, clone: function() { return new this.constructor(this.geometry, this.material).copy(this) }, boneTransform: (ec = new l, tc = new a, nc = new a, ic = new l, rc = new h, function(e, t) { var n = this.skeleton,
                        i = this.geometry; for (tc.fromBufferAttribute(i.attributes.skinIndex, e), nc.fromBufferAttribute(i.attributes.skinWeight, e), ec.fromBufferAttribute(i.attributes.position, e).applyMatrix4(this.bindMatrix), t.set(0, 0, 0), e = 0; 4 > e; e++)
                        if (0 !== (i = nc.getComponent(e))) { var r = tc.getComponent(e);
                            rc.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), t.addScaledVector(ic.copy(ec).applyMatrix4(rc), i) } return t.applyMatrix4(this.bindMatrixInverse) }) }); var sc = new h,
                cc = new h;
            Object.assign(Xt.prototype, { calculateInverses: function() { this.boneInverses = []; for (var e = 0, t = this.bones.length; e < t; e++) { var n = new h;
                        this.bones[e] && n.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(n) } }, pose: function() { var e, t, n = 0; for (t = this.bones.length; n < t; n++)(e = this.bones[n]) && e.matrixWorld.getInverse(this.boneInverses[n]); for (n = 0, t = this.bones.length; n < t; n++)(e = this.bones[n]) && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale)) }, update: function() { for (var e = this.bones, t = this.boneInverses, n = this.boneMatrices, i = this.boneTexture, r = 0, a = e.length; r < a; r++) sc.multiplyMatrices(e[r] ? e[r].matrixWorld : cc, t[r]), sc.toArray(n, 16 * r);
                    void 0 !== i && (i.needsUpdate = !0) }, clone: function() { return new Xt(this.bones, this.boneInverses) }, getBoneByName: function(e) { for (var t = 0, n = this.bones.length; t < n; t++) { var i = this.bones[t]; if (i.name === e) return i } }, dispose: function() { this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = void 0) } }), Yt.prototype = Object.assign(Object.create(d.prototype), { constructor: Yt, isBone: !0 }); var lc = new h,
                hc = new h,
                uc = [],
                pc = new H;
            Zt.prototype = Object.assign(Object.create(H.prototype), { constructor: Zt, isInstancedMesh: !0, getMatrixAt: function(e, t) { t.fromArray(this.instanceMatrix.array, 16 * e) }, raycast: function(e, t) { var n = this.matrixWorld,
                        i = this.count; if (pc.geometry = this.geometry, pc.material = this.material, void 0 !== pc.material)
                        for (var r = 0; r < i; r++) { this.getMatrixAt(r, lc), hc.multiplyMatrices(n, lc), pc.matrixWorld = hc, pc.raycast(e, uc); for (var a = 0, o = uc.length; a < o; a++) { var s = uc[a];
                                s.instanceId = r, s.object = this, t.push(s) } uc.length = 0 } }, setMatrixAt: function(e, t) { t.toArray(this.instanceMatrix.array, 16 * e) }, updateMorphTargets: function() {} }), Jt.prototype = Object.create(E.prototype), Jt.prototype.constructor = Jt, Jt.prototype.isLineBasicMaterial = !0, Jt.prototype.copy = function(e) { return E.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.morphTargets = e.morphTargets, this }; var dc = new l,
                fc = new l,
                mc = new h,
                gc = new y,
                vc = new v;
            Qt.prototype = Object.assign(Object.create(d.prototype), { constructor: Qt, isLine: !0, computeLineDistances: function() { var e = this.geometry; if (e.isBufferGeometry)
                        if (null === e.index) { for (var t = e.attributes.position, n = [0], i = 1, r = t.count; i < r; i++) dc.fromBufferAttribute(t, i - 1), fc.fromBufferAttribute(t, i), n[i] = n[i - 1], n[i] += dc.distanceTo(fc);
                            e.setAttribute("lineDistance", new B(n, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    else if (e.isGeometry)
                        for (t = e.vertices, (n = e.lineDistances)[0] = 0, i = 1, r = t.length; i < r; i++) n[i] = n[i - 1], n[i] += t[i - 1].distanceTo(t[i]); return this }, raycast: function(e, t) { var n = this.geometry,
                        i = this.matrixWorld,
                        r = e.params.Line.threshold; if (null === n.boundingSphere && n.computeBoundingSphere(), vc.copy(n.boundingSphere), vc.applyMatrix4(i), vc.radius += r, !1 !== e.ray.intersectsSphere(vc)) { mc.getInverse(i), gc.copy(e.ray).applyMatrix4(mc), i = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), i *= i; var a = new l,
                            o = new l;
                        r = new l; var s = new l,
                            c = this && this.isLineSegments ? 2 : 1; if (n.isBufferGeometry) { var h = n.index,
                                u = n.attributes.position.array; if (null !== h) { n = 0; for (var p = (h = h.array).length - 1; n < p; n += c) { var d = h[n + 1];
                                    a.fromArray(u, 3 * h[n]), o.fromArray(u, 3 * d), (d = gc.distanceSqToSegment(a, o, s, r)) > i || (s.applyMatrix4(this.matrixWorld), (d = e.ray.origin.distanceTo(s)) < e.near || d > e.far || t.push({ distance: d, point: r.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this })) } } else
                                for (n = 0, p = u.length / 3 - 1; n < p; n += c) a.fromArray(u, 3 * n), o.fromArray(u, 3 * n + 3), (d = gc.distanceSqToSegment(a, o, s, r)) > i || (s.applyMatrix4(this.matrixWorld), (d = e.ray.origin.distanceTo(s)) < e.near || d > e.far || t.push({ distance: d, point: r.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this })) } else if (n.isGeometry)
                            for (o = (a = n.vertices).length, n = 0; n < o - 1; n += c)(d = gc.distanceSqToSegment(a[n], a[n + 1], s, r)) > i || (s.applyMatrix4(this.matrixWorld), (d = e.ray.origin.distanceTo(s)) < e.near || d > e.far || t.push({ distance: d, point: r.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this })) } }, updateMorphTargets: function() { var e = this.geometry; if (e.isBufferGeometry) { e = e.morphAttributes; var t = Object.keys(e); if (0 < t.length) { var n = e[t[0]]; if (void 0 !== n)
                                for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = n.length; e < t; e++) { var i = n[e].name || String(e);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = e } } } else void 0 !== (e = e.morphTargets) && 0 < e.length && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.") }, clone: function() { return new this.constructor(this.geometry, this.material).copy(this) } }); var yc = new l,
                xc = new l;
            Kt.prototype = Object.assign(Object.create(Qt.prototype), { constructor: Kt, isLineSegments: !0, computeLineDistances: function() { var e = this.geometry; if (e.isBufferGeometry)
                        if (null === e.index) { for (var t = e.attributes.position, n = [], i = 0, r = t.count; i < r; i += 2) yc.fromBufferAttribute(t, i), xc.fromBufferAttribute(t, i + 1), n[i] = 0 === i ? 0 : n[i - 1], n[i + 1] = n[i] + yc.distanceTo(xc);
                            e.setAttribute("lineDistance", new B(n, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    else if (e.isGeometry)
                        for (t = e.vertices, n = e.lineDistances, i = 0, r = t.length; i < r; i += 2) yc.copy(t[i]), xc.copy(t[i + 1]), n[i] = 0 === i ? 0 : n[i - 1], n[i + 1] = n[i] + yc.distanceTo(xc); return this } }), $t.prototype = Object.assign(Object.create(Qt.prototype), { constructor: $t, isLineLoop: !0 }), en.prototype = Object.create(E.prototype), en.prototype.constructor = en, en.prototype.isPointsMaterial = !0, en.prototype.copy = function(e) { return E.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this }; var _c = new h,
                bc = new y,
                wc = new v,
                Mc = new l;
            tn.prototype = Object.assign(Object.create(d.prototype), { constructor: tn, isPoints: !0, raycast: function(e, t) { var n = this.geometry,
                        i = this.matrixWorld,
                        r = e.params.Points.threshold; if (null === n.boundingSphere && n.computeBoundingSphere(), wc.copy(n.boundingSphere), wc.applyMatrix4(i), wc.radius += r, !1 !== e.ray.intersectsSphere(wc))
                        if (_c.getInverse(i), bc.copy(e.ray).applyMatrix4(_c), r /= (this.scale.x + this.scale.y + this.scale.z) / 3, r *= r, n.isBufferGeometry) { var a = n.index; if (n = n.attributes.position.array, null !== a) { var o = a.array;
                                a = 0; for (var s = o.length; a < s; a++) { var c = o[a];
                                    Mc.fromArray(n, 3 * c), nn(Mc, c, r, i, e, t, this) } } else
                                for (a = 0, o = n.length / 3; a < o; a++) Mc.fromArray(n, 3 * a), nn(Mc, a, r, i, e, t, this) } else
                            for (a = 0, o = (n = n.vertices).length; a < o; a++) nn(n[a], a, r, i, e, t, this) }, updateMorphTargets: function() { var e = this.geometry; if (e.isBufferGeometry) { e = e.morphAttributes; var t = Object.keys(e); if (0 < t.length) { var n = e[t[0]]; if (void 0 !== n)
                                for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = n.length; e < t; e++) { var i = n[e].name || String(e);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = e } } } else void 0 !== (e = e.morphTargets) && 0 < e.length && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.") }, clone: function() { return new this.constructor(this.geometry, this.material).copy(this) } }), rn.prototype = Object.assign(Object.create(r.prototype), { constructor: rn, isVideoTexture: !0, update: function() { var e = this.image;
                    e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } }), an.prototype = Object.create(r.prototype), an.prototype.constructor = an, an.prototype.isCompressedTexture = !0, on.prototype = Object.create(r.prototype), on.prototype.constructor = on, on.prototype.isCanvasTexture = !0, sn.prototype = Object.create(r.prototype), sn.prototype.constructor = sn, sn.prototype.isDepthTexture = !0, cn.prototype = Object.create(G.prototype), cn.prototype.constructor = cn, ln.prototype = Object.create(j.prototype), ln.prototype.constructor = ln, hn.prototype = Object.create(G.prototype), hn.prototype.constructor = hn, un.prototype = Object.create(j.prototype), un.prototype.constructor = un, pn.prototype = Object.create(G.prototype), pn.prototype.constructor = pn, dn.prototype = Object.create(j.prototype), dn.prototype.constructor = dn, fn.prototype = Object.create(pn.prototype), fn.prototype.constructor = fn, mn.prototype = Object.create(j.prototype), mn.prototype.constructor = mn, gn.prototype = Object.create(pn.prototype), gn.prototype.constructor = gn, vn.prototype = Object.create(j.prototype), vn.prototype.constructor = vn, yn.prototype = Object.create(pn.prototype), yn.prototype.constructor = yn, xn.prototype = Object.create(j.prototype), xn.prototype.constructor = xn, _n.prototype = Object.create(pn.prototype), _n.prototype.constructor = _n, bn.prototype = Object.create(j.prototype), bn.prototype.constructor = bn, wn.prototype = Object.create(G.prototype), wn.prototype.constructor = wn, wn.prototype.toJSON = function() { var e = G.prototype.toJSON.call(this); return e.path = this.parameters.path.toJSON(), e }, Mn.prototype = Object.create(j.prototype), Mn.prototype.constructor = Mn, Sn.prototype = Object.create(G.prototype), Sn.prototype.constructor = Sn, Tn.prototype = Object.create(j.prototype), Tn.prototype.constructor = Tn, En.prototype = Object.create(G.prototype), En.prototype.constructor = En; var Sc = function(e, t, n) { n = n || 2; var i, r = t && t.length,
                        a = r ? t[0] * n : e.length,
                        o = An(e, 0, a, n, !0),
                        s = []; if (!o || o.next === o.prev) return s; if (r) { var c, l = n;
                        r = []; var h = 0; for (c = t.length; h < c; h++) { var u = t[h] * l;
                            (u = An(e, u, h < c - 1 ? t[h + 1] * l : e.length, l, !1)) === u.next && (u.steiner = !0), r.push(Dn(u)) } for (r.sort(Pn), h = 0; h < r.length; h++)(t = Cn(l = r[h], t = o)) && (l = Hn(t, l), Ln(t, t.next), Ln(l, l.next)), o = Ln(o, o.next) } if (e.length > 80 * n) { var p = i = e[0],
                            d = r = e[1]; for (l = n; l < a; l += n)(h = e[l]) < p && (p = h), (t = e[l + 1]) < d && (d = t), h > i && (i = h), t > r && (r = t);
                        i = 0 !== (i = Math.max(i - p, r - d)) ? 1 / i : 0 } return function e(t, n, i, r, a, o, s) { if (t) { if (!s && o) { var c = t,
                                    l = c;
                                do { null === l.z && (l.z = On(l.x, l.y, r, a, o)), l.prevZ = l.prev, l = l.nextZ = l.next } while (l !== c);
                                l.prevZ.nextZ = null, l.prevZ = null, c = l; var h, u, p, d, f = 1;
                                do { l = c; var m = c = null; for (u = 0; l;) { u++; var g = l; for (h = p = 0; h < f && (p++, g = g.nextZ); h++); for (d = f; 0 < p || 0 < d && g;) 0 !== p && (0 === d || !g || l.z <= g.z) ? (h = l, l = l.nextZ, p--) : (h = g, g = g.nextZ, d--), m ? m.nextZ = h : c = h, h.prevZ = m, m = h;
                                        l = g } m.nextZ = null, f *= 2 } while (1 < u) } for (c = t; t.prev !== t.next;) { if (l = t.prev, g = t.next, o) m = Rn(t, r, a, o);
                                else e: if (m = t, u = m.prev, p = m, f = m.next, 0 <= Nn(u, p, f)) m = !1;
                                    else { for (h = m.next.next; h !== m.prev;) { if (In(u.x, u.y, p.x, p.y, f.x, f.y, h.x, h.y) && 0 <= Nn(h.prev, h, h.next)) { m = !1; break e } h = h.next } m = !0 } if (m) n.push(l.i / i), n.push(t.i / i), n.push(g.i / i), Vn(t), c = t = g.next;
                                else if ((t = g) === c) { if (s) { if (1 === s) { s = n, c = i, l = t = Ln(t);
                                            do {!Bn(g = l.prev, m = l.next.next) && zn(g, l, l.next, m) && Gn(g, m) && Gn(m, g) && (s.push(g.i / c), s.push(l.i / c), s.push(m.i / c), Vn(l), Vn(l.next), l = t = m), l = l.next } while (l !== t);
                                            e(t = Ln(l), n, i, r, a, o, 2) } else if (2 === s) e: { s = t;do { for (c = s.next.next; c !== s.prev;) { if (l = s.i !== c.i) { if (g = c, m = (l = s).next.i !== g.i && l.prev.i !== g.i) { t: { m = l;do { if (m.i !== l.i && m.next.i !== l.i && m.i !== g.i && m.next.i !== g.i && zn(m, m.next, l, g)) { m = !0; break t } m = m.next } while (m !== l);m = !1 } m = !m } if (m) { if (m = Gn(l, g) && Gn(g, l)) { m = l, u = !1, p = (l.x + g.x) / 2, f = (l.y + g.y) / 2;
                                                                do { m.y > f != m.next.y > f && m.next.y !== m.y && p < (m.next.x - m.x) * (f - m.y) / (m.next.y - m.y) + m.x && (u = !u), m = m.next } while (m !== l);
                                                                m = u } m = m && (Nn(l.prev, l, g.prev) || Nn(l, g.prev, g)) || Bn(l, g) && 0 < Nn(l.prev, l, l.next) && 0 < Nn(g.prev, g, g.next) } l = m } if (l) { t = Hn(s, c), s = Ln(s, s.next), t = Ln(t, t.next), e(s, n, i, r, a, o), e(t, n, i, r, a, o); break e } c = c.next } s = s.next } while (s !== t) } } else e(Ln(t), n, i, r, a, o, 1); break } } } }(o, s, n, p, d, i), s },
                Tc = { area: function(e) { for (var t = e.length, n = 0, i = t - 1, r = 0; r < t; i = r++) n += e[i].x * e[r].y - e[r].x * e[i].y; return .5 * n }, isClockWise: function(e) { return 0 > Tc.area(e) }, triangulateShape: function(e, t) { var n = [],
                            i = [],
                            r = [];
                        Wn(e), qn(n, e); var a = e.length; for (t.forEach(Wn), e = 0; e < t.length; e++) i.push(a), a += t[e].length, qn(n, t[e]); for (t = Sc(n, i), e = 0; e < t.length; e += 3) r.push(t.slice(e, e + 3)); return r } };
            Xn.prototype = Object.create(j.prototype), Xn.prototype.constructor = Xn, Xn.prototype.toJSON = function() { var e = j.prototype.toJSON.call(this); return Zn(this.parameters.shapes, this.parameters.options, e) }, Yn.prototype = Object.create(G.prototype), Yn.prototype.constructor = Yn, Yn.prototype.toJSON = function() { var e = G.prototype.toJSON.call(this); return Zn(this.parameters.shapes, this.parameters.options, e) }; var Ec = { generateTopUV: function(e, t, i, r, a) { e = t[3 * r], r = t[3 * r + 1]; var o = t[3 * a]; return a = t[3 * a + 1], [new n(t[3 * i], t[3 * i + 1]), new n(e, r), new n(o, a)] }, generateSideWallUV: function(e, t, i, r, a, o) { e = t[3 * i]; var s = t[3 * i + 1];
                    i = t[3 * i + 2]; var c = t[3 * r],
                        l = t[3 * r + 1];
                    r = t[3 * r + 2]; var h = t[3 * a],
                        u = t[3 * a + 1];
                    a = t[3 * a + 2]; var p = t[3 * o],
                        d = t[3 * o + 1]; return t = t[3 * o + 2], .01 > Math.abs(s - l) ? [new n(e, 1 - i), new n(c, 1 - r), new n(h, 1 - a), new n(p, 1 - t)] : [new n(s, 1 - i), new n(l, 1 - r), new n(u, 1 - a), new n(d, 1 - t)] } };
            Jn.prototype = Object.create(j.prototype), Jn.prototype.constructor = Jn, Qn.prototype = Object.create(Yn.prototype), Qn.prototype.constructor = Qn, Kn.prototype = Object.create(j.prototype), Kn.prototype.constructor = Kn, $n.prototype = Object.create(G.prototype), $n.prototype.constructor = $n, ei.prototype = Object.create(j.prototype), ei.prototype.constructor = ei, ti.prototype = Object.create(G.prototype), ti.prototype.constructor = ti, ni.prototype = Object.create(j.prototype), ni.prototype.constructor = ni, ii.prototype = Object.create(G.prototype), ii.prototype.constructor = ii, ri.prototype = Object.create(j.prototype), ri.prototype.constructor = ri, ri.prototype.toJSON = function() { var e = j.prototype.toJSON.call(this); return oi(this.parameters.shapes, e) }, ai.prototype = Object.create(G.prototype), ai.prototype.constructor = ai, ai.prototype.toJSON = function() { var e = G.prototype.toJSON.call(this); return oi(this.parameters.shapes, e) }, si.prototype = Object.create(G.prototype), si.prototype.constructor = si, ci.prototype = Object.create(j.prototype), ci.prototype.constructor = ci, li.prototype = Object.create(G.prototype), li.prototype.constructor = li, hi.prototype = Object.create(ci.prototype), hi.prototype.constructor = hi, ui.prototype = Object.create(li.prototype), ui.prototype.constructor = ui, pi.prototype = Object.create(j.prototype), pi.prototype.constructor = pi, di.prototype = Object.create(G.prototype), di.prototype.constructor = di; var Ac = Object.freeze({ __proto__: null, WireframeGeometry: cn, ParametricGeometry: ln, ParametricBufferGeometry: hn, TetrahedronGeometry: dn, TetrahedronBufferGeometry: fn, OctahedronGeometry: mn, OctahedronBufferGeometry: gn, IcosahedronGeometry: vn, IcosahedronBufferGeometry: yn, DodecahedronGeometry: xn, DodecahedronBufferGeometry: _n, PolyhedronGeometry: un, PolyhedronBufferGeometry: pn, TubeGeometry: bn, TubeBufferGeometry: wn, TorusKnotGeometry: Mn, TorusKnotBufferGeometry: Sn, TorusGeometry: Tn, TorusBufferGeometry: En, TextGeometry: Jn, TextBufferGeometry: Qn, SphereGeometry: Kn, SphereBufferGeometry: $n, RingGeometry: ei, RingBufferGeometry: ti, PlaneGeometry: ne, PlaneBufferGeometry: ie, LatheGeometry: ni, LatheBufferGeometry: ii, ShapeGeometry: ri, ShapeBufferGeometry: ai, ExtrudeGeometry: Xn, ExtrudeBufferGeometry: Yn, EdgesGeometry: si, ConeGeometry: hi, ConeBufferGeometry: ui, CylinderGeometry: ci, CylinderBufferGeometry: li, CircleGeometry: pi, CircleBufferGeometry: di, BoxGeometry: vs, BoxBufferGeometry: ys });
            fi.prototype = Object.create(E.prototype), fi.prototype.constructor = fi, fi.prototype.isShadowMaterial = !0, fi.prototype.copy = function(e) { return E.prototype.copy.call(this, e), this.color.copy(e.color), this }, mi.prototype = Object.create(X.prototype), mi.prototype.constructor = mi, mi.prototype.isRawShaderMaterial = !0, gi.prototype = Object.create(E.prototype), gi.prototype.constructor = gi, gi.prototype.isMeshStandardMaterial = !0, gi.prototype.copy = function(e) { return E.prototype.copy.call(this, e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.vertexTangents = e.vertexTangents, this }, vi.prototype = Object.create(gi.prototype), vi.prototype.constructor = vi, vi.prototype.isMeshPhysicalMaterial = !0, vi.prototype.copy = function(e) { return gi.prototype.copy.call(this, e), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.reflectivity = e.reflectivity, this.sheen = e.sheen ? (this.sheen || new b).copy(e.sheen) : null, this.transparency = e.transparency, this }, yi.prototype = Object.create(E.prototype), yi.prototype.constructor = yi, yi.prototype.isMeshPhongMaterial = !0, yi.prototype.copy = function(e) { return E.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this }, xi.prototype = Object.create(E.prototype), xi.prototype.constructor = xi, xi.prototype.isMeshToonMaterial = !0, xi.prototype.copy = function(e) { return E.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this }, _i.prototype = Object.create(E.prototype), _i.prototype.constructor = _i, _i.prototype.isMeshNormalMaterial = !0, _i.prototype.copy = function(e) { return E.prototype.copy.call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this }, bi.prototype = Object.create(E.prototype), bi.prototype.constructor = bi, bi.prototype.isMeshLambertMaterial = !0, bi.prototype.copy = function(e) { return E.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this }, wi.prototype = Object.create(E.prototype), wi.prototype.constructor = wi, wi.prototype.isMeshMatcapMaterial = !0, wi.prototype.copy = function(e) { return E.prototype.copy.call(this, e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this }, Mi.prototype = Object.create(Jt.prototype), Mi.prototype.constructor = Mi, Mi.prototype.isLineDashedMaterial = !0, Mi.prototype.copy = function(e) { return Jt.prototype.copy.call(this, e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this }; var Lc = Object.freeze({ __proto__: null, ShadowMaterial: fi, SpriteMaterial: kt, RawShaderMaterial: mi, ShaderMaterial: X, PointsMaterial: en, MeshPhysicalMaterial: vi, MeshStandardMaterial: gi, MeshPhongMaterial: yi, MeshToonMaterial: xi, MeshNormalMaterial: _i, MeshLambertMaterial: bi, MeshDepthMaterial: Et, MeshDistanceMaterial: At, MeshBasicMaterial: A, MeshMatcapMaterial: wi, LineDashedMaterial: Mi, LineBasicMaterial: Jt, Material: E }),
                Rc = { arraySlice: function(e, t, n) { return Rc.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n) }, convertArray: function(e, t, n) { return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e) }, isTypedArray: function(e) { return ArrayBuffer.isView(e) && !(e instanceof DataView) }, getKeyframeOrder: function(e) { for (var t = e.length, n = Array(t), i = 0; i !== t; ++i) n[i] = i; return n.sort(function(t, n) { return e[t] - e[n] }), n }, sortedArray: function(e, t, n) { for (var i = e.length, r = new e.constructor(i), a = 0, o = 0; o !== i; ++a)
                            for (var s = n[a] * t, c = 0; c !== t; ++c) r[o++] = e[s + c]; return r }, flattenJSON: function(e, t, n, i) { for (var r = 1, a = e[0]; void 0 !== a && void 0 === a[i];) a = e[r++]; if (void 0 !== a) { var o = a[i]; if (void 0 !== o)
                                if (Array.isArray(o))
                                    do { void 0 !== (o = a[i]) && (t.push(a.time), n.push.apply(n, o)), a = e[r++] } while (void 0 !== a);
                                else if (void 0 !== o.toArray)
                                do { void 0 !== (o = a[i]) && (t.push(a.time), o.toArray(n, n.length)), a = e[r++] } while (void 0 !== a);
                            else
                                do { void 0 !== (o = a[i]) && (t.push(a.time), n.push(o)), a = e[r++] } while (void 0 !== a) } }, subclip: function(e, t, n, i, r) { r = r || 30, (e = e.clone()).name = t; var a = []; for (t = 0; t < e.tracks.length; ++t) { for (var o = e.tracks[t], s = o.getValueSize(), c = [], l = [], h = 0; h < o.times.length; ++h) { var u = o.times[h] * r; if (!(u < n || u >= i))
                                    for (c.push(o.times[h]), u = 0; u < s; ++u) l.push(o.values[h * s + u]) } 0 !== c.length && (o.times = Rc.convertArray(c, o.times.constructor), o.values = Rc.convertArray(l, o.values.constructor), a.push(o)) } for (e.tracks = a, n = 1 / 0, t = 0; t < e.tracks.length; ++t) n > e.tracks[t].times[0] && (n = e.tracks[t].times[0]); for (t = 0; t < e.tracks.length; ++t) e.tracks[t].shift(-1 * n); return e.resetDuration(), e }, makeClipAdditive: function(e, t, n, i) { void 0 === t && (t = 0), void 0 === n && (n = e), (void 0 === i || 0 >= i) && (i = 30); var r = e.tracks.length; for (t /= i, i = 0; i < r; ++i) { var a = n.tracks[i],
                                o = a.ValueTypeName; if ("bool" !== o && "string" !== o) { var s = e.tracks.find(function(e) { return e.name === a.name && e.ValueTypeName === o }); if (void 0 !== s) { var l = a.getValueSize(),
                                        h = a.times.length - 1;
                                    t <= a.times[0] ? h = Rc.arraySlice(a.values, 0, a.valueSize) : t >= a.times[h] ? h = Rc.arraySlice(a.values, h * l) : ((h = a.createInterpolant()).evaluate(t), h = h.resultBuffer), "quaternion" === o && new c(h[0], h[1], h[2], h[3]).normalize().conjugate().toArray(h); for (var u = s.times.length, p = 0; p < u; ++p) { var d = p * l; if ("quaternion" === o) c.multiplyQuaternionsFlat(s.values, d, h, 0, s.values, d);
                                        else
                                            for (var f = 0; f < l; ++f) s.values[d + f] -= h[f] } } } } return e.blendMode = 2501, e } };
            Object.assign(Si.prototype, { evaluate: function(e) { var t = this.parameterPositions,
                        n = this._cachedIndex,
                        i = t[n],
                        r = t[n - 1];
                    e: { t: { n: { i: if (!(e < i)) { for (var a = n + 2;;) { if (void 0 === i) { if (e < r) break i; return this._cachedIndex = n = t.length, this.afterEnd_(n - 1, e, r) } if (n === a) break; if (r = i, e < (i = t[++n])) break t } i = t.length; break n } if (e >= r) break e; for (e < (a = t[1]) && (n = 2, r = a), a = n - 2;;) { if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, e, i); if (n === a) break; if (i = r, e >= (r = t[--n - 1])) break t } i = n, n = 0 } for (; n < i;) e < t[r = n + i >>> 1] ? i = r : n = r + 1; if (i = t[n], void 0 === (r = t[n - 1])) return this._cachedIndex = 0, this.beforeStart_(0, e, i); if (void 0 === i) return this._cachedIndex = n = t.length, this.afterEnd_(n - 1, r, e) } this._cachedIndex = n, this.intervalChanged_(n, r, i) }
                    return this.interpolate_(n, r, e, i) }, settings: null, DefaultSettings_: {}, getSettings_: function() { return this.settings || this.DefaultSettings_ }, copySampleValue_: function(e) { var t = this.resultBuffer,
                        n = this.sampleValues,
                        i = this.valueSize;
                    e *= i; for (var r = 0; r !== i; ++r) t[r] = n[e + r]; return t }, interpolate_: function() { throw Error("call to abstract method") }, intervalChanged_: function() {} }), Object.assign(Si.prototype, { beforeStart_: Si.prototype.copySampleValue_, afterEnd_: Si.prototype.copySampleValue_ }), Ti.prototype = Object.assign(Object.create(Si.prototype), { constructor: Ti, DefaultSettings_: { endingStart: 2400, endingEnd: 2400 }, intervalChanged_: function(e, t, n) { var i = this.parameterPositions,
                        r = e - 2,
                        a = e + 1,
                        o = i[r],
                        s = i[a]; if (void 0 === o) switch (this.getSettings_().endingStart) {
                        case 2401:
                            r = e, o = 2 * t - n; break;
                        case 2402:
                            o = t + i[r = i.length - 2] - i[r + 1]; break;
                        default:
                            r = e, o = n }
                    if (void 0 === s) switch (this.getSettings_().endingEnd) {
                        case 2401:
                            a = e, s = 2 * n - t; break;
                        case 2402:
                            a = 1, s = n + i[1] - i[0]; break;
                        default:
                            a = e - 1, s = t } e = .5 * (n - t), i = this.valueSize, this._weightPrev = e / (t - o), this._weightNext = e / (s - n), this._offsetPrev = r * i, this._offsetNext = a * i }, interpolate_: function(e, t, n, i) { var r = this.resultBuffer,
                        a = this.sampleValues,
                        o = this.valueSize,
                        s = (e *= o) - o,
                        c = this._offsetPrev,
                        l = this._offsetNext,
                        h = this._weightPrev,
                        u = this._weightNext,
                        p = (n - t) / (i - t); for (t = -h * (i = (n = p * p) * p) + 2 * h * n - h * p, h = (1 + h) * i + (-1.5 - 2 * h) * n + (-.5 + h) * p + 1, p = (-1 - u) * i + (1.5 + u) * n + .5 * p, u = u * i - u * n, n = 0; n !== o; ++n) r[n] = t * a[c + n] + h * a[s + n] + p * a[e + n] + u * a[l + n]; return r } }), Ei.prototype = Object.assign(Object.create(Si.prototype), { constructor: Ei, interpolate_: function(e, t, n, i) { var r = this.resultBuffer,
                        a = this.sampleValues,
                        o = this.valueSize,
                        s = (e *= o) - o; for (n = 1 - (t = (n - t) / (i - t)), i = 0; i !== o; ++i) r[i] = a[s + i] * n + a[e + i] * t; return r } }), Ai.prototype = Object.assign(Object.create(Si.prototype), { constructor: Ai, interpolate_: function(e) { return this.copySampleValue_(e - 1) } }), Object.assign(Li, { toJSON: function(e) { var t = e.constructor; if (void 0 !== t.toJSON) t = t.toJSON(e);
                    else { t = { name: e.name, times: Rc.convertArray(e.times, Array), values: Rc.convertArray(e.values, Array) }; var n = e.getInterpolation();
                        n !== e.DefaultInterpolation && (t.interpolation = n) } return t.type = e.ValueTypeName, t } }), Object.assign(Li.prototype, { constructor: Li, TimeBufferType: Float32Array, ValueBufferType: Float32Array, DefaultInterpolation: 2301, InterpolantFactoryMethodDiscrete: function(e) { return new Ai(this.times, this.values, this.getValueSize(), e) }, InterpolantFactoryMethodLinear: function(e) { return new Ei(this.times, this.values, this.getValueSize(), e) }, InterpolantFactoryMethodSmooth: function(e) { return new Ti(this.times, this.values, this.getValueSize(), e) }, setInterpolation: function(e) { switch (e) {
                        case 2300:
                            var t = this.InterpolantFactoryMethodDiscrete; break;
                        case 2301:
                            t = this.InterpolantFactoryMethodLinear; break;
                        case 2302:
                            t = this.InterpolantFactoryMethodSmooth } if (void 0 === t) { if (t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name, void 0 === this.createInterpolant) { if (e === this.DefaultInterpolation) throw Error(t);
                            this.setInterpolation(this.DefaultInterpolation) } return console.warn("THREE.KeyframeTrack:", t), this } return this.createInterpolant = t, this }, getInterpolation: function() { switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return 2300;
                        case this.InterpolantFactoryMethodLinear:
                            return 2301;
                        case this.InterpolantFactoryMethodSmooth:
                            return 2302 } }, getValueSize: function() { return this.values.length / this.times.length }, shift: function(e) { if (0 !== e)
                        for (var t = this.times, n = 0, i = t.length; n !== i; ++n) t[n] += e; return this }, scale: function(e) { if (1 !== e)
                        for (var t = this.times, n = 0, i = t.length; n !== i; ++n) t[n] *= e; return this }, trim: function(e, t) { for (var n = this.times, i = n.length, r = 0, a = i - 1; r !== i && n[r] < e;) ++r; for (; - 1 !== a && n[a] > t;) --a; return ++a, 0 === r && a === i || (r >= a && (r = (a = Math.max(a, 1)) - 1), e = this.getValueSize(), this.times = Rc.arraySlice(n, r, a), this.values = Rc.arraySlice(this.values, r * e, a * e)), this }, validate: function() { var e = !0,
                        t = this.getValueSize();
                    0 != t - Math.floor(t) && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1); var n = this.times;
                    t = this.values; var i = n.length;
                    0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1); for (var r = null, a = 0; a !== i; a++) { var o = n[a]; if ("number" == typeof o && isNaN(o)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, o), e = !1; break } if (null !== r && r > o) { console.error("THREE.KeyframeTrack: Out of order keys.", this, a, o, r), e = !1; break } r = o } if (void 0 !== t && Rc.isTypedArray(t))
                        for (a = 0, n = t.length; a !== n; ++a)
                            if (i = t[a], isNaN(i)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, i), e = !1; break } return e }, optimize: function() { for (var e = Rc.arraySlice(this.times), t = Rc.arraySlice(this.values), n = this.getValueSize(), i = 2302 === this.getInterpolation(), r = 1, a = e.length - 1, o = 1; o < a; ++o) { var s = !1,
                            c = e[o]; if (c !== e[o + 1] && (1 !== o || c !== c[0]))
                            if (i) s = !0;
                            else { var l = o * n,
                                    h = l - n,
                                    u = l + n; for (c = 0; c !== n; ++c) { var p = t[l + c]; if (p !== t[h + c] || p !== t[u + c]) { s = !0; break } } } if (s) { if (o !== r)
                                for (e[r] = e[o], s = o * n, l = r * n, c = 0; c !== n; ++c) t[l + c] = t[s + c];++r } } if (0 < a) { for (e[r] = e[a], s = a * n, l = r * n, c = 0; c !== n; ++c) t[l + c] = t[s + c];++r } return r !== e.length ? (this.times = Rc.arraySlice(e, 0, r), this.values = Rc.arraySlice(t, 0, r * n)) : (this.times = e, this.values = t), this }, clone: function() { var e = Rc.arraySlice(this.times, 0),
                        t = Rc.arraySlice(this.values, 0); return (e = new this.constructor(this.name, e, t)).createInterpolant = this.createInterpolant, e } }), Ri.prototype = Object.assign(Object.create(Li.prototype), { constructor: Ri, ValueTypeName: "bool", ValueBufferType: Array, DefaultInterpolation: 2300, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), Pi.prototype = Object.assign(Object.create(Li.prototype), { constructor: Pi, ValueTypeName: "color" }), Ci.prototype = Object.assign(Object.create(Li.prototype), { constructor: Ci, ValueTypeName: "number" }), Oi.prototype = Object.assign(Object.create(Si.prototype), { constructor: Oi, interpolate_: function(e, t, n, i) { var r = this.resultBuffer,
                        a = this.sampleValues,
                        o = this.valueSize; for (t = (n - t) / (i - t), n = (e *= o) + o; e !== n; e += 4) c.slerpFlat(r, 0, a, e - o, a, e, t); return r } }), Di.prototype = Object.assign(Object.create(Li.prototype), { constructor: Di, ValueTypeName: "quaternion", DefaultInterpolation: 2301, InterpolantFactoryMethodLinear: function(e) { return new Oi(this.times, this.values, this.getValueSize(), e) }, InterpolantFactoryMethodSmooth: void 0 }), Ii.prototype = Object.assign(Object.create(Li.prototype), { constructor: Ii, ValueTypeName: "string", ValueBufferType: Array, DefaultInterpolation: 2300, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), Ni.prototype = Object.assign(Object.create(Li.prototype), { constructor: Ni, ValueTypeName: "vector" }), Object.assign(Bi, { parse: function(e) { for (var t = [], n = e.tracks, i = 1 / (e.fps || 1), r = 0, a = n.length; r !== a; ++r) t.push(zi(n[r]).scale(i)); return new Bi(e.name, e.duration, t, e.blendMode) }, toJSON: function(e) { var t = [],
                        n = e.tracks;
                    e = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode }; for (var i = 0, r = n.length; i !== r; ++i) t.push(Li.toJSON(n[i])); return e }, CreateFromMorphTargetSequence: function(e, t, n, i) { for (var r = t.length, a = [], o = 0; o < r; o++) { var s = [],
                            c = [];
                        s.push((o + r - 1) % r, o, (o + 1) % r), c.push(0, 1, 0); var l = Rc.getKeyframeOrder(s);
                        s = Rc.sortedArray(s, 1, l), c = Rc.sortedArray(c, 1, l), i || 0 !== s[0] || (s.push(r), c.push(c[0])), a.push(new Ci(".morphTargetInfluences[" + t[o].name + "]", s, c).scale(1 / n)) } return new Bi(e, -1, a) }, findByName: function(e, t) { var n = e; for (Array.isArray(e) || (n = e.geometry && e.geometry.animations || e.animations), e = 0; e < n.length; e++)
                        if (n[e].name === t) return n[e]; return null }, CreateClipsFromMorphTargetSequences: function(e, t, n) { for (var i = {}, r = /^([\w-]*?)([\d]+)$/, a = 0, o = e.length; a < o; a++) { var s = e[a],
                            c = s.name.match(r); if (c && 1 < c.length) { var l = c[1];
                            (c = i[l]) || (i[l] = c = []), c.push(s) } } for (l in e = [], i) e.push(Bi.CreateFromMorphTargetSequence(l, i[l], t, n)); return e }, parseAnimation: function(e, t) { if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; var n = function(e, t, n, i, r) { if (0 !== n.length) { var a = [],
                                    o = [];
                                Rc.flattenJSON(n, a, o, i), 0 !== a.length && r.push(new e(t, a, o)) } },
                        i = [],
                        r = e.name || "default",
                        a = e.length || -1,
                        o = e.fps || 30,
                        s = e.blendMode;
                    e = e.hierarchy || []; for (var c = 0; c < e.length; c++) { var l = e[c].keys; if (l && 0 !== l.length)
                            if (l[0].morphTargets) { a = {}; for (var h = 0; h < l.length; h++)
                                    if (l[h].morphTargets)
                                        for (var u = 0; u < l[h].morphTargets.length; u++) a[l[h].morphTargets[u]] = -1; for (var p in a) { var d = [],
                                        f = []; for (u = 0; u !== l[h].morphTargets.length; ++u) { var m = l[h];
                                        d.push(m.time), f.push(m.morphTarget === p ? 1 : 0) } i.push(new Ci(".morphTargetInfluence[" + p + "]", d, f)) } a = a.length * (o || 1) } else n(Ni, (h = ".bones[" + t[c].name + "]") + ".position", l, "pos", i), n(Di, h + ".quaternion", l, "rot", i), n(Ni, h + ".scale", l, "scl", i) } return 0 === i.length ? null : new Bi(r, a, i, s) } }), Object.assign(Bi.prototype, { resetDuration: function() { for (var e = 0, t = 0, n = this.tracks.length; t !== n; ++t) { var i = this.tracks[t];
                        e = Math.max(e, i.times[i.times.length - 1]) } return this.duration = e, this }, trim: function() { for (var e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration); return this }, validate: function() { for (var e = !0, t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate(); return e }, optimize: function() { for (var e = 0; e < this.tracks.length; e++) this.tracks[e].optimize(); return this }, clone: function() { for (var e = [], t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone()); return new Bi(this.name, this.duration, e, this.blendMode) } }); var Pc = { enabled: !1, files: {}, add: function(e, t) {!1 !== this.enabled && (this.files[e] = t) }, get: function(e) { if (!1 !== this.enabled) return this.files[e] }, remove: function(e) { delete this.files[e] }, clear: function() { this.files = {} } },
                Cc = new Ui;
            Object.assign(Fi.prototype, { load: function() {}, loadAsync: function(e, t) { var n = this; return new Promise(function(i, r) { n.load(e, i, t, r) }) }, parse: function() {}, setCrossOrigin: function(e) { return this.crossOrigin = e, this }, setPath: function(e) { return this.path = e, this }, setResourcePath: function(e) { return this.resourcePath = e, this }, setRequestHeader: function(e) { return this.requestHeader = e, this } }); var Oc = {};
            Gi.prototype = Object.assign(Object.create(Fi.prototype), { constructor: Gi, load: function(e, t, n, i) { void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); var r = this,
                        a = Pc.get(e); if (void 0 !== a) return r.manager.itemStart(e), setTimeout(function() { t && t(a), r.manager.itemEnd(e) }, 0), a; if (void 0 === Oc[e]) { var o = e.match(/^data:(.*?)(;base64)?,(.*)$/); if (o) { n = o[1]; var s = !!o[2];
                            o = o[3], o = decodeURIComponent(o), s && (o = atob(o)); try { var c = (this.responseType || "").toLowerCase(); switch (c) {
                                    case "arraybuffer":
                                    case "blob":
                                        var l = new Uint8Array(o.length); for (s = 0; s < o.length; s++) l[s] = o.charCodeAt(s); var h = "blob" === c ? new Blob([l.buffer], { type: n }) : l.buffer; break;
                                    case "document":
                                        h = (new DOMParser).parseFromString(o, n); break;
                                    case "json":
                                        h = JSON.parse(o); break;
                                    default:
                                        h = o } setTimeout(function() { t && t(h), r.manager.itemEnd(e) }, 0) } catch (t) { setTimeout(function() { i && i(t), r.manager.itemError(e), r.manager.itemEnd(e) }, 0) } } else { Oc[e] = [], Oc[e].push({ onLoad: t, onProgress: n, onError: i }); var u = new XMLHttpRequest; for (s in u.open("GET", e, !0), u.addEventListener("load", function(t) { var n = this.response,
                                        i = Oc[e]; if (delete Oc[e], 200 === this.status || 0 === this.status) { 0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), Pc.add(e, n); for (var a = 0, o = i.length; a < o; a++) { var s = i[a];
                                            s.onLoad && s.onLoad(n) } } else { for (a = 0, o = i.length; a < o; a++)(s = i[a]).onError && s.onError(t);
                                        r.manager.itemError(e) } r.manager.itemEnd(e) }, !1), u.addEventListener("progress", function(t) { for (var n = Oc[e], i = 0, r = n.length; i < r; i++) { var a = n[i];
                                        a.onProgress && a.onProgress(t) } }, !1), u.addEventListener("error", function(t) { var n = Oc[e];
                                    delete Oc[e]; for (var i = 0, a = n.length; i < a; i++) { var o = n[i];
                                        o.onError && o.onError(t) } r.manager.itemError(e), r.manager.itemEnd(e) }, !1), u.addEventListener("abort", function(t) { var n = Oc[e];
                                    delete Oc[e]; for (var i = 0, a = n.length; i < a; i++) { var o = n[i];
                                        o.onError && o.onError(t) } r.manager.itemError(e), r.manager.itemEnd(e) }, !1), void 0 !== this.responseType && (u.responseType = this.responseType), void 0 !== this.withCredentials && (u.withCredentials = this.withCredentials), u.overrideMimeType && u.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) u.setRequestHeader(s, this.requestHeader[s]);
                            u.send(null) } return r.manager.itemStart(e), u } Oc[e].push({ onLoad: t, onProgress: n, onError: i }) }, setResponseType: function(e) { return this.responseType = e, this }, setWithCredentials: function(e) { return this.withCredentials = e, this }, setMimeType: function(e) { return this.mimeType = e, this } }), Hi.prototype = Object.assign(Object.create(Fi.prototype), { constructor: Hi, load: function(e, t, n, i) { var r = this,
                        a = new Gi(r.manager);
                    a.setPath(r.path), a.load(e, function(n) { try { t(r.parse(JSON.parse(n))) } catch (t) { i ? i(t) : console.error(t), r.manager.itemError(e) } }, n, i) }, parse: function(e) { for (var t = [], n = 0; n < e.length; n++) { var i = Bi.parse(e[n]);
                        t.push(i) } return t } }), ki.prototype = Object.assign(Object.create(Fi.prototype), { constructor: ki, load: function(e, t, n, i) {
                    function r(r) { c.load(e[r], function(e) { e = a.parse(e, !0), o[r] = { width: e.width, height: e.height, format: e.format, mipmaps: e.mipmaps }, 6 === (l += 1) && (1 === e.mipmapCount && (s.minFilter = 1006), s.format = e.format, s.needsUpdate = !0, t && t(s)) }, n, i) } var a = this,
                        o = [],
                        s = new an;
                    s.image = o; var c = new Gi(this.manager); if (c.setPath(this.path), c.setResponseType("arraybuffer"), Array.isArray(e))
                        for (var l = 0, h = 0, u = e.length; h < u; ++h) r(h);
                    else c.load(e, function(e) { if ((e = a.parse(e, !0)).isCubemap)
                            for (var n = e.mipmaps.length / e.mipmapCount, i = 0; i < n; i++) { o[i] = { mipmaps: [] }; for (var r = 0; r < e.mipmapCount; r++) o[i].mipmaps.push(e.mipmaps[i * e.mipmapCount + r]), o[i].format = e.format, o[i].width = e.width, o[i].height = e.height } else s.image.width = e.width, s.image.height = e.height, s.mipmaps = e.mipmaps;
                        1 === e.mipmapCount && (s.minFilter = 1006), s.format = e.format, s.needsUpdate = !0, t && t(s) }, n, i); return s } }), Vi.prototype = Object.assign(Object.create(Fi.prototype), { constructor: Vi, load: function(e, t, n, i) { var r = this,
                        a = new K,
                        o = new Gi(this.manager); return o.setResponseType("arraybuffer"), o.setPath(this.path), o.load(e, function(e) {
                        (e = r.parse(e)) && (void 0 !== e.image ? a.image = e.image : void 0 !== e.data && (a.image.width = e.width, a.image.height = e.height, a.image.data = e.data), a.wrapS = void 0 !== e.wrapS ? e.wrapS : 1001, a.wrapT = void 0 !== e.wrapT ? e.wrapT : 1001, a.magFilter = void 0 !== e.magFilter ? e.magFilter : 1006, a.minFilter = void 0 !== e.minFilter ? e.minFilter : 1006, a.anisotropy = void 0 !== e.anisotropy ? e.anisotropy : 1, void 0 !== e.format && (a.format = e.format), void 0 !== e.type && (a.type = e.type), void 0 !== e.mipmaps && (a.mipmaps = e.mipmaps, a.minFilter = 1008), 1 === e.mipmapCount && (a.minFilter = 1006), a.needsUpdate = !0, t && t(a, e)) }, n, i), a } }), ji.prototype = Object.assign(Object.create(Fi.prototype), { constructor: ji, load: function(e, t, n, i) {
                    function r() { c.removeEventListener("load", r, !1), c.removeEventListener("error", a, !1), Pc.add(e, this), t && t(this), o.manager.itemEnd(e) }

                    function a(t) { c.removeEventListener("load", r, !1), c.removeEventListener("error", a, !1), i && i(t), o.manager.itemError(e), o.manager.itemEnd(e) } void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); var o = this,
                        s = Pc.get(e); if (void 0 !== s) return o.manager.itemStart(e), setTimeout(function() { t && t(s), o.manager.itemEnd(e) }, 0), s; var c = document.createElementNS("http://www.w3.org/1999/xhtml", "img"); return c.addEventListener("load", r, !1), c.addEventListener("error", a, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (c.crossOrigin = this.crossOrigin), o.manager.itemStart(e), c.src = e, c } }), Wi.prototype = Object.assign(Object.create(Fi.prototype), { constructor: Wi, load: function(e, t, n, i) {
                    function r(n) { o.load(e[n], function(e) { a.images[n] = e, 6 === ++s && (a.needsUpdate = !0, t && t(a)) }, void 0, i) } var a = new me,
                        o = new ji(this.manager);
                    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path); var s = 0; for (n = 0; n < e.length; ++n) r(n); return a } }), qi.prototype = Object.assign(Object.create(Fi.prototype), { constructor: qi, load: function(e, t, n, i) { var a = new r,
                        o = new ji(this.manager); return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(n) { a.image = n, n = 0 < e.search(/\.jpe?g($|\?)/i) || 0 === e.search(/^data:image\/jpeg/), a.format = n ? 1022 : 1023, a.needsUpdate = !0, void 0 !== t && t(a) }, n, i), a } }), Object.assign(Xi.prototype, { getPoint: function() { return console.warn("THREE.Curve: .getPoint() not implemented."), null }, getPointAt: function(e, t) { return e = this.getUtoTmapping(e), this.getPoint(e, t) }, getPoints: function(e) { void 0 === e && (e = 5); for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e)); return t }, getSpacedPoints: function(e) { void 0 === e && (e = 5); for (var t = [], n = 0; n <= e; n++) t.push(this.getPointAt(n / e)); return t }, getLength: function() { var e = this.getLengths(); return e[e.length - 1] }, getLengths: function(e) { if (void 0 === e && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1; var t, n = [],
                        i = this.getPoint(0),
                        r = 0; for (n.push(0), t = 1; t <= e; t++) { var a = this.getPoint(t / e);
                        r += a.distanceTo(i), n.push(r), i = a } return this.cacheArcLengths = n }, updateArcLengths: function() { this.needsUpdate = !0, this.getLengths() }, getUtoTmapping: function(e, t) { var n = this.getLengths(),
                        i = n.length;
                    t = t || e * n[i - 1]; for (var r, a = 0, o = i - 1; a <= o;)
                        if (0 > (r = n[e = Math.floor(a + (o - a) / 2)] - t)) a = e + 1;
                        else { if (!(0 < r)) { o = e; break } o = e - 1 } return n[e = o] === t ? e / (i - 1) : (e + (t - (a = n[e])) / (n[e + 1] - a)) / (i - 1) }, getTangent: function(e, t) { var i = e - 1e-4; return 0 > i && (i = 0), 1 < (e += 1e-4) && (e = 1), i = this.getPoint(i), e = this.getPoint(e), (t = t || (i.isVector2 ? new n : new l)).copy(e).sub(i).normalize(), t }, getTangentAt: function(e, t) { return e = this.getUtoTmapping(e), this.getTangent(e, t) }, computeFrenetFrames: function(e, t) { var n, i = new l,
                        r = [],
                        a = [],
                        o = [],
                        s = new l,
                        c = new h; for (n = 0; n <= e; n++) { var u = n / e;
                        r[n] = this.getTangentAt(u, new l), r[n].normalize() } a[0] = new l, o[0] = new l, n = Number.MAX_VALUE, u = Math.abs(r[0].x); var p = Math.abs(r[0].y),
                        d = Math.abs(r[0].z); for (u <= n && (n = u, i.set(1, 0, 0)), p <= n && (n = p, i.set(0, 1, 0)), d <= n && i.set(0, 0, 1), s.crossVectors(r[0], i).normalize(), a[0].crossVectors(r[0], s), o[0].crossVectors(r[0], a[0]), n = 1; n <= e; n++) a[n] = a[n - 1].clone(), o[n] = o[n - 1].clone(), s.crossVectors(r[n - 1], r[n]), s.length() > Number.EPSILON && (s.normalize(), i = Math.acos(Ra.clamp(r[n - 1].dot(r[n]), -1, 1)), a[n].applyMatrix4(c.makeRotationAxis(s, i))), o[n].crossVectors(r[n], a[n]); if (!0 === t)
                        for (i = Math.acos(Ra.clamp(a[0].dot(a[e]), -1, 1)), i /= e, 0 < r[0].dot(s.crossVectors(a[0], a[e])) && (i = -i), n = 1; n <= e; n++) a[n].applyMatrix4(c.makeRotationAxis(r[n], i * n)), o[n].crossVectors(r[n], a[n]); return { tangents: r, normals: a, binormals: o } }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this }, toJSON: function() { var e = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e }, fromJSON: function(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } }), Yi.prototype = Object.create(Xi.prototype), Yi.prototype.constructor = Yi, Yi.prototype.isEllipseCurve = !0, Yi.prototype.getPoint = function(e, t) { t = t || new n; for (var i = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, a = Math.abs(r) < Number.EPSILON; 0 > r;) r += i; for (; r > i;) r -= i;
                r < Number.EPSILON && (r = a ? 0 : i), !0 !== this.aClockwise || a || (r = r === i ? -i : r - i), i = this.aStartAngle + e * r, e = this.aX + this.xRadius * Math.cos(i); var o = this.aY + this.yRadius * Math.sin(i); return 0 !== this.aRotation && (i = Math.cos(this.aRotation), r = Math.sin(this.aRotation), e = (a = e - this.aX) * i - (o -= this.aY) * r + this.aX, o = a * r + o * i + this.aY), t.set(e, o) }, Yi.prototype.copy = function(e) { return Xi.prototype.copy.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this }, Yi.prototype.toJSON = function() { var e = Xi.prototype.toJSON.call(this); return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e }, Yi.prototype.fromJSON = function(e) { return Xi.prototype.fromJSON.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this }, Zi.prototype = Object.create(Yi.prototype), Zi.prototype.constructor = Zi, Zi.prototype.isArcCurve = !0; var Dc = new l,
                Ic = new Ji,
                Nc = new Ji,
                Bc = new Ji;
            Qi.prototype = Object.create(Xi.prototype), Qi.prototype.constructor = Qi, Qi.prototype.isCatmullRomCurve3 = !0, Qi.prototype.getPoint = function(e, t) { t = t || new l; var n = this.points,
                    i = n.length;
                e *= i - (this.closed ? 0 : 1); var r = Math.floor(e); if (e -= r, this.closed ? r += 0 < r ? 0 : (Math.floor(Math.abs(r) / i) + 1) * i : 0 === e && r === i - 1 && (r = i - 2, e = 1), this.closed || 0 < r) var a = n[(r - 1) % i];
                else Dc.subVectors(n[0], n[1]).add(n[0]), a = Dc; var o = n[r % i],
                    s = n[(r + 1) % i]; if (this.closed || r + 2 < i ? n = n[(r + 2) % i] : (Dc.subVectors(n[i - 1], n[i - 2]).add(n[i - 1]), n = Dc), "centripetal" === this.curveType || "chordal" === this.curveType) { var c = "chordal" === this.curveType ? .5 : .25;
                    i = Math.pow(a.distanceToSquared(o), c), 1e-4 > (r = Math.pow(o.distanceToSquared(s), c)) && (r = 1), 1e-4 > i && (i = r), 1e-4 > (c = Math.pow(s.distanceToSquared(n), c)) && (c = r), Ic.initNonuniformCatmullRom(a.x, o.x, s.x, n.x, i, r, c), Nc.initNonuniformCatmullRom(a.y, o.y, s.y, n.y, i, r, c), Bc.initNonuniformCatmullRom(a.z, o.z, s.z, n.z, i, r, c) } else "catmullrom" === this.curveType && (Ic.initCatmullRom(a.x, o.x, s.x, n.x, this.tension), Nc.initCatmullRom(a.y, o.y, s.y, n.y, this.tension), Bc.initCatmullRom(a.z, o.z, s.z, n.z, this.tension)); return t.set(Ic.calc(e), Nc.calc(e), Bc.calc(e)), t }, Qi.prototype.copy = function(e) { Xi.prototype.copy.call(this, e), this.points = []; for (var t = 0, n = e.points.length; t < n; t++) this.points.push(e.points[t].clone()); return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this }, Qi.prototype.toJSON = function() { var e = Xi.prototype.toJSON.call(this);
                e.points = []; for (var t = 0, n = this.points.length; t < n; t++) e.points.push(this.points[t].toArray()); return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e }, Qi.prototype.fromJSON = function(e) { Xi.prototype.fromJSON.call(this, e), this.points = []; for (var t = 0, n = e.points.length; t < n; t++) { var i = e.points[t];
                    this.points.push((new l).fromArray(i)) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this }, tr.prototype = Object.create(Xi.prototype), tr.prototype.constructor = tr, tr.prototype.isCubicBezierCurve = !0, tr.prototype.getPoint = function(e, t) { t = t || new n; var i = this.v0,
                    r = this.v1,
                    a = this.v2,
                    o = this.v3; return t.set(er(e, i.x, r.x, a.x, o.x), er(e, i.y, r.y, a.y, o.y)), t }, tr.prototype.copy = function(e) { return Xi.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this }, tr.prototype.toJSON = function() { var e = Xi.prototype.toJSON.call(this); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e }, tr.prototype.fromJSON = function(e) { return Xi.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this }, nr.prototype = Object.create(Xi.prototype), nr.prototype.constructor = nr, nr.prototype.isCubicBezierCurve3 = !0, nr.prototype.getPoint = function(e, t) { t = t || new l; var n = this.v0,
                    i = this.v1,
                    r = this.v2,
                    a = this.v3; return t.set(er(e, n.x, i.x, r.x, a.x), er(e, n.y, i.y, r.y, a.y), er(e, n.z, i.z, r.z, a.z)), t }, nr.prototype.copy = function(e) { return Xi.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this }, nr.prototype.toJSON = function() { var e = Xi.prototype.toJSON.call(this); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e }, nr.prototype.fromJSON = function(e) { return Xi.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this }, ir.prototype = Object.create(Xi.prototype), ir.prototype.constructor = ir, ir.prototype.isLineCurve = !0, ir.prototype.getPoint = function(e, t) { return t = t || new n, 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(e).add(this.v1)), t }, ir.prototype.getPointAt = function(e, t) { return this.getPoint(e, t) }, ir.prototype.getTangent = function(e, t) { return (t || new n).copy(this.v2).sub(this.v1).normalize() }, ir.prototype.copy = function(e) { return Xi.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this }, ir.prototype.toJSON = function() { var e = Xi.prototype.toJSON.call(this); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e }, ir.prototype.fromJSON = function(e) { return Xi.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this }, rr.prototype = Object.create(Xi.prototype), rr.prototype.constructor = rr, rr.prototype.isLineCurve3 = !0, rr.prototype.getPoint = function(e, t) { return t = t || new l, 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(e).add(this.v1)), t }, rr.prototype.getPointAt = function(e, t) { return this.getPoint(e, t) }, rr.prototype.copy = function(e) { return Xi.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this }, rr.prototype.toJSON = function() { var e = Xi.prototype.toJSON.call(this); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e }, rr.prototype.fromJSON = function(e) { return Xi.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this }, ar.prototype = Object.create(Xi.prototype), ar.prototype.constructor = ar, ar.prototype.isQuadraticBezierCurve = !0, ar.prototype.getPoint = function(e, t) { t = t || new n; var i = this.v0,
                    r = this.v1,
                    a = this.v2; return t.set($i(e, i.x, r.x, a.x), $i(e, i.y, r.y, a.y)), t }, ar.prototype.copy = function(e) { return Xi.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this }, ar.prototype.toJSON = function() { var e = Xi.prototype.toJSON.call(this); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e }, ar.prototype.fromJSON = function(e) { return Xi.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this }, or.prototype = Object.create(Xi.prototype), or.prototype.constructor = or, or.prototype.isQuadraticBezierCurve3 = !0, or.prototype.getPoint = function(e, t) { t = t || new l; var n = this.v0,
                    i = this.v1,
                    r = this.v2; return t.set($i(e, n.x, i.x, r.x), $i(e, n.y, i.y, r.y), $i(e, n.z, i.z, r.z)), t }, or.prototype.copy = function(e) { return Xi.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this }, or.prototype.toJSON = function() { var e = Xi.prototype.toJSON.call(this); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e }, or.prototype.fromJSON = function(e) { return Xi.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this }, sr.prototype = Object.create(Xi.prototype), sr.prototype.constructor = sr, sr.prototype.isSplineCurve = !0, sr.prototype.getPoint = function(e, t) { t = t || new n; var i = this.points,
                    r = (i.length - 1) * e;
                r -= e = Math.floor(r); var a = i[0 === e ? e : e - 1],
                    o = i[e],
                    s = i[e > i.length - 2 ? i.length - 1 : e + 1]; return i = i[e > i.length - 3 ? i.length - 1 : e + 2], t.set(Ki(r, a.x, o.x, s.x, i.x), Ki(r, a.y, o.y, s.y, i.y)), t }, sr.prototype.copy = function(e) { Xi.prototype.copy.call(this, e), this.points = []; for (var t = 0, n = e.points.length; t < n; t++) this.points.push(e.points[t].clone()); return this }, sr.prototype.toJSON = function() { var e = Xi.prototype.toJSON.call(this);
                e.points = []; for (var t = 0, n = this.points.length; t < n; t++) e.points.push(this.points[t].toArray()); return e }, sr.prototype.fromJSON = function(e) { Xi.prototype.fromJSON.call(this, e), this.points = []; for (var t = 0, i = e.points.length; t < i; t++) { var r = e.points[t];
                    this.points.push((new n).fromArray(r)) } return this }; var zc = Object.freeze({ __proto__: null, ArcCurve: Zi, CatmullRomCurve3: Qi, CubicBezierCurve: tr, CubicBezierCurve3: nr, EllipseCurve: Yi, LineCurve: ir, LineCurve3: rr, QuadraticBezierCurve: ar, QuadraticBezierCurve3: or, SplineCurve: sr });
            cr.prototype = Object.assign(Object.create(Xi.prototype), { constructor: cr, add: function(e) { this.curves.push(e) }, closePath: function() { var e = this.curves[0].getPoint(0),
                        t = this.curves[this.curves.length - 1].getPoint(1);
                    e.equals(t) || this.curves.push(new ir(t, e)) }, getPoint: function(e) { var t = e * this.getLength(),
                        n = this.getCurveLengths(); for (e = 0; e < n.length;) { if (n[e] >= t) return t = n[e] - t, n = (e = this.curves[e]).getLength(), e.getPointAt(0 === n ? 0 : 1 - t / n);
                        e++ } return null }, getLength: function() { var e = this.getCurveLengths(); return e[e.length - 1] }, updateArcLengths: function() { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() }, getCurveLengths: function() { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; for (var e = [], t = 0, n = 0, i = this.curves.length; n < i; n++) t += this.curves[n].getLength(), e.push(t); return this.cacheLengths = e }, getSpacedPoints: function(e) { void 0 === e && (e = 40); for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e)); return this.autoClose && t.push(t[0]), t }, getPoints: function(e) { e = e || 12; for (var t, n = [], i = 0, r = this.curves; i < r.length; i++) { var a = r[i];
                        a = a.getPoints(a && a.isEllipseCurve ? 2 * e : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? e * a.points.length : e); for (var o = 0; o < a.length; o++) { var s = a[o];
                            t && t.equals(s) || (n.push(s), t = s) } } return this.autoClose && 1 < n.length && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n }, copy: function(e) { Xi.prototype.copy.call(this, e), this.curves = []; for (var t = 0, n = e.curves.length; t < n; t++) this.curves.push(e.curves[t].clone()); return this.autoClose = e.autoClose, this }, toJSON: function() { var e = Xi.prototype.toJSON.call(this);
                    e.autoClose = this.autoClose, e.curves = []; for (var t = 0, n = this.curves.length; t < n; t++) e.curves.push(this.curves[t].toJSON()); return e }, fromJSON: function(e) { Xi.prototype.fromJSON.call(this, e), this.autoClose = e.autoClose, this.curves = []; for (var t = 0, n = e.curves.length; t < n; t++) { var i = e.curves[t];
                        this.curves.push((new zc[i.type]).fromJSON(i)) } return this } }), lr.prototype = Object.assign(Object.create(cr.prototype), { constructor: lr, setFromPoints: function(e) { this.moveTo(e[0].x, e[0].y); for (var t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y); return this }, moveTo: function(e, t) { return this.currentPoint.set(e, t), this }, lineTo: function(e, t) { var i = new ir(this.currentPoint.clone(), new n(e, t)); return this.curves.push(i), this.currentPoint.set(e, t), this }, quadraticCurveTo: function(e, t, i, r) { return e = new ar(this.currentPoint.clone(), new n(e, t), new n(i, r)), this.curves.push(e), this.currentPoint.set(i, r), this }, bezierCurveTo: function(e, t, i, r, a, o) { return e = new tr(this.currentPoint.clone(), new n(e, t), new n(i, r), new n(a, o)), this.curves.push(e), this.currentPoint.set(a, o), this }, splineThru: function(e) { var t = [this.currentPoint.clone()].concat(e); return t = new sr(t), this.curves.push(t), this.currentPoint.copy(e[e.length - 1]), this }, arc: function(e, t, n, i, r, a) { return this.absarc(e + this.currentPoint.x, t + this.currentPoint.y, n, i, r, a), this }, absarc: function(e, t, n, i, r, a) { return this.absellipse(e, t, n, n, i, r, a), this }, ellipse: function(e, t, n, i, r, a, o, s) { return this.absellipse(e + this.currentPoint.x, t + this.currentPoint.y, n, i, r, a, o, s), this }, absellipse: function(e, t, n, i, r, a, o, s) { return e = new Yi(e, t, n, i, r, a, o, s), 0 < this.curves.length && ((t = e.getPoint(0)).equals(this.currentPoint) || this.lineTo(t.x, t.y)), this.curves.push(e), e = e.getPoint(1), this.currentPoint.copy(e), this }, copy: function(e) { return cr.prototype.copy.call(this, e), this.currentPoint.copy(e.currentPoint), this }, toJSON: function() { var e = cr.prototype.toJSON.call(this); return e.currentPoint = this.currentPoint.toArray(), e }, fromJSON: function(e) { return cr.prototype.fromJSON.call(this, e), this.currentPoint.fromArray(e.currentPoint), this } }), hr.prototype = Object.assign(Object.create(lr.prototype), { constructor: hr, getPointsHoles: function(e) { for (var t = [], n = 0, i = this.holes.length; n < i; n++) t[n] = this.holes[n].getPoints(e); return t }, extractPoints: function(e) { return { shape: this.getPoints(e), holes: this.getPointsHoles(e) } }, copy: function(e) { lr.prototype.copy.call(this, e), this.holes = []; for (var t = 0, n = e.holes.length; t < n; t++) this.holes.push(e.holes[t].clone()); return this }, toJSON: function() { var e = lr.prototype.toJSON.call(this);
                    e.uuid = this.uuid, e.holes = []; for (var t = 0, n = this.holes.length; t < n; t++) e.holes.push(this.holes[t].toJSON()); return e }, fromJSON: function(e) { lr.prototype.fromJSON.call(this, e), this.uuid = e.uuid, this.holes = []; for (var t = 0, n = e.holes.length; t < n; t++) { var i = e.holes[t];
                        this.holes.push((new lr).fromJSON(i)) } return this } }), ur.prototype = Object.assign(Object.create(d.prototype), { constructor: ur, isLight: !0, copy: function(e) { return d.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this }, toJSON: function(e) { return (e = d.prototype.toJSON.call(this, e)).object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e } }), pr.prototype = Object.assign(Object.create(ur.prototype), { constructor: pr, isHemisphereLight: !0, copy: function(e) { return ur.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this } }), Object.assign(dr.prototype, { _projScreenMatrix: new h, _lightPositionWorld: new l, _lookTarget: new l, getViewportCount: function() { return this._viewportCount }, getFrustum: function() { return this._frustum }, updateMatrices: function(e) { var t = this.camera,
                        n = this.matrix,
                        i = this._projScreenMatrix,
                        r = this._lookTarget,
                        a = this._lightPositionWorld;
                    a.setFromMatrixPosition(e.matrixWorld), t.position.copy(a), r.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(r), t.updateMatrixWorld(), i.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(i), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(t.projectionMatrix), n.multiply(t.matrixWorldInverse) }, getViewport: function(e) { return this._viewports[e] }, getFrameExtents: function() { return this._frameExtents }, copy: function(e) { return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this }, clone: function() { return (new this.constructor).copy(this) }, toJSON: function() { var e = {}; return 0 !== this.bias && (e.bias = this.bias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e } }), fr.prototype = Object.assign(Object.create(dr.prototype), { constructor: fr, isSpotLightShadow: !0, updateMatrices: function(e) { var t = this.camera,
                        n = 2 * Ra.RAD2DEG * e.angle,
                        i = this.mapSize.width / this.mapSize.height,
                        r = e.distance || t.far;
                    n === t.fov && i === t.aspect && r === t.far || (t.fov = n, t.aspect = i, t.far = r, t.updateProjectionMatrix()), dr.prototype.updateMatrices.call(this, e) } }), mr.prototype = Object.assign(Object.create(ur.prototype), { constructor: mr, isSpotLight: !0, copy: function(e) { return ur.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } }), gr.prototype = Object.assign(Object.create(dr.prototype), { constructor: gr, isPointLightShadow: !0, updateMatrices: function(e, t) { void 0 === t && (t = 0); var n = this.camera,
                        i = this.matrix,
                        r = this._lightPositionWorld,
                        a = this._lookTarget,
                        o = this._projScreenMatrix;
                    r.setFromMatrixPosition(e.matrixWorld), n.position.copy(r), a.copy(n.position), a.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(a), n.updateMatrixWorld(), i.makeTranslation(-r.x, -r.y, -r.z), o.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(o) } }), vr.prototype = Object.assign(Object.create(ur.prototype), { constructor: vr, isPointLight: !0, copy: function(e) { return ur.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this } }), yr.prototype = Object.assign(Object.create(Y.prototype), { constructor: yr, isOrthographicCamera: !0, copy: function(e, t) { return Y.prototype.copy.call(this, e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this }, setViewOffset: function(e, t, n, i, r, a) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix() }, clearViewOffset: function() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }, updateProjectionMatrix: function() { var e = (this.right - this.left) / (2 * this.zoom),
                        t = (this.top - this.bottom) / (2 * this.zoom),
                        n = (this.right + this.left) / 2,
                        i = (this.top + this.bottom) / 2,
                        r = n - e;
                    n += e, e = i + t, t = i - t, null !== this.view && this.view.enabled && (i = (this.right - this.left) / this.view.fullWidth / this.zoom, t = (this.top - this.bottom) / this.view.fullHeight / this.zoom, n = (r += i * this.view.offsetX) + i * this.view.width, t = (e -= t * this.view.offsetY) - t * this.view.height), this.projectionMatrix.makeOrthographic(r, n, e, t, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix) }, toJSON: function(e) { return (e = d.prototype.toJSON.call(this, e)).object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e } }), xr.prototype = Object.assign(Object.create(dr.prototype), { constructor: xr, isDirectionalLightShadow: !0, updateMatrices: function(e) { dr.prototype.updateMatrices.call(this, e) } }), _r.prototype = Object.assign(Object.create(ur.prototype), { constructor: _r, isDirectionalLight: !0, copy: function(e) { return ur.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } }), br.prototype = Object.assign(Object.create(ur.prototype), { constructor: br, isAmbientLight: !0 }), wr.prototype = Object.assign(Object.create(ur.prototype), { constructor: wr, isRectAreaLight: !0, copy: function(e) { return ur.prototype.copy.call(this, e), this.width = e.width, this.height = e.height, this }, toJSON: function(e) { return (e = ur.prototype.toJSON.call(this, e)).object.width = this.width, e.object.height = this.height, e } }), Object.assign(Mr.prototype, { isSphericalHarmonics3: !0, set: function(e) { for (var t = 0; 9 > t; t++) this.coefficients[t].copy(e[t]); return this }, zero: function() { for (var e = 0; 9 > e; e++) this.coefficients[e].set(0, 0, 0); return this }, getAt: function(e, t) { var n = e.x,
                        i = e.y;
                    e = e.z; var r = this.coefficients; return t.copy(r[0]).multiplyScalar(.282095), t.addScaledVector(r[1], .488603 * i), t.addScaledVector(r[2], .488603 * e), t.addScaledVector(r[3], .488603 * n), t.addScaledVector(r[4], 1.092548 * n * i), t.addScaledVector(r[5], 1.092548 * i * e), t.addScaledVector(r[6], .315392 * (3 * e * e - 1)), t.addScaledVector(r[7], 1.092548 * n * e), t.addScaledVector(r[8], .546274 * (n * n - i * i)), t }, getIrradianceAt: function(e, t) { var n = e.x,
                        i = e.y;
                    e = e.z; var r = this.coefficients; return t.copy(r[0]).multiplyScalar(.886227), t.addScaledVector(r[1], 1.023328 * i), t.addScaledVector(r[2], 1.023328 * e), t.addScaledVector(r[3], 1.023328 * n), t.addScaledVector(r[4], .858086 * n * i), t.addScaledVector(r[5], .858086 * i * e), t.addScaledVector(r[6], .743125 * e * e - .247708), t.addScaledVector(r[7], .858086 * n * e), t.addScaledVector(r[8], .429043 * (n * n - i * i)), t }, add: function(e) { for (var t = 0; 9 > t; t++) this.coefficients[t].add(e.coefficients[t]); return this }, addScaledSH: function(e, t) { for (var n = 0; 9 > n; n++) this.coefficients[n].addScaledVector(e.coefficients[n], t); return this }, scale: function(e) { for (var t = 0; 9 > t; t++) this.coefficients[t].multiplyScalar(e); return this }, lerp: function(e, t) { for (var n = 0; 9 > n; n++) this.coefficients[n].lerp(e.coefficients[n], t); return this }, equals: function(e) { for (var t = 0; 9 > t; t++)
                        if (!this.coefficients[t].equals(e.coefficients[t])) return !1; return !0 }, copy: function(e) { return this.set(e.coefficients) }, clone: function() { return (new this.constructor).copy(this) }, fromArray: function(e, t) { void 0 === t && (t = 0); for (var n = this.coefficients, i = 0; 9 > i; i++) n[i].fromArray(e, t + 3 * i); return this }, toArray: function(e, t) { void 0 === e && (e = []), void 0 === t && (t = 0); for (var n = this.coefficients, i = 0; 9 > i; i++) n[i].toArray(e, t + 3 * i); return e } }), Object.assign(Mr, { getBasisAt: function(e, t) { var n = e.x,
                        i = e.y;
                    e = e.z, t[0] = .282095, t[1] = .488603 * i, t[2] = .488603 * e, t[3] = .488603 * n, t[4] = 1.092548 * n * i, t[5] = 1.092548 * i * e, t[6] = .315392 * (3 * e * e - 1), t[7] = 1.092548 * n * e, t[8] = .546274 * (n * n - i * i) } }), Sr.prototype = Object.assign(Object.create(ur.prototype), { constructor: Sr, isLightProbe: !0, copy: function(e) { return ur.prototype.copy.call(this, e), this.sh.copy(e.sh), this }, fromJSON: function(e) { return this.intensity = e.intensity, this.sh.fromArray(e.sh), this }, toJSON: function(e) { return (e = ur.prototype.toJSON.call(this, e)).object.sh = this.sh.toArray(), e } }), Tr.prototype = Object.assign(Object.create(Fi.prototype), { constructor: Tr, load: function(e, t, n, i) { var r = this,
                        a = new Gi(r.manager);
                    a.setPath(r.path), a.load(e, function(n) { try { t(r.parse(JSON.parse(n))) } catch (t) { i ? i(t) : console.error(t), r.manager.itemError(e) } }, n, i) }, parse: function(e) {
                    function t(e) { return void 0 === r[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), r[e] } var r = this.textures,
                        o = new Lc[e.type]; if (void 0 !== e.uuid && (o.uuid = e.uuid), void 0 !== e.name && (o.name = e.name), void 0 !== e.color && o.color.setHex(e.color), void 0 !== e.roughness && (o.roughness = e.roughness), void 0 !== e.metalness && (o.metalness = e.metalness), void 0 !== e.sheen && (o.sheen = (new b).setHex(e.sheen)), void 0 !== e.emissive && o.emissive.setHex(e.emissive), void 0 !== e.specular && o.specular.setHex(e.specular), void 0 !== e.shininess && (o.shininess = e.shininess), void 0 !== e.clearcoat && (o.clearcoat = e.clearcoat), void 0 !== e.clearcoatRoughness && (o.clearcoatRoughness = e.clearcoatRoughness), void 0 !== e.fog && (o.fog = e.fog), void 0 !== e.flatShading && (o.flatShading = e.flatShading), void 0 !== e.blending && (o.blending = e.blending), void 0 !== e.combine && (o.combine = e.combine), void 0 !== e.side && (o.side = e.side), void 0 !== e.opacity && (o.opacity = e.opacity), void 0 !== e.transparent && (o.transparent = e.transparent), void 0 !== e.alphaTest && (o.alphaTest = e.alphaTest), void 0 !== e.depthTest && (o.depthTest = e.depthTest), void 0 !== e.depthWrite && (o.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (o.colorWrite = e.colorWrite), void 0 !== e.stencilWrite && (o.stencilWrite = e.stencilWrite), void 0 !== e.stencilWriteMask && (o.stencilWriteMask = e.stencilWriteMask), void 0 !== e.stencilFunc && (o.stencilFunc = e.stencilFunc), void 0 !== e.stencilRef && (o.stencilRef = e.stencilRef), void 0 !== e.stencilFuncMask && (o.stencilFuncMask = e.stencilFuncMask), void 0 !== e.stencilFail && (o.stencilFail = e.stencilFail), void 0 !== e.stencilZFail && (o.stencilZFail = e.stencilZFail), void 0 !== e.stencilZPass && (o.stencilZPass = e.stencilZPass), void 0 !== e.wireframe && (o.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (o.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (o.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (o.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (o.rotation = e.rotation), 1 !== e.linewidth && (o.linewidth = e.linewidth), void 0 !== e.dashSize && (o.dashSize = e.dashSize), void 0 !== e.gapSize && (o.gapSize = e.gapSize), void 0 !== e.scale && (o.scale = e.scale), void 0 !== e.polygonOffset && (o.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (o.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (o.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.skinning && (o.skinning = e.skinning), void 0 !== e.morphTargets && (o.morphTargets = e.morphTargets), void 0 !== e.morphNormals && (o.morphNormals = e.morphNormals), void 0 !== e.dithering && (o.dithering = e.dithering), void 0 !== e.vertexTangents && (o.vertexTangents = e.vertexTangents), void 0 !== e.visible && (o.visible = e.visible), void 0 !== e.toneMapped && (o.toneMapped = e.toneMapped), void 0 !== e.userData && (o.userData = e.userData), void 0 !== e.vertexColors && (o.vertexColors = "number" == typeof e.vertexColors ? 0 < e.vertexColors : e.vertexColors), void 0 !== e.uniforms)
                        for (var s in e.uniforms) { var c = e.uniforms[s]; switch (o.uniforms[s] = {}, c.type) {
                                case "t":
                                    o.uniforms[s].value = t(c.value); break;
                                case "c":
                                    o.uniforms[s].value = (new b).setHex(c.value); break;
                                case "v2":
                                    o.uniforms[s].value = (new n).fromArray(c.value); break;
                                case "v3":
                                    o.uniforms[s].value = (new l).fromArray(c.value); break;
                                case "v4":
                                    o.uniforms[s].value = (new a).fromArray(c.value); break;
                                case "m3":
                                    o.uniforms[s].value = (new i).fromArray(c.value);
                                case "m4":
                                    o.uniforms[s].value = (new h).fromArray(c.value); break;
                                default:
                                    o.uniforms[s].value = c.value } }
                    if (void 0 !== e.defines && (o.defines = e.defines), void 0 !== e.vertexShader && (o.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (o.fragmentShader = e.fragmentShader), void 0 !== e.extensions)
                        for (var u in e.extensions) o.extensions[u] = e.extensions[u]; return void 0 !== e.shading && (o.flatShading = 1 === e.shading), void 0 !== e.size && (o.size = e.size), void 0 !== e.sizeAttenuation && (o.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (o.map = t(e.map)), void 0 !== e.matcap && (o.matcap = t(e.matcap)), void 0 !== e.alphaMap && (o.alphaMap = t(e.alphaMap)), void 0 !== e.bumpMap && (o.bumpMap = t(e.bumpMap)), void 0 !== e.bumpScale && (o.bumpScale = e.bumpScale), void 0 !== e.normalMap && (o.normalMap = t(e.normalMap)), void 0 !== e.normalMapType && (o.normalMapType = e.normalMapType), void 0 !== e.normalScale && (s = e.normalScale, !1 === Array.isArray(s) && (s = [s, s]), o.normalScale = (new n).fromArray(s)), void 0 !== e.displacementMap && (o.displacementMap = t(e.displacementMap)), void 0 !== e.displacementScale && (o.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (o.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (o.roughnessMap = t(e.roughnessMap)), void 0 !== e.metalnessMap && (o.metalnessMap = t(e.metalnessMap)), void 0 !== e.emissiveMap && (o.emissiveMap = t(e.emissiveMap)), void 0 !== e.emissiveIntensity && (o.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (o.specularMap = t(e.specularMap)), void 0 !== e.envMap && (o.envMap = t(e.envMap)), void 0 !== e.envMapIntensity && (o.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (o.reflectivity = e.reflectivity), void 0 !== e.refractionRatio && (o.refractionRatio = e.refractionRatio), void 0 !== e.lightMap && (o.lightMap = t(e.lightMap)), void 0 !== e.lightMapIntensity && (o.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (o.aoMap = t(e.aoMap)), void 0 !== e.aoMapIntensity && (o.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (o.gradientMap = t(e.gradientMap)), void 0 !== e.clearcoatMap && (o.clearcoatMap = t(e.clearcoatMap)), void 0 !== e.clearcoatRoughnessMap && (o.clearcoatRoughnessMap = t(e.clearcoatRoughnessMap)), void 0 !== e.clearcoatNormalMap && (o.clearcoatNormalMap = t(e.clearcoatNormalMap)), void 0 !== e.clearcoatNormalScale && (o.clearcoatNormalScale = (new n).fromArray(e.clearcoatNormalScale)), o }, setTextures: function(e) { return this.textures = e, this } }); var Uc = { decodeText: function(e) { if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e); for (var t = "", n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]); try { return decodeURIComponent(escape(t)) } catch (e) { return t } }, extractUrlBase: function(e) { var t = e.lastIndexOf("/"); return -1 === t ? "./" : e.substr(0, t + 1) } };
            Er.prototype = Object.assign(Object.create(G.prototype), { constructor: Er, isInstancedBufferGeometry: !0, copy: function(e) { return G.prototype.copy.call(this, e), this.instanceCount = e.instanceCount, this }, clone: function() { return (new this.constructor).copy(this) }, toJSON: function() { var e = G.prototype.toJSON.call(this); return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e } }), Ar.prototype = Object.assign(Object.create(L.prototype), { constructor: Ar, isInstancedBufferAttribute: !0, copy: function(e) { return L.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this }, toJSON: function() { var e = L.prototype.toJSON.call(this); return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e } }), Lr.prototype = Object.assign(Object.create(Fi.prototype), { constructor: Lr, load: function(e, t, n, i) { var r = this,
                        a = new Gi(r.manager);
                    a.setPath(r.path), a.load(e, function(n) { try { t(r.parse(JSON.parse(n))) } catch (t) { i ? i(t) : console.error(t), r.manager.itemError(e) } }, n, i) }, parse: function(e) { var t = e.isInstancedBufferGeometry ? new Er : new G,
                        n = e.data.index; if (void 0 !== n) { var i = new Fc[n.type](n.array);
                        t.setIndex(new L(i, 1)) } for (var r in n = e.data.attributes) { var a = n[r];
                        i = new Fc[a.type](a.array), i = new(a.isInstancedBufferAttribute ? Ar : L)(i, a.itemSize, a.normalized), void 0 !== a.name && (i.name = a.name), t.setAttribute(r, i) } var o = e.data.morphAttributes; if (o)
                        for (r in o) { var s = o[r],
                                c = [];
                            n = 0; for (var h = s.length; n < h; n++) a = s[n], i = new L(i = new Fc[a.type](a.array), a.itemSize, a.normalized), void 0 !== a.name && (i.name = a.name), c.push(i);
                            t.morphAttributes[r] = c }
                    if (e.data.morphTargetsRelative && (t.morphTargetsRelative = !0), void 0 !== (r = e.data.groups || e.data.drawcalls || e.data.offsets))
                        for (n = 0, a = r.length; n !== a; ++n) i = r[n], t.addGroup(i.start, i.count, i.materialIndex); return void 0 !== (n = e.data.boundingSphere) && (r = new l, void 0 !== n.center && r.fromArray(n.center), t.boundingSphere = new v(r, n.radius)), e.name && (t.name = e.name), e.userData && (t.userData = e.userData), t } }); var Fc = { Int8Array: Int8Array, Uint8Array: Uint8Array, Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array };
            Rr.prototype = Object.assign(Object.create(Fi.prototype), { constructor: Rr, load: function(e, t, n, i) { var r = this,
                        a = "" === this.path ? Uc.extractUrlBase(e) : this.path;
                    this.resourcePath = this.resourcePath || a, (a = new Gi(r.manager)).setPath(this.path), a.load(e, function(n) { var a = null; try { a = JSON.parse(n) } catch (t) { return void 0 !== i && i(t), void console.error("THREE:ObjectLoader: Can't parse " + e + ".", t.message) } void 0 === (n = a.metadata) || void 0 === n.type || "geometry" === n.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " + e) : r.parse(a, t) }, n, i) }, parse: function(e, t) { var n = this.parseShape(e.shapes);
                    n = this.parseGeometries(e.geometries, n); var i = this.parseImages(e.images, function() { void 0 !== t && t(r) });
                    i = this.parseTextures(e.textures, i), i = this.parseMaterials(e.materials, i); var r = this.parseObject(e.object, n, i); return e.animations && (r.animations = this.parseAnimations(e.animations)), void 0 !== e.images && 0 !== e.images.length || void 0 === t || t(r), r }, parseShape: function(e) { var t = {}; if (void 0 !== e)
                        for (var n = 0, i = e.length; n < i; n++) { var r = (new hr).fromJSON(e[n]);
                            t[r.uuid] = r }
                    return t }, parseGeometries: function(e, t) { var n = {}; if (void 0 !== e)
                        for (var i = new Lr, r = 0, a = e.length; r < a; r++) { var o = e[r]; switch (o.type) {
                                case "PlaneGeometry":
                                case "PlaneBufferGeometry":
                                    var s = new Ac[o.type](o.width, o.height, o.widthSegments, o.heightSegments); break;
                                case "BoxGeometry":
                                case "BoxBufferGeometry":
                                case "CubeGeometry":
                                    s = new Ac[o.type](o.width, o.height, o.depth, o.widthSegments, o.heightSegments, o.depthSegments); break;
                                case "CircleGeometry":
                                case "CircleBufferGeometry":
                                    s = new Ac[o.type](o.radius, o.segments, o.thetaStart, o.thetaLength); break;
                                case "CylinderGeometry":
                                case "CylinderBufferGeometry":
                                    s = new Ac[o.type](o.radiusTop, o.radiusBottom, o.height, o.radialSegments, o.heightSegments, o.openEnded, o.thetaStart, o.thetaLength); break;
                                case "ConeGeometry":
                                case "ConeBufferGeometry":
                                    s = new Ac[o.type](o.radius, o.height, o.radialSegments, o.heightSegments, o.openEnded, o.thetaStart, o.thetaLength); break;
                                case "SphereGeometry":
                                case "SphereBufferGeometry":
                                    s = new Ac[o.type](o.radius, o.widthSegments, o.heightSegments, o.phiStart, o.phiLength, o.thetaStart, o.thetaLength); break;
                                case "DodecahedronGeometry":
                                case "DodecahedronBufferGeometry":
                                case "IcosahedronGeometry":
                                case "IcosahedronBufferGeometry":
                                case "OctahedronGeometry":
                                case "OctahedronBufferGeometry":
                                case "TetrahedronGeometry":
                                case "TetrahedronBufferGeometry":
                                    s = new Ac[o.type](o.radius, o.detail); break;
                                case "RingGeometry":
                                case "RingBufferGeometry":
                                    s = new Ac[o.type](o.innerRadius, o.outerRadius, o.thetaSegments, o.phiSegments, o.thetaStart, o.thetaLength); break;
                                case "TorusGeometry":
                                case "TorusBufferGeometry":
                                    s = new Ac[o.type](o.radius, o.tube, o.radialSegments, o.tubularSegments, o.arc); break;
                                case "TorusKnotGeometry":
                                case "TorusKnotBufferGeometry":
                                    s = new Ac[o.type](o.radius, o.tube, o.tubularSegments, o.radialSegments, o.p, o.q); break;
                                case "TubeGeometry":
                                case "TubeBufferGeometry":
                                    s = new Ac[o.type]((new zc[o.path.type]).fromJSON(o.path), o.tubularSegments, o.radius, o.radialSegments, o.closed); break;
                                case "LatheGeometry":
                                case "LatheBufferGeometry":
                                    s = new Ac[o.type](o.points, o.segments, o.phiStart, o.phiLength); break;
                                case "PolyhedronGeometry":
                                case "PolyhedronBufferGeometry":
                                    s = new Ac[o.type](o.vertices, o.indices, o.radius, o.details); break;
                                case "ShapeGeometry":
                                case "ShapeBufferGeometry":
                                    s = []; for (var c = 0, l = o.shapes.length; c < l; c++) { var h = t[o.shapes[c]];
                                        s.push(h) } s = new Ac[o.type](s, o.curveSegments); break;
                                case "ExtrudeGeometry":
                                case "ExtrudeBufferGeometry":
                                    for (s = [], c = 0, l = o.shapes.length; c < l; c++) h = t[o.shapes[c]], s.push(h);
                                    void 0 !== (c = o.options.extrudePath) && (o.options.extrudePath = (new zc[c.type]).fromJSON(c)), s = new Ac[o.type](s, o.options); break;
                                case "BufferGeometry":
                                case "InstancedBufferGeometry":
                                    s = i.parse(o); break;
                                case "Geometry":
                                    console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.'); break;
                                default:
                                    console.warn('THREE.ObjectLoader: Unsupported geometry type "' + o.type + '"'); continue } s.uuid = o.uuid, void 0 !== o.name && (s.name = o.name), !0 === s.isBufferGeometry && void 0 !== o.userData && (s.userData = o.userData), n[o.uuid] = s }
                    return n }, parseMaterials: function(e, t) { var n = {},
                        i = {}; if (void 0 !== e) { var r = new Tr;
                        r.setTextures(t), t = 0; for (var a = e.length; t < a; t++) { var o = e[t]; if ("MultiMaterial" === o.type) { for (var s = [], c = 0; c < o.materials.length; c++) { var l = o.materials[c];
                                    void 0 === n[l.uuid] && (n[l.uuid] = r.parse(l)), s.push(n[l.uuid]) } i[o.uuid] = s } else void 0 === n[o.uuid] && (n[o.uuid] = r.parse(o)), i[o.uuid] = n[o.uuid] } } return i }, parseAnimations: function(e) { for (var t = [], n = 0; n < e.length; n++) { var i = e[n],
                            r = Bi.parse(i);
                        void 0 !== i.uuid && (r.uuid = i.uuid), t.push(r) } return t }, parseImages: function(e, t) {
                    function n(e) { return i.manager.itemStart(e), a.load(e, function() { i.manager.itemEnd(e) }, void 0, function() { i.manager.itemError(e), i.manager.itemEnd(e) }) } var i = this,
                        r = {}; if (void 0 !== e && 0 < e.length) { var a = new ji(t = new Ui(t));
                        a.setCrossOrigin(this.crossOrigin), t = 0; for (var o = e.length; t < o; t++) { var s = e[t],
                                c = s.url; if (Array.isArray(c)) { r[s.uuid] = []; for (var l = 0, h = c.length; l < h; l++) { var u = c[l];
                                    u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : i.resourcePath + u, r[s.uuid].push(n(u)) } } else u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(s.url) ? s.url : i.resourcePath + s.url, r[s.uuid] = n(u) } } return r }, parseTextures: function(e, t) {
                    function n(e, t) { return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e]) } var i = {}; if (void 0 !== e)
                        for (var a = 0, o = e.length; a < o; a++) { var s = e[a];
                            void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === t[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image); var c = Array.isArray(t[s.image]) ? new me(t[s.image]) : new r(t[s.image]);
                            c.needsUpdate = !0, c.uuid = s.uuid, void 0 !== s.name && (c.name = s.name), void 0 !== s.mapping && (c.mapping = n(s.mapping, Gc)), void 0 !== s.offset && c.offset.fromArray(s.offset), void 0 !== s.repeat && c.repeat.fromArray(s.repeat), void 0 !== s.center && c.center.fromArray(s.center), void 0 !== s.rotation && (c.rotation = s.rotation), void 0 !== s.wrap && (c.wrapS = n(s.wrap[0], Hc), c.wrapT = n(s.wrap[1], Hc)), void 0 !== s.format && (c.format = s.format), void 0 !== s.type && (c.type = s.type), void 0 !== s.encoding && (c.encoding = s.encoding), void 0 !== s.minFilter && (c.minFilter = n(s.minFilter, kc)), void 0 !== s.magFilter && (c.magFilter = n(s.magFilter, kc)), void 0 !== s.anisotropy && (c.anisotropy = s.anisotropy), void 0 !== s.flipY && (c.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (c.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (c.unpackAlignment = s.unpackAlignment), i[s.uuid] = c }
                    return i }, parseObject: function(e, t, n) {
                    function i(e) { return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e] }

                    function r(e) { if (void 0 !== e) { if (Array.isArray(e)) { for (var t = [], i = 0, r = e.length; i < r; i++) { var a = e[i];
                                    void 0 === n[a] && console.warn("THREE.ObjectLoader: Undefined material", a), t.push(n[a]) } return t } return void 0 === n[e] && console.warn("THREE.ObjectLoader: Undefined material", e), n[e] } } switch (e.type) {
                        case "Scene":
                            var a = new f;
                            void 0 !== e.background && Number.isInteger(e.background) && (a.background = new b(e.background)), void 0 !== e.fog && ("Fog" === e.fog.type ? a.fog = new Ft(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (a.fog = new Ut(e.fog.color, e.fog.density))); break;
                        case "PerspectiveCamera":
                            a = new Z(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (a.focus = e.focus), void 0 !== e.zoom && (a.zoom = e.zoom), void 0 !== e.filmGauge && (a.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (a.filmOffset = e.filmOffset), void 0 !== e.view && (a.view = Object.assign({}, e.view)); break;
                        case "OrthographicCamera":
                            a = new yr(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (a.zoom = e.zoom), void 0 !== e.view && (a.view = Object.assign({}, e.view)); break;
                        case "AmbientLight":
                            a = new br(e.color, e.intensity); break;
                        case "DirectionalLight":
                            a = new _r(e.color, e.intensity); break;
                        case "PointLight":
                            a = new vr(e.color, e.intensity, e.distance, e.decay); break;
                        case "RectAreaLight":
                            a = new wr(e.color, e.intensity, e.width, e.height); break;
                        case "SpotLight":
                            a = new mr(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay); break;
                        case "HemisphereLight":
                            a = new pr(e.color, e.groundColor, e.intensity); break;
                        case "LightProbe":
                            a = (new Sr).fromJSON(e); break;
                        case "SkinnedMesh":
                            console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                        case "Mesh":
                            a = i(e.geometry); var o = r(e.material);
                            a = new H(a, o); break;
                        case "InstancedMesh":
                            a = i(e.geometry), o = r(e.material); var s = e.instanceMatrix;
                            (a = new Zt(a, o, e.count)).instanceMatrix = new L(new Float32Array(s.array), 16); break;
                        case "LOD":
                            a = new Wt; break;
                        case "Line":
                            a = new Qt(i(e.geometry), r(e.material), e.mode); break;
                        case "LineLoop":
                            a = new $t(i(e.geometry), r(e.material)); break;
                        case "LineSegments":
                            a = new Kt(i(e.geometry), r(e.material)); break;
                        case "PointCloud":
                        case "Points":
                            a = new tn(i(e.geometry), r(e.material)); break;
                        case "Sprite":
                            a = new Vt(r(e.material)); break;
                        case "Group":
                            a = new Dt; break;
                        default:
                            a = new d } if (a.uuid = e.uuid, void 0 !== e.name && (a.name = e.name), void 0 !== e.matrix ? (a.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (a.matrixAutoUpdate = e.matrixAutoUpdate), a.matrixAutoUpdate && a.matrix.decompose(a.position, a.quaternion, a.scale)) : (void 0 !== e.position && a.position.fromArray(e.position), void 0 !== e.rotation && a.rotation.fromArray(e.rotation), void 0 !== e.quaternion && a.quaternion.fromArray(e.quaternion), void 0 !== e.scale && a.scale.fromArray(e.scale)), void 0 !== e.castShadow && (a.castShadow = e.castShadow), void 0 !== e.receiveShadow && (a.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (a.shadow.bias = e.shadow.bias), void 0 !== e.shadow.radius && (a.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && a.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (a.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (a.visible = e.visible), void 0 !== e.frustumCulled && (a.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (a.renderOrder = e.renderOrder), void 0 !== e.userData && (a.userData = e.userData), void 0 !== e.layers && (a.layers.mask = e.layers), void 0 !== e.children)
                        for (s = e.children, o = 0; o < s.length; o++) a.add(this.parseObject(s[o], t, n)); if ("LOD" === e.type)
                        for (void 0 !== e.autoUpdate && (a.autoUpdate = e.autoUpdate), e = e.levels, s = 0; s < e.length; s++) { o = e[s]; var c = a.getObjectByProperty("uuid", o.object);
                            void 0 !== c && a.addLevel(c, o.distance) }
                    return a } }); var Gc = { UVMapping: 300, CubeReflectionMapping: 301, CubeRefractionMapping: 302, EquirectangularReflectionMapping: 303, EquirectangularRefractionMapping: 304, SphericalReflectionMapping: 305, CubeUVReflectionMapping: 306, CubeUVRefractionMapping: 307 },
                Hc = { RepeatWrapping: 1e3, ClampToEdgeWrapping: 1001, MirroredRepeatWrapping: 1002 },
                kc = { NearestFilter: 1003, NearestMipmapNearestFilter: 1004, NearestMipmapLinearFilter: 1005, LinearFilter: 1006, LinearMipmapNearestFilter: 1007, LinearMipmapLinearFilter: 1008 };
            Pr.prototype = Object.assign(Object.create(Fi.prototype), { constructor: Pr, setOptions: function(e) { return this.options = e, this }, load: function(e, t, n, i) { void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); var r = this,
                        a = Pc.get(e); if (void 0 !== a) return r.manager.itemStart(e), setTimeout(function() { t && t(a), r.manager.itemEnd(e) }, 0), a;
                    fetch(e).then(function(e) { return e.blob() }).then(function(e) { return void 0 === r.options ? createImageBitmap(e) : createImageBitmap(e, r.options) }).then(function(n) { Pc.add(e, n), t && t(n), r.manager.itemEnd(e) }).catch(function(t) { i && i(t), r.manager.itemError(e), r.manager.itemEnd(e) }), r.manager.itemStart(e) } }), Object.assign(Cr.prototype, { moveTo: function(e, t) { return this.currentPath = new lr, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this }, lineTo: function(e, t) { return this.currentPath.lineTo(e, t), this }, quadraticCurveTo: function(e, t, n, i) { return this.currentPath.quadraticCurveTo(e, t, n, i), this }, bezierCurveTo: function(e, t, n, i, r, a) { return this.currentPath.bezierCurveTo(e, t, n, i, r, a), this }, splineThru: function(e) { return this.currentPath.splineThru(e), this }, toShapes: function(e, t) {
                    function n(e) { for (var t = [], n = 0, i = e.length; n < i; n++) { var r = e[n],
                                a = new hr;
                            a.curves = r.curves, t.push(a) } return t }

                    function i(e, t) { for (var n = t.length, i = !1, r = n - 1, a = 0; a < n; r = a++) { var o = t[r],
                                s = t[a],
                                c = s.x - o.x,
                                l = s.y - o.y; if (Math.abs(l) > Number.EPSILON) { if (0 > l && (o = t[a], c = -c, s = t[r], l = -l), !(e.y < o.y || e.y > s.y))
                                    if (e.y === o.y) { if (e.x === o.x) return !0 } else { if (0 === (r = l * (e.x - o.x) - c * (e.y - o.y))) return !0;
                                        0 > r || (i = !i) } } else if (e.y === o.y && (s.x <= e.x && e.x <= o.x || o.x <= e.x && e.x <= s.x)) return !0 } return i } var r = Tc.isClockWise,
                        a = this.subPaths; if (0 === a.length) return []; if (!0 === t) return n(a); if (t = [], 1 === a.length) { var o = a[0],
                            s = new hr; return s.curves = o.curves, t.push(s), t } var c = !r(a[0].getPoints());
                    c = e ? !c : c, s = []; var l = [],
                        h = [],
                        u = 0;
                    l[u] = void 0, h[u] = []; for (var p = 0, d = a.length; p < d; p++) { var f = (o = a[p]).getPoints(),
                            m = r(f);
                        (m = e ? !m : m) ? (!c && l[u] && u++, l[u] = { s: new hr, p: f }, l[u].s.curves = o.curves, c && u++, h[u] = []) : h[u].push({ h: o, p: f[0] }) } if (!l[0]) return n(a); if (1 < l.length) { for (p = !1, e = [], r = 0, a = l.length; r < a; r++) s[r] = []; for (r = 0, a = l.length; r < a; r++)
                            for (o = h[r], m = 0; m < o.length; m++) { for (c = o[m], u = !0, f = 0; f < l.length; f++) i(c.p, l[f].p) && (r !== f && e.push({ froms: r, tos: f, hole: m }), u ? (u = !1, s[f].push(c)) : p = !0);
                                u && s[r].push(c) } 0 < e.length && (p || (h = s)) } for (p = 0, r = l.length; p < r; p++)
                        for (s = l[p].s, t.push(s), a = 0, o = (e = h[p]).length; a < o; a++) s.holes.push(e[a].h); return t } }), Object.assign(Or.prototype, { isFont: !0, generateShapes: function(e, t) { void 0 === t && (t = 100); var n = [],
                        i = t;
                    t = this.data; var r = Array.from ? Array.from(e) : String(e).split("");
                    i /= t.resolution; var a = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * i;
                    e = []; for (var o = 0, s = 0, c = 0; c < r.length; c++) { var l = r[c]; if ("\n" === l) o = 0, s -= a;
                        else { var h = l;
                            l = i; var u = o,
                                p = s,
                                d = t,
                                f = d.glyphs[h] || d.glyphs["?"]; if (f) { if (h = new Cr, f.o)
                                    for (var m = 0, g = (d = f._cachedOutline || (f._cachedOutline = f.o.split(" "))).length; m < g;) switch (d[m++]) {
                                        case "m":
                                            var v = d[m++] * l + u,
                                                y = d[m++] * l + p;
                                            h.moveTo(v, y); break;
                                        case "l":
                                            v = d[m++] * l + u, y = d[m++] * l + p, h.lineTo(v, y); break;
                                        case "q":
                                            var x = d[m++] * l + u,
                                                _ = d[m++] * l + p,
                                                b = d[m++] * l + u,
                                                w = d[m++] * l + p;
                                            h.quadraticCurveTo(b, w, x, _); break;
                                        case "b":
                                            x = d[m++] * l + u, _ = d[m++] * l + p, b = d[m++] * l + u, w = d[m++] * l + p, v = d[m++] * l + u, y = d[m++] * l + p, h.bezierCurveTo(b, w, v, y, x, _) } l = { offsetX: f.ha * l, path: h } } else console.error('THREE.Font: character "' + h + '" does not exists in font family ' + d.familyName + "."), l = void 0;
                            o += l.offsetX, e.push(l.path) } } for (t = 0, r = e.length; t < r; t++) Array.prototype.push.apply(n, e[t].toShapes()); return n } }), Dr.prototype = Object.assign(Object.create(Fi.prototype), { constructor: Dr, load: function(e, t, n, i) { var r = this,
                        a = new Gi(this.manager);
                    a.setPath(this.path), a.load(e, function(e) { try { var n = JSON.parse(e) } catch (t) { console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(e.substring(65, e.length - 2)) } e = r.parse(n), t && t(e) }, n, i) }, parse: function(e) { return new Or(e) } }); var Vc, jc = { getContext: function() { return void 0 === Vc && (Vc = new(window.AudioContext || window.webkitAudioContext)), Vc }, setContext: function(e) { Vc = e } };
            Ir.prototype = Object.assign(Object.create(Fi.prototype), { constructor: Ir, load: function(e, t, n, i) { var r = this,
                        a = new Gi(r.manager);
                    a.setResponseType("arraybuffer"), a.setPath(r.path), a.load(e, function(n) { try { var a = n.slice(0);
                            jc.getContext().decodeAudioData(a, function(e) { t(e) }) } catch (t) { i ? i(t) : console.error(t), r.manager.itemError(e) } }, n, i) } }), Nr.prototype = Object.assign(Object.create(Sr.prototype), { constructor: Nr, isHemisphereLightProbe: !0, copy: function(e) { return Sr.prototype.copy.call(this, e), this }, toJSON: function(e) { return Sr.prototype.toJSON.call(this, e) } }), Br.prototype = Object.assign(Object.create(Sr.prototype), { constructor: Br, isAmbientLightProbe: !0, copy: function(e) { return Sr.prototype.copy.call(this, e), this }, toJSON: function(e) { return Sr.prototype.toJSON.call(this, e) } }); var Wc = new h,
                qc = new h;
            Object.assign(zr.prototype, { update: function(e) { var t = this._cache; if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) { t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep; var n = e.projectionMatrix.clone(),
                            i = t.eyeSep / 2,
                            r = i * t.near / t.focus,
                            a = t.near * Math.tan(Ra.DEG2RAD * t.fov * .5) / t.zoom;
                        qc.elements[12] = -i, Wc.elements[12] = i, i = -a * t.aspect + r; var o = a * t.aspect + r;
                        n.elements[0] = 2 * t.near / (o - i), n.elements[8] = (o + i) / (o - i), this.cameraL.projectionMatrix.copy(n), i = -a * t.aspect - r, o = a * t.aspect - r, n.elements[0] = 2 * t.near / (o - i), n.elements[8] = (o + i) / (o - i), this.cameraR.projectionMatrix.copy(n) } this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(qc), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Wc) } }), Object.assign(Ur.prototype, { start: function() { this.oldTime = this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.elapsedTime = 0, this.running = !0 }, stop: function() { this.getElapsedTime(), this.autoStart = this.running = !1 }, getElapsedTime: function() { return this.getDelta(), this.elapsedTime }, getDelta: function() { var e = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { var t = ("undefined" == typeof performance ? Date : performance).now();
                        e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e } return e } }); var Xc = new l,
                Yc = new c,
                Zc = new l,
                Jc = new l;
            Fr.prototype = Object.assign(Object.create(d.prototype), { constructor: Fr, getInput: function() { return this.gain }, removeFilter: function() { return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this }, getFilter: function() { return this.filter }, setFilter: function(e) { return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this }, getMasterVolume: function() { return this.gain.gain.value }, setMasterVolume: function(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this }, updateMatrixWorld: function(e) { d.prototype.updateMatrixWorld.call(this, e), e = this.context.listener; var t = this.up; if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Xc, Yc, Zc), Jc.set(0, 0, -1).applyQuaternion(Yc), e.positionX) { var n = this.context.currentTime + this.timeDelta;
                        e.positionX.linearRampToValueAtTime(Xc.x, n), e.positionY.linearRampToValueAtTime(Xc.y, n), e.positionZ.linearRampToValueAtTime(Xc.z, n), e.forwardX.linearRampToValueAtTime(Jc.x, n), e.forwardY.linearRampToValueAtTime(Jc.y, n), e.forwardZ.linearRampToValueAtTime(Jc.z, n), e.upX.linearRampToValueAtTime(t.x, n), e.upY.linearRampToValueAtTime(t.y, n), e.upZ.linearRampToValueAtTime(t.z, n) } else e.setPosition(Xc.x, Xc.y, Xc.z), e.setOrientation(Jc.x, Jc.y, Jc.z, t.x, t.y, t.z) } }), Gr.prototype = Object.assign(Object.create(d.prototype), { constructor: Gr, getOutput: function() { return this.gain }, setNodeSource: function(e) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this }, setMediaElementSource: function(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this }, setMediaStreamSource: function(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this }, setBuffer: function(e) { return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this }, play: function(e) { if (void 0 === e && (e = 0), !0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing.");
                    else { if (!1 !== this.hasPlaybackControl) return this._startedAt = this.context.currentTime + e, (e = this.context.createBufferSource()).buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
                        console.warn("THREE.Audio: this Audio has no playback control.") } }, pause: function() { if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress %= this.duration || this.buffer.duration), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                    console.warn("THREE.Audio: this Audio has no playback control.") }, stop: function() { if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
                    console.warn("THREE.Audio: this Audio has no playback control.") }, connect: function() { if (0 < this.filters.length) { this.source.connect(this.filters[0]); for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                        this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this }, disconnect: function() { if (0 < this.filters.length) { this.source.disconnect(this.filters[0]); for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this }, getFilters: function() { return this.filters }, setFilters: function(e) { return e || (e = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = e, this.connect()) : this.filters = e, this }, setDetune: function(e) { if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this }, getDetune: function() { return this.detune }, getFilter: function() { return this.getFilters()[0] }, setFilter: function(e) { return this.setFilters(e ? [e] : []) }, setPlaybackRate: function(e) { if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                    console.warn("THREE.Audio: this Audio has no playback control.") }, getPlaybackRate: function() { return this.playbackRate }, onEnded: function() { this.isPlaying = !1 }, getLoop: function() { return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop }, setLoop: function(e) { if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                    console.warn("THREE.Audio: this Audio has no playback control.") }, setLoopStart: function(e) { return this.loopStart = e, this }, setLoopEnd: function(e) { return this.loopEnd = e, this }, getVolume: function() { return this.gain.gain.value }, setVolume: function(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } }); var Qc = new l,
                Kc = new c,
                $c = new l,
                el = new l;
            Hr.prototype = Object.assign(Object.create(Gr.prototype), { constructor: Hr, getOutput: function() { return this.panner }, getRefDistance: function() { return this.panner.refDistance }, setRefDistance: function(e) { return this.panner.refDistance = e, this }, getRolloffFactor: function() { return this.panner.rolloffFactor }, setRolloffFactor: function(e) { return this.panner.rolloffFactor = e, this }, getDistanceModel: function() { return this.panner.distanceModel }, setDistanceModel: function(e) { return this.panner.distanceModel = e, this }, getMaxDistance: function() { return this.panner.maxDistance }, setMaxDistance: function(e) { return this.panner.maxDistance = e, this }, setDirectionalCone: function(e, t, n) { return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this }, updateMatrixWorld: function(e) { if (d.prototype.updateMatrixWorld.call(this, e), !0 !== this.hasPlaybackControl || !1 !== this.isPlaying)
                        if (this.matrixWorld.decompose(Qc, Kc, $c), el.set(0, 0, 1).applyQuaternion(Kc), (e = this.panner).positionX) { var t = this.context.currentTime + this.listener.timeDelta;
                            e.positionX.linearRampToValueAtTime(Qc.x, t), e.positionY.linearRampToValueAtTime(Qc.y, t), e.positionZ.linearRampToValueAtTime(Qc.z, t), e.orientationX.linearRampToValueAtTime(el.x, t), e.orientationY.linearRampToValueAtTime(el.y, t), e.orientationZ.linearRampToValueAtTime(el.z, t) } else e.setPosition(Qc.x, Qc.y, Qc.z), e.setOrientation(el.x, el.y, el.z) } }), Object.assign(kr.prototype, { getFrequencyData: function() { return this.analyser.getByteFrequencyData(this.data), this.data }, getAverageFrequency: function() { for (var e = 0, t = this.getFrequencyData(), n = 0; n < t.length; n++) e += t[n]; return e / t.length } }), Object.assign(Vr.prototype, { accumulate: function(e, t) { var n = this.buffer,
                        i = this.valueSize;
                    e = e * i + i; var r = this.cumulativeWeight; if (0 === r) { for (r = 0; r !== i; ++r) n[e + r] = n[r];
                        r = t } else r += t, this._mixBufferRegion(n, e, 0, t / r, i);
                    this.cumulativeWeight = r }, accumulateAdditive: function(e) { var t = this.buffer,
                        n = this.valueSize,
                        i = n * this._addIndex;
                    0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, i, 0, e, n), this.cumulativeWeightAdditive += e }, apply: function(e) { var t = this.valueSize,
                        n = this.buffer;
                    e = e * t + t; var i = this.cumulativeWeight,
                        r = this.cumulativeWeightAdditive,
                        a = this.binding; for (this.cumulativeWeightAdditive = this.cumulativeWeight = 0, 1 > i && this._mixBufferRegion(n, e, t * this._origIndex, 1 - i, t), 0 < r && this._mixBufferRegionAdditive(n, e, this._addIndex * t, 1, t), i = t, r = t + t; i !== r; ++i)
                        if (n[i] !== n[i + t]) { a.setValue(n, e); break } }, saveOriginalState: function() { var e = this.buffer,
                        t = this.valueSize,
                        n = t * this._origIndex;
                    this.binding.getValue(e, n); for (var i = t; i !== n; ++i) e[i] = e[n + i % t];
                    this._setIdentity(), this.cumulativeWeightAdditive = this.cumulativeWeight = 0 }, restoreOriginalState: function() { this.binding.setValue(this.buffer, 3 * this.valueSize) }, _setAdditiveIdentityNumeric: function() { for (var e = this._addIndex * this.valueSize, t = e + this.valueSize; e < t; e++) this.buffer[e] = 0 }, _setAdditiveIdentityQuaternion: function() { this._setAdditiveIdentityNumeric(), this.buffer[4 * this._addIndex + 3] = 1 }, _setAdditiveIdentityOther: function() { for (var e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize, n = 0; n < this.valueSize; n++) this.buffer[t + n] = this.buffer[e + n] }, _select: function(e, t, n, i, r) { if (.5 <= i)
                        for (i = 0; i !== r; ++i) e[t + i] = e[n + i] }, _slerp: function(e, t, n, i) { c.slerpFlat(e, t, e, t, e, n, i) }, _slerpAdditive: function(e, t, n, i, r) { r *= this._workIndex, c.multiplyQuaternionsFlat(e, r, e, t, e, n), c.slerpFlat(e, t, e, t, e, r, i) }, _lerp: function(e, t, n, i, r) { for (var a = 1 - i, o = 0; o !== r; ++o) { var s = t + o;
                        e[s] = e[s] * a + e[n + o] * i } }, _lerpAdditive: function(e, t, n, i, r) { for (var a = 0; a !== r; ++a) { e[t + a] += e[n + a] * i } } }); var tl = /[\[\]\.:\/]/g,
                nl = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
                il = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                rl = /(WCOD+)?/.source.replace("WCOD", nl),
                al = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                ol = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                sl = new RegExp("^" + il + rl + al + ol + "$"),
                cl = ["material", "materials", "bones"];
            Object.assign(jr.prototype, { getValue: function(e, t) { this.bind(); var n = this._bindings[this._targetGroup.nCachedObjects_];
                    void 0 !== n && n.getValue(e, t) }, setValue: function(e, t) { for (var n = this._bindings, i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(e, t) }, bind: function() { for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind() }, unbind: function() { for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind() } }), Object.assign(Wr, { Composite: jr, create: function(e, t, n) { return e && e.isAnimationObjectGroup ? new Wr.Composite(e, t, n) : new Wr(e, t, n) }, sanitizeNodeName: function(e) { return e.replace(/\s/g, "_").replace(tl, "") }, parseTrackName: function(e) { var t = sl.exec(e); if (!t) throw Error("PropertyBinding: Cannot parse trackName: " + e); var n = (t = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] }).nodeName && t.nodeName.lastIndexOf("."); if (void 0 !== n && -1 !== n) { var i = t.nodeName.substring(n + 1); - 1 !== cl.indexOf(i) && (t.nodeName = t.nodeName.substring(0, n), t.objectName = i) } if (null === t.propertyName || 0 === t.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + e); return t }, findNode: function(e, t) { if (!t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e; if (e.skeleton) { var n = e.skeleton.getBoneByName(t); if (void 0 !== n) return n } if (e.children) { var i = function(e) { for (var n = 0; n < e.length; n++) { var r = e[n]; if (r.name === t || r.uuid === t || (r = i(r.children))) return r } return null }; if (e = i(e.children)) return e } return null } }), Object.assign(Wr.prototype, { _getValue_unavailable: function() {}, _setValue_unavailable: function() {}, BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, GetterByBindingType: [function(e, t) { e[t] = this.node[this.propertyName] }, function(e, t) { for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) e[t++] = n[i] }, function(e, t) { e[t] = this.resolvedProperty[this.propertyIndex] }, function(e, t) { this.resolvedProperty.toArray(e, t) }], SetterByBindingTypeAndVersioning: [
                    [function(e, t) { this.targetObject[this.propertyName] = e[t] }, function(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0 }, function(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 }],
                    [function(e, t) { for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = e[t++] }, function(e, t) { for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
                        this.targetObject.needsUpdate = !0 }, function(e, t) { for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
                        this.targetObject.matrixWorldNeedsUpdate = !0 }],
                    [function(e, t) { this.resolvedProperty[this.propertyIndex] = e[t] }, function(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0 }, function(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 }],
                    [function(e, t) { this.resolvedProperty.fromArray(e, t) }, function(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0 }, function(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0 }]
                ], getValue: function(e, t) { this.bind(), this.getValue(e, t) }, setValue: function(e, t) { this.bind(), this.setValue(e, t) }, bind: function() { var e = this.node,
                        t = this.parsedPath,
                        n = t.objectName,
                        i = t.propertyName,
                        r = t.propertyIndex; if (e || (this.node = e = Wr.findNode(this.rootNode, t.nodeName) || this.rootNode), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, e) { if (n) { var a = t.objectIndex; switch (n) {
                                case "materials":
                                    if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                    e = e.material.materials; break;
                                case "bones":
                                    if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); for (e = e.skeleton.bones, n = 0; n < e.length; n++)
                                        if (e[n].name === a) { a = n; break } break;
                                default:
                                    if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                    e = e[n] } if (void 0 !== a) { if (void 0 === e[a]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                                e = e[a] } } if (void 0 === (a = e[i])) console.error("THREE.PropertyBinding: Trying to update property for track: " + t.nodeName + "." + i + " but it wasn't found.", e);
                        else { if (t = this.Versioning.None, this.targetObject = e, void 0 !== e.needsUpdate ? t = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (t = this.Versioning.MatrixWorldNeedsUpdate), n = this.BindingType.Direct, void 0 !== r) { if ("morphTargetInfluences" === i) { if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); if (!e.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this); if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                    void 0 !== e.morphTargetDictionary[r] && (r = e.morphTargetDictionary[r]) } n = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = r } else void 0 !== a.fromArray && void 0 !== a.toArray ? (n = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (n = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = i;
                            this.getValue = this.GetterByBindingType[n], this.setValue = this.SetterByBindingTypeAndVersioning[n][t] } } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.") }, unbind: function() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } }), Object.assign(Wr.prototype, { _getValue_unbound: Wr.prototype.getValue, _setValue_unbound: Wr.prototype.setValue }), Object.assign(qr.prototype, { isAnimationObjectGroup: !0, add: function() { for (var e = this._objects, t = e.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._paths, a = this._parsedPaths, o = this._bindings, s = o.length, c = void 0, l = 0, h = arguments.length; l !== h; ++l) { var u = arguments[l],
                            p = u.uuid,
                            d = i[p]; if (void 0 === d) { d = t++, i[p] = d, e.push(u), p = 0; for (var f = s; p !== f; ++p) o[p].push(new Wr(u, r[p], a[p])) } else if (d < n) { c = e[d]; var m = --n; for (i[(f = e[m]).uuid] = d, e[d] = f, i[p] = m, e[m] = u, p = 0, f = s; p !== f; ++p) { var g = o[p],
                                    v = g[d];
                                g[d] = g[m], void 0 === v && (v = new Wr(u, r[p], a[p])), g[m] = v } } else e[d] !== c && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.") } this.nCachedObjects_ = n }, remove: function() { for (var e = this._objects, t = this.nCachedObjects_, n = this._indicesByUUID, i = this._bindings, r = i.length, a = 0, o = arguments.length; a !== o; ++a) { var s = arguments[a],
                            c = s.uuid,
                            l = n[c]; if (void 0 !== l && l >= t) { var h = t++,
                                u = e[h]; for (n[u.uuid] = l, e[l] = u, n[c] = h, e[h] = s, s = 0, c = r; s !== c; ++s) { var p = (u = i[s])[l];
                                u[l] = u[h], u[h] = p } } } this.nCachedObjects_ = t }, uncache: function() { for (var e = this._objects, t = e.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._bindings, a = r.length, o = 0, s = arguments.length; o !== s; ++o) { var c = arguments[o].uuid,
                            l = i[c]; if (void 0 !== l)
                            if (delete i[c], l < n) { var h = e[c = --n],
                                    u = --t,
                                    p = e[u]; for (i[h.uuid] = l, e[l] = h, i[p.uuid] = c, e[c] = p, e.pop(), h = 0, p = a; h !== p; ++h) { var d = r[h],
                                        f = d[u];
                                    d[l] = d[c], d[c] = f, d.pop() } } else
                                for (i[(p = e[u = --t]).uuid] = l, e[l] = p, e.pop(), h = 0, p = a; h !== p; ++h)(d = r[h])[l] = d[u], d.pop() } this.nCachedObjects_ = n }, subscribe_: function(e, t) { var n = this._bindingsIndicesByPath,
                        i = n[e],
                        r = this._bindings; if (void 0 !== i) return r[i]; var a = this._paths,
                        o = this._parsedPaths,
                        s = this._objects,
                        c = this.nCachedObjects_,
                        l = Array(s.length); for (i = r.length, n[e] = i, a.push(e), o.push(t), r.push(l), n = c, i = s.length; n !== i; ++n) l[n] = new Wr(s[n], e, t); return l }, unsubscribe_: function(e) { var t = this._bindingsIndicesByPath,
                        n = t[e]; if (void 0 !== n) { var i = this._paths,
                            r = this._parsedPaths,
                            a = this._bindings,
                            o = a.length - 1,
                            s = a[o];
                        t[e[o]] = n, a[n] = s, a.pop(), r[n] = r[o], r.pop(), i[n] = i[o], i.pop() } } }), Object.assign(Xr.prototype, { play: function() { return this._mixer._activateAction(this), this }, stop: function() { return this._mixer._deactivateAction(this), this.reset() }, reset: function() { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() }, isRunning: function() { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) }, isScheduled: function() { return this._mixer._isActiveAction(this) }, startAt: function(e) { return this._startTime = e, this }, setLoop: function(e, t) { return this.loop = e, this.repetitions = t, this }, setEffectiveWeight: function(e) { return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading() }, getEffectiveWeight: function() { return this._effectiveWeight }, fadeIn: function(e) { return this._scheduleFading(e, 0, 1) }, fadeOut: function(e) { return this._scheduleFading(e, 1, 0) }, crossFadeFrom: function(e, t, n) { if (e.fadeOut(t), this.fadeIn(t), n) { n = this._clip.duration; var i = e._clip.duration,
                            r = n / i;
                        e.warp(1, i / n, t), this.warp(r, 1, t) } return this }, crossFadeTo: function(e, t, n) { return e.crossFadeFrom(this, t, n) }, stopFading: function() { var e = this._weightInterpolant; return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this }, setEffectiveTimeScale: function(e) { return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping() }, getEffectiveTimeScale: function() { return this._effectiveTimeScale }, setDuration: function(e) { return this.timeScale = this._clip.duration / e, this.stopWarping() }, syncWith: function(e) { return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping() }, halt: function(e) { return this.warp(this._effectiveTimeScale, 0, e) }, warp: function(e, t, n) { var i = this._mixer,
                        r = i.time,
                        a = this._timeScaleInterpolant,
                        o = this.timeScale; return null === a && (this._timeScaleInterpolant = a = i._lendControlInterpolant()), i = a.parameterPositions, a = a.sampleValues, i[0] = r, i[1] = r + n, a[0] = e / o, a[1] = t / o, this }, stopWarping: function() { var e = this._timeScaleInterpolant; return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this }, getMixer: function() { return this._mixer }, getClip: function() { return this._clip }, getRoot: function() { return this._localRoot || this._mixer._root }, _update: function(e, t, n, i) { if (this.enabled) { var r = this._startTime; if (null !== r) { if (0 > (t = (e - r) * n) || 0 === n) return;
                            this._startTime = null, t *= n } if (t *= this._updateTimeScale(e), n = this._updateTime(t), 0 < (e = this._updateWeight(e))) switch (t = this._interpolants, r = this._propertyBindings, this.blendMode) {
                            case 2501:
                                for (var a = 0, o = t.length; a !== o; ++a) t[a].evaluate(n), r[a].accumulateAdditive(e); break;
                            default:
                                for (a = 0, o = t.length; a !== o; ++a) t[a].evaluate(n), r[a].accumulate(i, e) } } else this._updateWeight(e) }, _updateWeight: function(e) { var t = 0; if (this.enabled) { t = this.weight; var n = this._weightInterpolant; if (null !== n) { var i = n.evaluate(e)[0];
                            t *= i, e > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1)) } } return this._effectiveWeight = t }, _updateTimeScale: function(e) { var t = 0; if (!this.paused) { t = this.timeScale; var n = this._timeScaleInterpolant; if (null !== n) t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t) } return this._effectiveTimeScale = t }, _updateTime: function(e) { var t = this.time + e,
                        n = this._clip.duration,
                        i = this.loop,
                        r = this._loopCount,
                        a = 2202 === i; if (0 === e) return -1 === r ? t : a && 1 == (1 & r) ? n - t : t; if (2200 === i) e: { if (-1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1)), t >= n) t = n;
                        else { if (!(0 > t)) { this.time = t; break e } t = 0 } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = t, this._mixer.dispatchEvent({ type: "finished", action: this, direction: 0 > e ? -1 : 1 }) }
                    else { if (-1 === r && (0 <= e ? (r = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), t >= n || 0 > t) { t -= n * (i = Math.floor(t / n)), r += Math.abs(i); var o = this.repetitions - r;
                            0 >= o ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = t = 0 < e ? n : 0, this._mixer.dispatchEvent({ type: "finished", action: this, direction: 0 < e ? 1 : -1 })) : (1 === o ? (e = 0 > e, this._setEndings(e, !e, a)) : this._setEndings(!1, !1, a), this._loopCount = r, this.time = t, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: i })) } else this.time = t; if (a && 1 == (1 & r)) return n - t } return t }, _setEndings: function(e, t, n) { var i = this._interpolantSettings;
                    n ? (i.endingStart = 2401, i.endingEnd = 2401) : (i.endingStart = e ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, i.endingEnd = t ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402) }, _scheduleFading: function(e, t, n) { var i = this._mixer,
                        r = i.time,
                        a = this._weightInterpolant; return null === a && (this._weightInterpolant = a = i._lendControlInterpolant()), i = a.parameterPositions, a = a.sampleValues, i[0] = r, a[0] = t, i[1] = r + e, a[1] = n, this } }), Yr.prototype = Object.assign(Object.create(t.prototype), { constructor: Yr, _bindAction: function(e, t) { var n = e._localRoot || this._root,
                        i = e._clip.tracks,
                        r = i.length,
                        a = e._propertyBindings;
                    e = e._interpolants; var o = n.uuid,
                        s = this._bindingsByRootAndName,
                        c = s[o]; for (void 0 === c && (c = {}, s[o] = c), s = 0; s !== r; ++s) { var l = i[s],
                            h = l.name,
                            u = c[h]; if (void 0 === u) { if (void 0 !== (u = a[s])) { null === u._cacheIndex && (++u.referenceCount, this._addInactiveBinding(u, o, h)); continue }++(u = new Vr(Wr.create(n, h, t && t._propertyBindings[s].binding.parsedPath), l.ValueTypeName, l.getValueSize())).referenceCount, this._addInactiveBinding(u, o, h) } a[s] = u, e[s].resultBuffer = u.buffer } }, _activateAction: function(e) { if (!this._isActiveAction(e)) { if (null === e._cacheIndex) { var t = (e._localRoot || this._root).uuid,
                                n = e._clip.uuid,
                                i = this._actionsByClip[n];
                            this._bindAction(e, i && i.knownActions[0]), this._addInactiveAction(e, n, t) } for (n = 0, i = (t = e._propertyBindings).length; n !== i; ++n) { var r = t[n];
                            0 == r.useCount++ && (this._lendBinding(r), r.saveOriginalState()) } this._lendAction(e) } }, _deactivateAction: function(e) { if (this._isActiveAction(e)) { for (var t = e._propertyBindings, n = 0, i = t.length; n !== i; ++n) { var r = t[n];
                            0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r)) } this._takeBackAction(e) } }, _initMemoryManager: function() { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; var e = this;
                    this.stats = { actions: { get total() { return e._actions.length }, get inUse() { return e._nActiveActions } }, bindings: { get total() { return e._bindings.length }, get inUse() { return e._nActiveBindings } }, controlInterpolants: { get total() { return e._controlInterpolants.length }, get inUse() { return e._nActiveControlInterpolants } } } }, _isActiveAction: function(e) { return null !== (e = e._cacheIndex) && e < this._nActiveActions }, _addInactiveAction: function(e, t, n) { var i = this._actions,
                        r = this._actionsByClip,
                        a = r[t];
                    void 0 === a ? (a = { knownActions: [e], actionByRoot: {} }, e._byClipCacheIndex = 0, r[t] = a) : (t = a.knownActions, e._byClipCacheIndex = t.length, t.push(e)), e._cacheIndex = i.length, i.push(e), a.actionByRoot[n] = e }, _removeInactiveAction: function(e) { var t = this._actions,
                        n = t[t.length - 1],
                        i = e._cacheIndex;
                    n._cacheIndex = i, t[i] = n, t.pop(), e._cacheIndex = null, t = e._clip.uuid; var r = (i = (n = this._actionsByClip)[t]).knownActions,
                        a = r[r.length - 1],
                        o = e._byClipCacheIndex;
                    a._byClipCacheIndex = o, r[o] = a, r.pop(), e._byClipCacheIndex = null, delete i.actionByRoot[(e._localRoot || this._root).uuid], 0 === r.length && delete n[t], this._removeInactiveBindingsForAction(e) }, _removeInactiveBindingsForAction: function(e) { for (var t = 0, n = (e = e._propertyBindings).length; t !== n; ++t) { var i = e[t];
                        0 == --i.referenceCount && this._removeInactiveBinding(i) } }, _lendAction: function(e) { var t = this._actions,
                        n = e._cacheIndex,
                        i = this._nActiveActions++,
                        r = t[i];
                    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r }, _takeBackAction: function(e) { var t = this._actions,
                        n = e._cacheIndex,
                        i = --this._nActiveActions,
                        r = t[i];
                    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r }, _addInactiveBinding: function(e, t, n) { var i = this._bindingsByRootAndName,
                        r = i[t],
                        a = this._bindings;
                    void 0 === r && (r = {}, i[t] = r), r[n] = e, e._cacheIndex = a.length, a.push(e) }, _removeInactiveBinding: function(e) { var t = this._bindings,
                        n = e.binding,
                        i = n.rootNode.uuid;
                    n = n.path; var r = this._bindingsByRootAndName,
                        a = r[i],
                        o = t[t.length - 1];
                    e = e._cacheIndex, o._cacheIndex = e, t[e] = o, t.pop(), delete a[n], 0 === Object.keys(a).length && delete r[i] }, _lendBinding: function(e) { var t = this._bindings,
                        n = e._cacheIndex,
                        i = this._nActiveBindings++,
                        r = t[i];
                    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r }, _takeBackBinding: function(e) { var t = this._bindings,
                        n = e._cacheIndex,
                        i = --this._nActiveBindings,
                        r = t[i];
                    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r }, _lendControlInterpolant: function() { var e = this._controlInterpolants,
                        t = this._nActiveControlInterpolants++,
                        n = e[t]; return void 0 === n && ((n = new Ei(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = t, e[t] = n), n }, _takeBackControlInterpolant: function(e) { var t = this._controlInterpolants,
                        n = e.__cacheIndex,
                        i = --this._nActiveControlInterpolants,
                        r = t[i];
                    e.__cacheIndex = i, t[i] = e, r.__cacheIndex = n, t[n] = r }, _controlInterpolantsResultBuffer: new Float32Array(1), clipAction: function(e, t, n) { var i = t || this._root,
                        r = i.uuid;
                    e = null !== (i = "string" == typeof e ? Bi.findByName(i, e) : e) ? i.uuid : e; var a = this._actionsByClip[e],
                        o = null; if (void 0 === n && (n = null !== i ? i.blendMode : 2500), void 0 !== a) { if (void 0 !== (o = a.actionByRoot[r]) && o.blendMode === n) return o;
                        o = a.knownActions[0], null === i && (i = o._clip) } return null === i ? null : (t = new Xr(this, i, t, n), this._bindAction(t, o), this._addInactiveAction(t, e, r), t) }, existingAction: function(e, t) { var n = t || this._root; return t = n.uuid, n = "string" == typeof e ? Bi.findByName(n, e) : e, void 0 !== (e = this._actionsByClip[n ? n.uuid : e]) && e.actionByRoot[t] || null }, stopAllAction: function() { for (var e = this._actions, t = this._nActiveActions - 1; 0 <= t; --t) e[t].stop(); return this }, update: function(e) { e *= this.timeScale; for (var t = this._actions, n = this._nActiveActions, i = this.time += e, r = Math.sign(e), a = this._accuIndex ^= 1, o = 0; o !== n; ++o) t[o]._update(i, e, r, a); for (e = this._bindings, t = this._nActiveBindings, o = 0; o !== t; ++o) e[o].apply(a); return this }, setTime: function(e) { for (var t = this.time = 0; t < this._actions.length; t++) this._actions[t].time = 0; return this.update(e) }, getRoot: function() { return this._root }, uncacheClip: function(e) { var t = this._actions;
                    e = e.uuid; var n = this._actionsByClip,
                        i = n[e]; if (void 0 !== i) { for (var r = 0, a = (i = i.knownActions).length; r !== a; ++r) { var o = i[r];
                            this._deactivateAction(o); var s = o._cacheIndex,
                                c = t[t.length - 1];
                            o._cacheIndex = null, o._byClipCacheIndex = null, c._cacheIndex = s, t[s] = c, t.pop(), this._removeInactiveBindingsForAction(o) } delete n[e] } }, uncacheRoot: function(e) { e = e.uuid; var t = this._actionsByClip; for (i in t) { var n = t[i].actionByRoot[e];
                        void 0 !== n && (this._deactivateAction(n), this._removeInactiveAction(n)) } var i = this._bindingsByRootAndName[e]; if (void 0 !== i)
                        for (var r in i)(e = i[r]).restoreOriginalState(), this._removeInactiveBinding(e) }, uncacheAction: function(e, t) { null !== (e = this.existingAction(e, t)) && (this._deactivateAction(e), this._removeInactiveAction(e)) } }), Zr.prototype.clone = function() { return new Zr(void 0 === this.value.clone ? this.value : this.value.clone()) }, Jr.prototype = Object.assign(Object.create(Gt.prototype), { constructor: Jr, isInstancedInterleavedBuffer: !0, copy: function(e) { return Gt.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this } }), Object.assign(Qr.prototype, { set: function(e, t) { this.ray.set(e, t) }, setFromCamera: function(e, t) { t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type.") }, intersectObject: function(e, t, n) { return $r(e, this, n = n || [], t), n.sort(Kr), n }, intersectObjects: function(e, t, n) { if (n = n || [], !1 === Array.isArray(e)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), n; for (var i = 0, r = e.length; i < r; i++) $r(e[i], this, n, t); return n.sort(Kr), n } }), Object.assign(ea.prototype, { set: function(e, t, n) { return this.radius = e, this.phi = t, this.theta = n, this }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this }, makeSafe: function() { return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this }, setFromVector3: function(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) }, setFromCartesianCoords: function(e, t, n) { return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(e, n), this.phi = Math.acos(Ra.clamp(t / this.radius, -1, 1))), this } }), Object.assign(ta.prototype, { set: function(e, t, n) { return this.radius = e, this.theta = t, this.y = n, this }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this }, setFromVector3: function(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) }, setFromCartesianCoords: function(e, t, n) { return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this } }); var ll = new n;
            Object.assign(na.prototype, { set: function(e, t) { return this.min.copy(e), this.max.copy(t), this }, setFromPoints: function(e) { this.makeEmpty(); for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]); return this }, setFromCenterAndSize: function(e, t) { return t = ll.copy(t).multiplyScalar(.5), this.min.copy(e).sub(t), this.max.copy(e).add(t), this }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.min.copy(e.min), this.max.copy(e.max), this }, makeEmpty: function() { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this }, isEmpty: function() { return this.max.x < this.min.x || this.max.y < this.min.y }, getCenter: function(e) { return void 0 === e && (console.warn("THREE.Box2: .getCenter() target is now required"), e = new n), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) }, getSize: function(e) { return void 0 === e && (console.warn("THREE.Box2: .getSize() target is now required"), e = new n), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min) }, expandByPoint: function(e) { return this.min.min(e), this.max.max(e), this }, expandByVector: function(e) { return this.min.sub(e), this.max.add(e), this }, expandByScalar: function(e) { return this.min.addScalar(-e), this.max.addScalar(e), this }, containsPoint: function(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y) }, containsBox: function(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y }, getParameter: function(e, t) { return void 0 === t && (console.warn("THREE.Box2: .getParameter() target is now required"), t = new n), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y)) }, intersectsBox: function(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y) }, clampPoint: function(e, t) { return void 0 === t && (console.warn("THREE.Box2: .clampPoint() target is now required"), t = new n), t.copy(e).clamp(this.min, this.max) }, distanceToPoint: function(e) { return ll.copy(e).clamp(this.min, this.max).sub(e).length() }, intersect: function(e) { return this.min.max(e.min), this.max.min(e.max), this }, union: function(e) { return this.min.min(e.min), this.max.max(e.max), this }, translate: function(e) { return this.min.add(e), this.max.add(e), this }, equals: function(e) { return e.min.equals(this.min) && e.max.equals(this.max) } }); var hl = new l,
                ul = new l;
            Object.assign(ia.prototype, { set: function(e, t) { return this.start.copy(e), this.end.copy(t), this }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.start.copy(e.start), this.end.copy(e.end), this }, getCenter: function(e) { return void 0 === e && (console.warn("THREE.Line3: .getCenter() target is now required"), e = new l), e.addVectors(this.start, this.end).multiplyScalar(.5) }, delta: function(e) { return void 0 === e && (console.warn("THREE.Line3: .delta() target is now required"), e = new l), e.subVectors(this.end, this.start) }, distanceSq: function() { return this.start.distanceToSquared(this.end) }, distance: function() { return this.start.distanceTo(this.end) }, at: function(e, t) { return void 0 === t && (console.warn("THREE.Line3: .at() target is now required"), t = new l), this.delta(t).multiplyScalar(e).add(this.start) }, closestPointToPointParameter: function(e, t) { return hl.subVectors(e, this.start), ul.subVectors(this.end, this.start), e = ul.dot(ul), e = ul.dot(hl) / e, t && (e = Ra.clamp(e, 0, 1)), e }, closestPointToPoint: function(e, t, n) { return e = this.closestPointToPointParameter(e, t), void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new l), this.delta(n).multiplyScalar(e).add(this.start) }, applyMatrix4: function(e) { return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this }, equals: function(e) { return e.start.equals(this.start) && e.end.equals(this.end) } }), ra.prototype = Object.create(d.prototype), ra.prototype.constructor = ra, ra.prototype.isImmediateRenderObject = !0; var pl = new l;
            aa.prototype = Object.create(d.prototype), aa.prototype.constructor = aa, aa.prototype.dispose = function() { this.cone.geometry.dispose(), this.cone.material.dispose() }, aa.prototype.update = function() { this.light.updateMatrixWorld(); var e = this.light.distance ? this.light.distance : 1e3,
                    t = e * Math.tan(this.light.angle);
                this.cone.scale.set(t, t, e), pl.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(pl), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color) }; var dl = new l,
                fl = new h,
                ml = new h;
            oa.prototype = Object.create(Kt.prototype), oa.prototype.constructor = oa, oa.prototype.isSkeletonHelper = !0, oa.prototype.updateMatrixWorld = function(e) { var t = this.bones,
                    n = this.geometry,
                    i = n.getAttribute("position");
                ml.getInverse(this.root.matrixWorld); for (var r = 0, a = 0; r < t.length; r++) { var o = t[r];
                    o.parent && o.parent.isBone && (fl.multiplyMatrices(ml, o.matrixWorld), dl.setFromMatrixPosition(fl), i.setXYZ(a, dl.x, dl.y, dl.z), fl.multiplyMatrices(ml, o.parent.matrixWorld), dl.setFromMatrixPosition(fl), i.setXYZ(a + 1, dl.x, dl.y, dl.z), a += 2) } n.getAttribute("position").needsUpdate = !0, d.prototype.updateMatrixWorld.call(this, e) }, sa.prototype = Object.create(H.prototype), sa.prototype.constructor = sa, sa.prototype.dispose = function() { this.geometry.dispose(), this.material.dispose() }, sa.prototype.update = function() { void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) }; var gl = new l,
                vl = new b,
                yl = new b;
            ca.prototype = Object.create(d.prototype), ca.prototype.constructor = ca, ca.prototype.dispose = function() { this.children[0].geometry.dispose(), this.children[0].material.dispose() }, ca.prototype.update = function() { var e = this.children[0]; if (void 0 !== this.color) this.material.color.set(this.color);
                else { var t = e.geometry.getAttribute("color");
                    vl.copy(this.light.color), yl.copy(this.light.groundColor); for (var n = 0, i = t.count; n < i; n++) { var r = n < i / 2 ? vl : yl;
                        t.setXYZ(n, r.r, r.g, r.b) } t.needsUpdate = !0 } e.lookAt(gl.setFromMatrixPosition(this.light.matrixWorld).negate()) }, la.prototype = Object.assign(Object.create(Kt.prototype), { constructor: la, copy: function(e) { return Kt.prototype.copy.call(this, e), this.geometry.copy(e.geometry), this.material.copy(e.material), this }, clone: function() { return (new this.constructor).copy(this) } }), ha.prototype = Object.create(Kt.prototype), ha.prototype.constructor = ha; var xl = new l,
                _l = new l,
                bl = new l;
            ua.prototype = Object.create(d.prototype), ua.prototype.constructor = ua, ua.prototype.dispose = function() { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() }, ua.prototype.update = function() { xl.setFromMatrixPosition(this.light.matrixWorld), _l.setFromMatrixPosition(this.light.target.matrixWorld), bl.subVectors(_l, xl), this.lightPlane.lookAt(_l), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(_l), this.targetLine.scale.z = bl.length() }; var wl = new l,
                Ml = new Y;
            pa.prototype = Object.create(Kt.prototype), pa.prototype.constructor = pa, pa.prototype.update = function() { var e = this.geometry,
                    t = this.pointMap;
                Ml.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), da("c", t, e, Ml, 0, 0, -1), da("t", t, e, Ml, 0, 0, 1), da("n1", t, e, Ml, -1, -1, -1), da("n2", t, e, Ml, 1, -1, -1), da("n3", t, e, Ml, -1, 1, -1), da("n4", t, e, Ml, 1, 1, -1), da("f1", t, e, Ml, -1, -1, 1), da("f2", t, e, Ml, 1, -1, 1), da("f3", t, e, Ml, -1, 1, 1), da("f4", t, e, Ml, 1, 1, 1), da("u1", t, e, Ml, .7, 1.1, -1), da("u2", t, e, Ml, -.7, 1.1, -1), da("u3", t, e, Ml, 0, 2, -1), da("cf1", t, e, Ml, -1, 0, 1), da("cf2", t, e, Ml, 1, 0, 1), da("cf3", t, e, Ml, 0, -1, 1), da("cf4", t, e, Ml, 0, 1, 1), da("cn1", t, e, Ml, -1, 0, -1), da("cn2", t, e, Ml, 1, 0, -1), da("cn3", t, e, Ml, 0, -1, -1), da("cn4", t, e, Ml, 0, 1, -1), e.getAttribute("position").needsUpdate = !0 }; var Sl = new m;
            fa.prototype = Object.create(Kt.prototype), fa.prototype.constructor = fa, fa.prototype.update = function(e) { if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && Sl.setFromObject(this.object), !Sl.isEmpty()) { e = Sl.min; var t = Sl.max,
                        n = this.geometry.attributes.position,
                        i = n.array;
                    i[0] = t.x, i[1] = t.y, i[2] = t.z, i[3] = e.x, i[4] = t.y, i[5] = t.z, i[6] = e.x, i[7] = e.y, i[8] = t.z, i[9] = t.x, i[10] = e.y, i[11] = t.z, i[12] = t.x, i[13] = t.y, i[14] = e.z, i[15] = e.x, i[16] = t.y, i[17] = e.z, i[18] = e.x, i[19] = e.y, i[20] = e.z, i[21] = t.x, i[22] = e.y, i[23] = e.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere() } }, fa.prototype.setFromObject = function(e) { return this.object = e, this.update(), this }, fa.prototype.copy = function(e) { return Kt.prototype.copy.call(this, e), this.object = e.object, this }, fa.prototype.clone = function() { return (new this.constructor).copy(this) }, ma.prototype = Object.create(Kt.prototype), ma.prototype = Object.assign(Object.create(Kt.prototype), { constructor: ma, copy: function(e) { return Kt.prototype.copy.call(this, e), this.box = e.box.clone(), this } }), ma.prototype.updateMatrixWorld = function(e) { var t = this.box;
                t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), d.prototype.updateMatrixWorld.call(this, e)) }, ga.prototype = Object.create(Qt.prototype), ga.prototype.constructor = ga, ga.prototype.updateMatrixWorld = function(e) { var t = -this.plane.constant;
                1e-8 > Math.abs(t) && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.children[0].material.side = 0 > t ? 1 : 0, this.lookAt(this.plane.normal), d.prototype.updateMatrixWorld.call(this, e) }; var Tl, El, Al = new l;
            va.prototype = Object.create(d.prototype), va.prototype.constructor = va, va.prototype.setDirection = function(e) { .99999 < e.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > e.y ? this.quaternion.set(1, 0, 0, 0) : (Al.set(e.z, 0, -e.x).normalize(), this.quaternion.setFromAxisAngle(Al, Math.acos(e.y))) }, va.prototype.setLength = function(e, t, n) { void 0 === t && (t = .2 * e), void 0 === n && (n = .2 * t), this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix() }, va.prototype.setColor = function(e) { this.line.material.color.set(e), this.cone.material.color.set(e) }, va.prototype.copy = function(e) { return d.prototype.copy.call(this, e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this }, va.prototype.clone = function() { return (new this.constructor).copy(this) }, ya.prototype = Object.create(Kt.prototype), ya.prototype.constructor = ya; var Ll = Math.pow(2, 8),
                Rl = [.125, .215, .35, .446, .526, .582],
                Pl = 5 + Rl.length,
                Cl = { 3000: 0, 3001: 1, 3002: 2, 3004: 3, 3005: 4, 3006: 5, 3007: 6 },
                Ol = new yr,
                Dl = function() { for (var e = [], t = [], n = [], i = 8, r = 0; r < Pl; r++) { var a = Math.pow(2, i);
                        t.push(a); var o = 1 / a;
                        4 < r ? o = Rl[r - 8 + 4 - 1] : 0 == r && (o = 0), n.push(o); var s = [a = -(o = 1 / (a - 1)) / 2, a, o = 1 + o / 2, a, o, o, a, a, o, o, a, o];
                        a = new Float32Array(108), o = new Float32Array(72); for (var c = new Float32Array(36), l = 0; 6 > l; l++) { var h = l % 3 * 2 / 3 - 1,
                                u = 2 < l ? 0 : -1;
                            a.set([h, u, 0, h + 2 / 3, u, 0, h + 2 / 3, u + 1, 0, h, u, 0, h + 2 / 3, u + 1, 0, h, u + 1, 0], 18 * l), o.set(s, 12 * l), c.set([l, l, l, l, l, l], 6 * l) }(s = new G).setAttribute("position", new L(a, 3)), s.setAttribute("uv", new L(o, 2)), s.setAttribute("faceIndex", new L(c, 1)), e.push(s), 4 < i && i-- } return { _lodPlanes: e, _sizeLods: t, _sigmas: n } }(),
                Il = Dl._lodPlanes,
                Nl = Dl._sizeLods,
                Bl = Dl._sigmas,
                zl = null,
                Ul = (1 + Math.sqrt(5)) / 2,
                Fl = 1 / Ul,
                Gl = [new l(1, 1, 1), new l(-1, 1, 1), new l(1, 1, -1), new l(-1, 1, -1), new l(0, Ul, Fl), new l(0, Ul, -Fl), new l(Fl, 0, Ul), new l(-Fl, 0, Ul), new l(Ul, Fl, 0), new l(-Ul, Fl, 0)];
            xa.prototype = { constructor: xa, fromScene: function(e, t, n, i) { void 0 === t && (t = 0), void 0 === n && (n = .1), void 0 === i && (i = 100), zl = this._renderer.getRenderTarget(); var r = this._allocateTargets(); return this._sceneToCubeUV(e, n, i, r), 0 < t && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r }, fromEquirectangular: function(e) { return e.magFilter = 1003, e.minFilter = 1003, e.generateMipmaps = !1, this.fromCubemap(e) }, fromCubemap: function(e) { zl = this._renderer.getRenderTarget(); var t = this._allocateTargets(e); return this._textureToCubeUV(e, t), this._applyPMREM(t), this._cleanup(t), t }, compileCubemapShader: function() { null === this._cubemapShader && (this._cubemapShader = Ma(), this._compileMaterial(this._cubemapShader)) }, compileEquirectangularShader: function() { null === this._equirectShader && (this._equirectShader = wa(), this._compileMaterial(this._equirectShader)) }, dispose: function() { this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose(); for (var e = 0; e < Il.length; e++) Il[e].dispose() }, _cleanup: function(e) { this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(zl), e.scissorTest = !1, e.setSize(e.width, e.height) }, _allocateTargets: function(e) { var t = void 0 !== e && 1009 === e.type && (3e3 === e.encoding || 3001 === e.encoding || 3007 === e.encoding),
                        n = _a(t = { magFilter: 1003, minFilter: 1003, generateMipmaps: !1, type: 1009, format: 1023, encoding: t ? e.encoding : 3002, depthBuffer: !1, stencilBuffer: !1 }); return n.depthBuffer = !e, this._pingPongRenderTarget = _a(t), n }, _compileMaterial: function(e) { e = new H(Il[0], e), this._renderer.compile(e, Ol) }, _sceneToCubeUV: function(e, t, n, i) { t = new Z(90, 1, t, n), n = [1, -1, 1, 1, 1, 1]; var r = [1, 1, 1, -1, -1, -1],
                        a = this._renderer,
                        o = a.outputEncoding,
                        s = a.toneMapping,
                        c = a.toneMappingExposure,
                        l = a.getClearColor(),
                        h = a.getClearAlpha();
                    a.toneMapping = 1, a.toneMappingExposure = 1, a.outputEncoding = 3e3; var u = e.background; if (u && u.isColor) { u.convertSRGBToLinear(); var p = Math.min(Math.max(Math.ceil(Math.log2(Math.max(u.r, u.g, u.b))), -128), 127);
                        u = u.multiplyScalar(Math.pow(2, -p)), a.setClearColor(u, (p + 128) / 255), e.background = null } for (u = 0; 6 > u; u++) 0 == (p = u % 3) ? (t.up.set(0, n[u], 0), t.lookAt(r[u], 0, 0)) : 1 == p ? (t.up.set(0, 0, n[u]), t.lookAt(0, r[u], 0)) : (t.up.set(0, n[u], 0), t.lookAt(0, 0, r[u])), ba(i, p * Ll, 2 < u ? Ll : 0, Ll, Ll), a.setRenderTarget(i), a.render(e, t);
                    a.toneMapping = s, a.toneMappingExposure = c, a.outputEncoding = o, a.setClearColor(l, h) }, _textureToCubeUV: function(e, t) { var n = this._renderer;
                    e.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = Ma()) : null == this._equirectShader && (this._equirectShader = wa()); var i = e.isCubeTexture ? this._cubemapShader : this._equirectShader,
                        r = new H(Il[0], i);
                    (i = i.uniforms).envMap.value = e, e.isCubeTexture || i.texelSize.value.set(1 / e.image.width, 1 / e.image.height), i.inputEncoding.value = Cl[e.encoding], i.outputEncoding.value = Cl[t.texture.encoding], ba(t, 0, 0, 3 * Ll, 2 * Ll), n.setRenderTarget(t), n.render(r, Ol) }, _applyPMREM: function(e) { var t = this._renderer,
                        n = t.autoClear;
                    t.autoClear = !1; for (var i = 1; i < Pl; i++) this._blur(e, i - 1, i, Math.sqrt(Bl[i] * Bl[i] - Bl[i - 1] * Bl[i - 1]), Gl[(i - 1) % Gl.length]);
                    t.autoClear = n }, _blur: function(e, t, n, i, r) { var a = this._pingPongRenderTarget;
                    this._halfBlur(e, a, t, n, i, "latitudinal", r), this._halfBlur(a, e, n, n, i, "longitudinal", r) }, _halfBlur: function(e, t, n, i, r, a, o) { var s = this._renderer,
                        c = this._blurMaterial; "latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!"); var l = new H(Il[i], c);
                    c = c.uniforms; var h = Nl[n] - 1,
                        u = r / (h = isFinite(r) ? Math.PI / (2 * h) : 2 * Math.PI / 39),
                        p = isFinite(r) ? 1 + Math.floor(3 * u) : 20;
                    20 < p && console.warn("sigmaRadians, " + r + ", is too large and will clip, as it requested " + p + " samples when the maximum is set to 20"), r = []; for (var d = 0, f = 0; 20 > f; ++f) { var m = f / u;
                        m = Math.exp(-m * m / 2), r.push(m), 0 == f ? d += m : f < p && (d += 2 * m) } for (f = 0; f < r.length; f++) r[f] /= d;
                    c.envMap.value = e.texture, c.samples.value = p, c.weights.value = r, c.latitudinal.value = "latitudinal" === a, o && (c.poleAxis.value = o), c.dTheta.value = h, c.mipInt.value = 8 - n, c.inputEncoding.value = Cl[e.texture.encoding], c.outputEncoding.value = Cl[e.texture.encoding], e = Nl[i], ba(t, m = 3 * Math.max(0, Ll - 2 * e), (0 === i ? 0 : 2 * Ll) + 2 * e * (4 < i ? i - 8 + 4 : 0), 3 * e, 2 * e), s.setRenderTarget(t), s.render(l, Ol) } }, Xi.create = function(e, t) { return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(Xi.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e }, Object.assign(cr.prototype, { createPointsGeometry: function(e) { return console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."), e = this.getPoints(e), this.createGeometry(e) }, createSpacedPointsGeometry: function(e) { return console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."), e = this.getSpacedPoints(e), this.createGeometry(e) }, createGeometry: function(e) { console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); for (var t = new j, n = 0, i = e.length; n < i; n++) { var r = e[n];
                        t.vertices.push(new l(r.x, r.y, r.z || 0)) } return t } }), Object.assign(lr.prototype, { fromPoints: function(e) { return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e) } }), Sa.prototype = Object.create(Qi.prototype), Ta.prototype = Object.create(Qi.prototype), Ea.prototype = Object.create(Qi.prototype), Object.assign(Ea.prototype, { initFromArray: function() { console.error("THREE.Spline: .initFromArray() has been removed.") }, getControlPointsArray: function() { console.error("THREE.Spline: .getControlPointsArray() has been removed.") }, reparametrizeByArcLength: function() { console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.") } }), la.prototype.setColors = function() { console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.") }, oa.prototype.update = function() { console.error("THREE.SkeletonHelper: update() no longer needs to be called.") }, Object.assign(Fi.prototype, { extractUrlBase: function(e) { return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Uc.extractUrlBase(e) } }), Fi.Handlers = { add: function() { console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.") }, get: function() { console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.") } }, Object.assign(Rr.prototype, { setTexturePath: function(e) { return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e) } }), Object.assign(na.prototype, { center: function(e) { return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e) }, empty: function() { return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, isIntersectionBox: function(e) { return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, size: function(e) { return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e) } }), Object.assign(m.prototype, { center: function(e) { return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e) }, empty: function() { return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, isIntersectionBox: function(e) { return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, isIntersectionSphere: function(e) { return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e) }, size: function(e) { return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e) } }), Object.assign(v.prototype, { empty: function() { return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty() } }), $.prototype.setFromMatrix = function(e) { return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(e) }, ia.prototype.center = function(e) { return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e) }, Object.assign(Ra, { random16: function() { return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random() }, nearestPowerOfTwo: function(e) { return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), Ra.floorPowerOfTwo(e) }, nextPowerOfTwo: function(e) { return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), Ra.ceilPowerOfTwo(e) } }), Object.assign(i.prototype, { flattenToArrayOffset: function(e, t) { return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t) }, multiplyVector3: function(e) { return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this) }, multiplyVector3Array: function() { console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.") }, applyToBufferAttribute: function(e) { return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), e.applyMatrix3(this) }, applyToVector3Array: function() { console.error("THREE.Matrix3: .applyToVector3Array() has been removed.") } }), Object.assign(h.prototype, { extractPosition: function(e) { return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e) }, flattenToArrayOffset: function(e, t) { return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t) }, getPosition: function() { return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new l).setFromMatrixColumn(this, 3) }, setRotationFromQuaternion: function(e) { return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e) }, multiplyToArray: function() { console.warn("THREE.Matrix4: .multiplyToArray() has been removed.") }, multiplyVector3: function(e) { return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, multiplyVector4: function(e) { return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, multiplyVector3Array: function() { console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.") }, rotateAxis: function(e) { console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this) }, crossVector: function(e) { return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, translate: function() { console.error("THREE.Matrix4: .translate() has been removed.") }, rotateX: function() { console.error("THREE.Matrix4: .rotateX() has been removed.") }, rotateY: function() { console.error("THREE.Matrix4: .rotateY() has been removed.") }, rotateZ: function() { console.error("THREE.Matrix4: .rotateZ() has been removed.") }, rotateByAxis: function() { console.error("THREE.Matrix4: .rotateByAxis() has been removed.") }, applyToBufferAttribute: function(e) { return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, applyToVector3Array: function() { console.error("THREE.Matrix4: .applyToVector3Array() has been removed.") }, makeFrustum: function(e, t, n, i, r, a) { return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, i, n, r, a) } }), x.prototype.isIntersectionLine = function(e) { return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e) }, c.prototype.multiplyVector3 = function(e) { return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this) }, Object.assign(y.prototype, { isIntersectionBox: function(e) { return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, isIntersectionPlane: function(e) { return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e) }, isIntersectionSphere: function(e) { return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e) } }), Object.assign(_.prototype, { area: function() { return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea() }, barycoordFromPoint: function(e, t) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t) }, midpoint: function(e) { return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e) }, normal: function(e) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e) }, plane: function(e) { return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e) } }), Object.assign(_, { barycoordFromPoint: function(e, t, n, i, r) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), _.getBarycoord(e, t, n, i, r) }, normal: function(e, t, n, i) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), _.getNormal(e, t, n, i) } }), Object.assign(hr.prototype, { extractAllPoints: function(e) { return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e) }, extrude: function(e) { return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Xn(this, e) }, makeGeometry: function(e) { return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new ri(this, e) } }), Object.assign(n.prototype, { fromAttribute: function(e, t, n) { return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n) }, distanceToManhattan: function(e) { return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e) }, lengthManhattan: function() { return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(l.prototype, { setEulerFromRotationMatrix: function() { console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.") }, setEulerFromQuaternion: function() { console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.") }, getPositionFromMatrix: function(e) { return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e) }, getScaleFromMatrix: function(e) { return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e) }, getColumnFromMatrix: function(e, t) { return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e) }, applyProjection: function(e) { return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e) }, fromAttribute: function(e, t, n) { return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n) }, distanceToManhattan: function(e) { return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e) }, lengthManhattan: function() { return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(a.prototype, { fromAttribute: function(e, t, n) { return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n) }, lengthManhattan: function() { return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(j.prototype, { computeTangents: function() { console.error("THREE.Geometry: .computeTangents() has been removed.") }, computeLineDistances: function() { console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.") }, applyMatrix: function(e) { return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e) } }), Object.assign(d.prototype, { getChildByName: function(e) { return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e) }, renderDepth: function() { console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.") }, translate: function(e, t) { return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e) }, getWorldRotation: function() { console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.") }, applyMatrix: function(e) { return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e) } }), Object.defineProperties(d.prototype, { eulerOrder: { get: function() { return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order }, set: function(e) { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e } }, useQuaternion: { get: function() { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") }, set: function() { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") } } }), Object.assign(H.prototype, { setDrawMode: function() { console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") } }), Object.defineProperties(H.prototype, { drawMode: { get: function() { return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0 }, set: function() { console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") } } }), Object.defineProperties(Wt.prototype, { objects: { get: function() { return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels } } }), Object.defineProperty(Xt.prototype, "useVertexTexture", { get: function() { console.warn("THREE.Skeleton: useVertexTexture has been removed.") }, set: function() { console.warn("THREE.Skeleton: useVertexTexture has been removed.") } }), qt.prototype.initBones = function() { console.error("THREE.SkinnedMesh: initBones() has been removed.") }, Object.defineProperty(Xi.prototype, "__arcLengthDivisions", { get: function() { return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions }, set: function(e) { console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e } }), Z.prototype.setLens = function(e, t) { console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e) }, Object.defineProperties(ur.prototype, { onlyShadow: { set: function() { console.warn("THREE.Light: .onlyShadow has been removed.") } }, shadowCameraFov: { set: function(e) { console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e } }, shadowCameraLeft: { set: function(e) { console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e } }, shadowCameraRight: { set: function(e) { console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e } }, shadowCameraTop: { set: function(e) { console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e } }, shadowCameraBottom: { set: function(e) { console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e } }, shadowCameraNear: { set: function(e) { console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e } }, shadowCameraFar: { set: function(e) { console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e } }, shadowCameraVisible: { set: function() { console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.") } }, shadowBias: { set: function(e) { console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e } }, shadowDarkness: { set: function() { console.warn("THREE.Light: .shadowDarkness has been removed.") } }, shadowMapWidth: { set: function(e) { console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e } }, shadowMapHeight: { set: function(e) { console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e } } }), Object.defineProperties(L.prototype, { length: { get: function() { return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length } }, dynamic: { get: function() { return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), 35048 === this.usage }, set: function() { console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(35048) } } }), Object.assign(L.prototype, { setDynamic: function(e) { return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? 35048 : 35044), this }, copyIndicesArray: function() { console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.") }, setArray: function() { console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") } }), Object.assign(G.prototype, { addIndex: function(e) { console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e) }, addAttribute: function(e, t, n) { return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : this.setAttribute(e, t) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(e, new L(t, n))) }, addDrawCall: function(e, t, n) { void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t) }, clearDrawCalls: function() { console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups() }, computeTangents: function() { console.warn("THREE.BufferGeometry: .computeTangents() has been removed.") }, computeOffsets: function() { console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.") }, removeAttribute: function(e) { return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(e) }, applyMatrix: function(e) { return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e) } }), Object.defineProperties(G.prototype, { drawcalls: { get: function() { return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups } }, offsets: { get: function() { return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups } } }), Object.defineProperties(Er.prototype, { maxInstancedCount: { get: function() { return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount }, set: function(e) { console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount = e } } }), Object.defineProperties(Qr.prototype, { linePrecision: { get: function() { return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold }, set: function(e) { console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold = e } } }), Object.defineProperties(Gt.prototype, { dynamic: { get: function() { return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), 35048 === this.usage }, set: function(e) { console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(e) } } }), Object.assign(Gt.prototype, { setDynamic: function(e) { return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? 35048 : 35044), this }, setArray: function() { console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") } }), Object.assign(Yn.prototype, { getArrays: function() { console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.") }, addShapeList: function() { console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.") }, addShape: function() { console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.") } }), Object.defineProperties(Zr.prototype, { dynamic: { set: function() { console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.") } }, onUpdate: { value: function() { return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this } } }), Object.defineProperties(E.prototype, { wrapAround: { get: function() { console.warn("THREE.Material: .wrapAround has been removed.") }, set: function() { console.warn("THREE.Material: .wrapAround has been removed.") } }, overdraw: { get: function() { console.warn("THREE.Material: .overdraw has been removed.") }, set: function() { console.warn("THREE.Material: .overdraw has been removed.") } }, wrapRGB: { get: function() { return console.warn("THREE.Material: .wrapRGB has been removed."), new b } }, shading: { get: function() { console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.") }, set: function(e) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === e } }, stencilMask: { get: function() { return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask }, set: function(e) { console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = e } } }), Object.defineProperties(yi.prototype, { metal: { get: function() { return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1 }, set: function() { console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead") } } }), Object.defineProperties(X.prototype, { derivatives: { get: function() { return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives }, set: function(e) { console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e } } }), Object.assign(zt.prototype, { clearTarget: function(e, t, n, i) { console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, n, i) }, animate: function(e) { console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e) }, getCurrentRenderTarget: function() { return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget() }, getMaxAnisotropy: function() { return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy() }, getPrecision: function() { return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision }, resetGLState: function() { return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset() }, supportsFloatTextures: function() { return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float") }, supportsHalfFloatTextures: function() { return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float") }, supportsStandardDerivatives: function() { return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives") }, supportsCompressedTextureS3TC: function() { return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc") }, supportsCompressedTexturePVRTC: function() { return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc") }, supportsBlendMinMax: function() { return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax") }, supportsVertexTextures: function() { return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures }, supportsInstancedArrays: function() { return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays") }, enableScissorTest: function(e) { console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e) }, initMaterial: function() { console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.") }, addPrePlugin: function() { console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.") }, addPostPlugin: function() { console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.") }, updateShadowMap: function() { console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.") }, setFaceCulling: function() { console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.") }, allocTextureUnit: function() { console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.") }, setTexture: function() { console.warn("THREE.WebGLRenderer: .setTexture() has been removed.") }, setTexture2D: function() { console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.") }, setTextureCube: function() { console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.") }, getActiveMipMapLevel: function() { return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel() } }), Object.defineProperties(zt.prototype, { shadowMapEnabled: { get: function() { return this.shadowMap.enabled }, set: function(e) { console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e } }, shadowMapType: { get: function() { return this.shadowMap.type }, set: function(e) { console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e } }, shadowMapCullFace: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") } }, context: { get: function() { return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext() } }, vr: { get: function() { return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr } }, gammaInput: { get: function() { return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1 }, set: function() { console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.") } }, gammaOutput: { get: function() { return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1 }, set: function(e) { console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === e ? 3001 : 3e3 } } }), Object.defineProperties(Lt.prototype, { cullFace: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") } }, renderReverseSided: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") } }, renderSingleSided: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") } } }), Object.defineProperties(o.prototype, { wrapS: { get: function() { return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e } }, wrapT: { get: function() { return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e } }, magFilter: { get: function() { return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e } }, minFilter: { get: function() { return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e } }, anisotropy: { get: function() { return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e } }, offset: { get: function() { return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e } }, repeat: { get: function() { return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e } }, format: { get: function() { return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e } }, type: { get: function() { return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e } }, generateMipmaps: { get: function() { return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e } } }), Object.defineProperties(Gr.prototype, { load: { value: function(e) { console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."); var t = this; return (new Ir).load(e, function(e) { t.setBuffer(e) }), this } }, startTime: { set: function() { console.warn("THREE.Audio: .startTime is now .play( delay ).") } } }), kr.prototype.getData = function() { return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData() }, J.prototype.updateCubeMap = function(e, t) { return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t) }, Ca.crossOrigin = void 0, Ca.loadTexture = function(e, t, n, i) { console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."); var r = new qi; return r.setCrossOrigin(this.crossOrigin), e = r.load(e, n, void 0, i), t && (e.mapping = t), e }, Ca.loadTextureCube = function(e, t, n, i) { console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."); var r = new Wi; return r.setCrossOrigin(this.crossOrigin), e = r.load(e, n, void 0, i), t && (e.mapping = t), e }, Ca.loadCompressedTexture = function() { console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.") }, Ca.loadCompressedTextureCube = function() { console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.") }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: "117" } })), e.ACESFilmicToneMapping = 5, e.AddEquation = 100, e.AddOperation = 2, e.AdditiveAnimationBlendMode = 2501, e.AdditiveBlending = 2, e.AlphaFormat = 1021, e.AlwaysDepth = 1, e.AlwaysStencilFunc = 519, e.AmbientLight = br, e.AmbientLightProbe = Br, e.AnimationClip = Bi, e.AnimationLoader = Hi, e.AnimationMixer = Yr, e.AnimationObjectGroup = qr, e.AnimationUtils = Rc, e.ArcCurve = Zi, e.ArrayCamera = Ot, e.ArrowHelper = va, e.Audio = Gr, e.AudioAnalyser = kr, e.AudioContext = jc, e.AudioListener = Fr, e.AudioLoader = Ir, e.AxesHelper = ya, e.AxisHelper = function(e) { return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new ya(e) }, e.BackSide = 1, e.BasicDepthPacking = 3200, e.BasicShadowMap = 0, e.BinaryTextureLoader = function(e) { return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Vi(e) }, e.Bone = Yt, e.BooleanKeyframeTrack = Ri, e.BoundingBoxHelper = function(e, t) { return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new fa(e, t) }, e.Box2 = na, e.Box3 = m, e.Box3Helper = ma, e.BoxBufferGeometry = ys, e.BoxGeometry = vs, e.BoxHelper = fa, e.BufferAttribute = L, e.BufferGeometry = G, e.BufferGeometryLoader = Lr, e.ByteType = 1010, e.Cache = Pc, e.Camera = Y, e.CameraHelper = pa, e.CanvasRenderer = function() { console.error("THREE.CanvasRenderer has been removed") }, e.CanvasTexture = on, e.CatmullRomCurve3 = Qi, e.CineonToneMapping = 4, e.CircleBufferGeometry = di, e.CircleGeometry = pi, e.ClampToEdgeWrapping = 1001, e.Clock = Ur, e.ClosedSplineCurve3 = Sa, e.Color = b, e.ColorKeyframeTrack = Pi, e.CompressedTexture = an, e.CompressedTextureLoader = ki, e.ConeBufferGeometry = ui, e.ConeGeometry = hi, e.CubeCamera = J, e.CubeGeometry = vs, e.CubeReflectionMapping = 301, e.CubeRefractionMapping = 302, e.CubeTexture = me, e.CubeTextureLoader = Wi, e.CubeUVReflectionMapping = 306, e.CubeUVRefractionMapping = 307, e.CubicBezierCurve = tr, e.CubicBezierCurve3 = nr, e.CubicInterpolant = Ti, e.CullFaceBack = 1, e.CullFaceFront = 2, e.CullFaceFrontBack = 3, e.CullFaceNone = 0, e.Curve = Xi, e.CurvePath = cr, e.CustomBlending = 5, e.CylinderBufferGeometry = li, e.CylinderGeometry = ci, e.Cylindrical = ta, e.DataTexture = K, e.DataTexture2DArray = ge, e.DataTexture3D = ve, e.DataTextureLoader = Vi, e.DecrementStencilOp = 7683, e.DecrementWrapStencilOp = 34056, e.DefaultLoadingManager = Cc, e.DepthFormat = 1026, e.DepthStencilFormat = 1027, e.DepthTexture = sn, e.DirectionalLight = _r, e.DirectionalLightHelper = ua, e.DirectionalLightShadow = xr, e.DiscreteInterpolant = Ai, e.DodecahedronBufferGeometry = _n, e.DodecahedronGeometry = xn, e.DoubleSide = 2, e.DstAlphaFactor = 206, e.DstColorFactor = 208, e.DynamicBufferAttribute = function(e, t) { return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new L(e, t).setUsage(35048) }, e.DynamicCopyUsage = 35050, e.DynamicDrawUsage = 35048, e.DynamicReadUsage = 35049, e.EdgesGeometry = si, e.EdgesHelper = function(e, t) { return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Kt(new si(e.geometry), new Jt({ color: void 0 !== t ? t : 16777215 })) }, e.EllipseCurve = Yi, e.EqualDepth = 4, e.EqualStencilFunc = 514, e.EquirectangularReflectionMapping = 303, e.EquirectangularRefractionMapping = 304, e.Euler = u, e.EventDispatcher = t, e.ExtrudeBufferGeometry = Yn, e.ExtrudeGeometry = Xn, e.Face3 = T, e.Face4 = function(e, t, n, i, r, a, o) { return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new T(e, t, n, r, a, o) }, e.FaceColors = 1, e.FileLoader = Gi, e.FlatShading = 1, e.Float32Attribute = function(e, t) { return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new B(e, t) }, e.Float32BufferAttribute = B, e.Float64Attribute = function(e, t) { return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new z(e, t) }, e.Float64BufferAttribute = z, e.FloatType = 1015, e.Fog = Ft, e.FogExp2 = Ut, e.Font = Or, e.FontLoader = Dr, e.FrontFaceDirectionCCW = 1, e.FrontFaceDirectionCW = 0, e.FrontSide = 0, e.Frustum = $, e.GammaEncoding = 3007, e.Geometry = j, e.GeometryUtils = { merge: function(e, t, n) { if (console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), t.isMesh) { t.matrixAutoUpdate && t.updateMatrix(); var i = t.matrix;
                        t = t.geometry } e.merge(t, i, n) }, center: function(e) { return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e.center() } }, e.GreaterDepth = 6, e.GreaterEqualDepth = 5, e.GreaterEqualStencilFunc = 518, e.GreaterStencilFunc = 516, e.GridHelper = la, e.Group = Dt, e.HalfFloatType = 1016, e.HemisphereLight = pr, e.HemisphereLightHelper = ca, e.HemisphereLightProbe = Nr, e.IcosahedronBufferGeometry = yn, e.IcosahedronGeometry = vn, e.ImageBitmapLoader = Pr, e.ImageLoader = ji, e.ImageUtils = Ca, e.ImmediateRenderObject = ra, e.IncrementStencilOp = 7682, e.IncrementWrapStencilOp = 34055, e.InstancedBufferAttribute = Ar, e.InstancedBufferGeometry = Er, e.InstancedInterleavedBuffer = Jr, e.InstancedMesh = Zt, e.Int16Attribute = function(e, t) { return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new O(e, t) }, e.Int16BufferAttribute = O, e.Int32Attribute = function(e, t) { return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new I(e, t) }, e.Int32BufferAttribute = I, e.Int8Attribute = function(e, t) { return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new R(e, t) }, e.Int8BufferAttribute = R, e.IntType = 1013, e.InterleavedBuffer = Gt, e.InterleavedBufferAttribute = Ht, e.Interpolant = Si, e.InterpolateDiscrete = 2300, e.InterpolateLinear = 2301, e.InterpolateSmooth = 2302, e.InvertStencilOp = 5386, e.JSONLoader = function() { console.error("THREE.JSONLoader has been removed.") }, e.KeepStencilOp = 7680, e.KeyframeTrack = Li, e.LOD = Wt, e.LatheBufferGeometry = ii, e.LatheGeometry = ni, e.Layers = p, e.LensFlare = function() { console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js") }, e.LessDepth = 2, e.LessEqualDepth = 3, e.LessEqualStencilFunc = 515, e.LessStencilFunc = 513, e.Light = ur, e.LightProbe = Sr, e.LightShadow = dr, e.Line = Qt, e.Line3 = ia, e.LineBasicMaterial = Jt, e.LineCurve = ir, e.LineCurve3 = rr, e.LineDashedMaterial = Mi, e.LineLoop = $t, e.LinePieces = 1, e.LineSegments = Kt, e.LineStrip = 0, e.LinearEncoding = 3e3, e.LinearFilter = 1006, e.LinearInterpolant = Ei, e.LinearMipMapLinearFilter = 1008, e.LinearMipMapNearestFilter = 1007, e.LinearMipmapLinearFilter = 1008, e.LinearMipmapNearestFilter = 1007, e.LinearToneMapping = 1, e.Loader = Fi, e.LoaderUtils = Uc, e.LoadingManager = Ui, e.LogLuvEncoding = 3003, e.LoopOnce = 2200, e.LoopPingPong = 2202, e.LoopRepeat = 2201, e.LuminanceAlphaFormat = 1025, e.LuminanceFormat = 1024, e.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, e.Material = E, e.MaterialLoader = Tr, e.Math = Ra, e.MathUtils = Ra, e.Matrix3 = i, e.Matrix4 = h, e.MaxEquation = 104, e.Mesh = H, e.MeshBasicMaterial = A, e.MeshDepthMaterial = Et, e.MeshDistanceMaterial = At, e.MeshFaceMaterial = function(e) { return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), e }, e.MeshLambertMaterial = bi, e.MeshMatcapMaterial = wi, e.MeshNormalMaterial = _i, e.MeshPhongMaterial = yi, e.MeshPhysicalMaterial = vi, e.MeshStandardMaterial = gi, e.MeshToonMaterial = xi, e.MinEquation = 103, e.MirroredRepeatWrapping = 1002, e.MixOperation = 1, e.MultiMaterial = function(e) { return void 0 === e && (e = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), e.isMultiMaterial = !0, e.materials = e, e.clone = function() { return e.slice() }, e }, e.MultiplyBlending = 4, e.MultiplyOperation = 0, e.NearestFilter = 1003, e.NearestMipMapLinearFilter = 1005, e.NearestMipMapNearestFilter = 1004, e.NearestMipmapLinearFilter = 1005, e.NearestMipmapNearestFilter = 1004, e.NeverDepth = 0, e.NeverStencilFunc = 512, e.NoBlending = 0, e.NoColors = 0, e.NoToneMapping = 0, e.NormalAnimationBlendMode = 2500, e.NormalBlending = 1, e.NotEqualDepth = 7, e.NotEqualStencilFunc = 517, e.NumberKeyframeTrack = Ci, e.Object3D = d, e.ObjectLoader = Rr, e.ObjectSpaceNormalMap = 1, e.OctahedronBufferGeometry = gn, e.OctahedronGeometry = mn, e.OneFactor = 201, e.OneMinusDstAlphaFactor = 207, e.OneMinusDstColorFactor = 209, e.OneMinusSrcAlphaFactor = 205, e.OneMinusSrcColorFactor = 203, e.OrthographicCamera = yr, e.PCFShadowMap = 1, e.PCFSoftShadowMap = 2, e.PMREMGenerator = xa, e.ParametricBufferGeometry = hn, e.ParametricGeometry = ln, e.Particle = function(e) { return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Vt(e) }, e.ParticleBasicMaterial = function(e) { return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new en(e) }, e.ParticleSystem = function(e, t) { return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new tn(e, t) }, e.ParticleSystemMaterial = function(e) { return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new en(e) }, e.Path = lr, e.PerspectiveCamera = Z, e.Plane = x, e.PlaneBufferGeometry = ie, e.PlaneGeometry = ne, e.PlaneHelper = ga, e.PointCloud = function(e, t) { return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new tn(e, t) }, e.PointCloudMaterial = function(e) { return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new en(e) }, e.PointLight = vr, e.PointLightHelper = sa, e.Points = tn, e.PointsMaterial = en, e.PolarGridHelper = ha, e.PolyhedronBufferGeometry = pn, e.PolyhedronGeometry = un, e.PositionalAudio = Hr, e.PropertyBinding = Wr, e.PropertyMixer = Vr, e.QuadraticBezierCurve = ar, e.QuadraticBezierCurve3 = or, e.Quaternion = c, e.QuaternionKeyframeTrack = Di, e.QuaternionLinearInterpolant = Oi, e.REVISION = "117", e.RGBADepthPacking = 3201, e.RGBAFormat = 1023, e.RGBAIntegerFormat = 1033, e.RGBA_ASTC_10x10_Format = 37819, e.RGBA_ASTC_10x5_Format = 37816, e.RGBA_ASTC_10x6_Format = 37817, e.RGBA_ASTC_10x8_Format = 37818, e.RGBA_ASTC_12x10_Format = 37820, e.RGBA_ASTC_12x12_Format = 37821, e.RGBA_ASTC_4x4_Format = 37808, e.RGBA_ASTC_5x4_Format = 37809, e.RGBA_ASTC_5x5_Format = 37810, e.RGBA_ASTC_6x5_Format = 37811, e.RGBA_ASTC_6x6_Format = 37812, e.RGBA_ASTC_8x5_Format = 37813, e.RGBA_ASTC_8x6_Format = 37814, e.RGBA_ASTC_8x8_Format = 37815, e.RGBA_BPTC_Format = 36492, e.RGBA_ETC2_EAC_Format = 37496, e.RGBA_PVRTC_2BPPV1_Format = 35843, e.RGBA_PVRTC_4BPPV1_Format = 35842, e.RGBA_S3TC_DXT1_Format = 33777, e.RGBA_S3TC_DXT3_Format = 33778, e.RGBA_S3TC_DXT5_Format = 33779, e.RGBDEncoding = 3006, e.RGBEEncoding = 3002, e.RGBEFormat = 1023, e.RGBFormat = 1022, e.RGBIntegerFormat = 1032, e.RGBM16Encoding = 3005, e.RGBM7Encoding = 3004, e.RGB_ETC1_Format = 36196, e.RGB_ETC2_Format = 37492, e.RGB_PVRTC_2BPPV1_Format = 35841, e.RGB_PVRTC_4BPPV1_Format = 35840, e.RGB_S3TC_DXT1_Format = 33776, e.RGFormat = 1030, e.RGIntegerFormat = 1031, e.RawShaderMaterial = mi, e.Ray = y, e.Raycaster = Qr, e.RectAreaLight = wr, e.RedFormat = 1028, e.RedIntegerFormat = 1029, e.ReinhardToneMapping = 2, e.RepeatWrapping = 1e3, e.ReplaceStencilOp = 7681, e.ReverseSubtractEquation = 102, e.RingBufferGeometry = ti, e.RingGeometry = ei, e.SRGB8_ALPHA8_ASTC_10x10_Format = 37851, e.SRGB8_ALPHA8_ASTC_10x5_Format = 37848, e.SRGB8_ALPHA8_ASTC_10x6_Format = 37849, e.SRGB8_ALPHA8_ASTC_10x8_Format = 37850, e.SRGB8_ALPHA8_ASTC_12x10_Format = 37852, e.SRGB8_ALPHA8_ASTC_12x12_Format = 37853, e.SRGB8_ALPHA8_ASTC_4x4_Format = 37840, e.SRGB8_ALPHA8_ASTC_5x4_Format = 37841, e.SRGB8_ALPHA8_ASTC_5x5_Format = 37842, e.SRGB8_ALPHA8_ASTC_6x5_Format = 37843, e.SRGB8_ALPHA8_ASTC_6x6_Format = 37844, e.SRGB8_ALPHA8_ASTC_8x5_Format = 37845, e.SRGB8_ALPHA8_ASTC_8x6_Format = 37846, e.SRGB8_ALPHA8_ASTC_8x8_Format = 37847, e.Scene = f, e.SceneUtils = { createMultiMaterialObject: function() { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") }, detach: function() { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") }, attach: function() { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") } }, e.ShaderChunk = Ms, e.ShaderLib = Ss, e.ShaderMaterial = X, e.ShadowMaterial = fi, e.Shape = hr, e.ShapeBufferGeometry = ai, e.ShapeGeometry = ri, e.ShapePath = Cr, e.ShapeUtils = Tc, e.ShortType = 1011, e.Skeleton = Xt, e.SkeletonHelper = oa, e.SkinnedMesh = qt, e.SmoothShading = 2, e.Sphere = v, e.SphereBufferGeometry = $n, e.SphereGeometry = Kn, e.Spherical = ea, e.SphericalHarmonics3 = Mr, e.SphericalReflectionMapping = 305, e.Spline = Ea, e.SplineCurve = sr, e.SplineCurve3 = Ta, e.SpotLight = mr, e.SpotLightHelper = aa, e.SpotLightShadow = fr, e.Sprite = Vt, e.SpriteMaterial = kt, e.SrcAlphaFactor = 204, e.SrcAlphaSaturateFactor = 210, e.SrcColorFactor = 202, e.StaticCopyUsage = 35046, e.StaticDrawUsage = 35044, e.StaticReadUsage = 35045, e.StereoCamera = zr, e.StreamCopyUsage = 35042, e.StreamDrawUsage = 35040, e.StreamReadUsage = 35041, e.StringKeyframeTrack = Ii, e.SubtractEquation = 101, e.SubtractiveBlending = 3, e.TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, e.TangentSpaceNormalMap = 0, e.TetrahedronBufferGeometry = fn, e.TetrahedronGeometry = dn, e.TextBufferGeometry = Qn, e.TextGeometry = Jn, e.Texture = r, e.TextureLoader = qi, e.TorusBufferGeometry = En, e.TorusGeometry = Tn, e.TorusKnotBufferGeometry = Sn, e.TorusKnotGeometry = Mn, e.Triangle = _, e.TriangleFanDrawMode = 2, e.TriangleStripDrawMode = 1, e.TrianglesDrawMode = 0, e.TubeBufferGeometry = wn, e.TubeGeometry = bn, e.UVMapping = 300, e.Uint16Attribute = function(e, t) { return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new D(e, t) }, e.Uint16BufferAttribute = D, e.Uint32Attribute = function(e, t) { return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new N(e, t) }, e.Uint32BufferAttribute = N, e.Uint8Attribute = function(e, t) { return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new P(e, t) }, e.Uint8BufferAttribute = P, e.Uint8ClampedAttribute = function(e, t) { return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new C(e, t) }, e.Uint8ClampedBufferAttribute = C, e.Uncharted2ToneMapping = 3, e.Uniform = Zr, e.UniformsLib = ws, e.UniformsUtils = xs, e.UnsignedByteType = 1009, e.UnsignedInt248Type = 1020, e.UnsignedIntType = 1014, e.UnsignedShort4444Type = 1017, e.UnsignedShort5551Type = 1018, e.UnsignedShort565Type = 1019, e.UnsignedShortType = 1012, e.VSMShadowMap = 3, e.Vector2 = n, e.Vector3 = l, e.Vector4 = a, e.VectorKeyframeTrack = Ni, e.Vertex = function(e, t, n) { return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new l(e, t, n) }, e.VertexColors = 2, e.VideoTexture = rn, e.WebGLCubeRenderTarget = Q, e.WebGLMultisampleRenderTarget = s, e.WebGLRenderTarget = o, e.WebGLRenderTargetCube = function(e, t, n) { return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new Q(e, n) }, e.WebGLRenderer = zt, e.WebGLUtils = Ct, e.WireframeGeometry = cn, e.WireframeHelper = function(e, t) { return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Kt(new cn(e.geometry), new Jt({ color: void 0 !== t ? t : 16777215 })) }, e.WrapAroundEnding = 2402, e.XHRLoader = function(e) { return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Gi(e) }, e.ZeroCurvatureEnding = 2400, e.ZeroFactor = 200, e.ZeroSlopeEnding = 2401, e.ZeroStencilOp = 0, e.sRGBEncoding = 3001, Object.defineProperty(e, "__esModule", { value: !0 }) });

    }, {}],
    24: [function(require, module, exports) {
        const WORLD_SIZE = 1024e3,
            MERCATOR_A = 6378137,
            FOV_ORTHO = .1 / 180 * Math.PI,
            FOV = Math.atan(.75),
            EARTH_RADIUS = 6371008.8,
            EARTH_CIRCUMFERENCE_EQUATOR = 40075017;
        module.exports = exports = { WORLD_SIZE: 1024e3, PROJECTION_WORLD_SIZE: 1024e3 / (6371008.8 * Math.PI * 2), MERCATOR_A: 6371008.8, DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, EARTH_RADIUS: 6371008.8, EARTH_CIRCUMFERENCE: 2 * Math.PI * 6371008.8, EARTH_CIRCUMFERENCE_EQUATOR: 40075017, FOV_ORTHO: FOV_ORTHO, FOV: FOV, FOV_DEGREES: 180 * FOV / Math.PI, TILE_SIZE: 512 };

    }, {}],
    25: [function(require, module, exports) {
        var utils = require("../utils/utils.js"),
            THREE = require("../three.js"),
            defaults = { material: "MeshBasicMaterial", color: "black", opacity: 1 };

        function material(a) { var t;

            function r() { return new THREE[defaults.material]({ color: defaults.color }) } return a ? (t = (a = utils._validate(a, defaults)).material && a.material.isMaterial ? a.material : a.material || a.color || a.opacity ? new THREE[a.material]({ color: a.color, transparent: a.opacity < 1 }) : r()).opacity = a.opacity : t = r(), t } module.exports = exports = material;

    }, { "../three.js": 23, "../utils/utils.js": 27 }],
    26: [function(require, module, exports) {
        ! function() { "use strict"; var n = Math.PI,
                t = Math.sin,
                e = Math.cos,
                r = Math.tan,
                a = Math.asin,
                u = Math.atan2,
                o = Math.acos,
                i = n / 180,
                c = 864e5,
                s = 2440588,
                d = 2451545;

            function f(n) { return n.valueOf() / c - .5 + s }

            function l(n) { return new Date((n + .5 - s) * c) }

            function h(n) { return f(n) - d } var M = 23.4397 * i;

            function g(n, a) { return u(t(n) * e(M) - r(a) * t(M), e(n)) }

            function v(n, r) { return a(t(r) * e(M) + e(r) * t(M) * t(n)) }

            function w(n, a, o) { return u(t(n), e(n) * t(a) - r(o) * e(a)) }

            function m(n, r, u) { return a(t(r) * t(u) + e(r) * e(u) * e(n)) }

            function D(n, t) { return i * (280.16 + 360.9856235 * n) - t }

            function P(n) { return i * (357.5291 + .98560028 * n) }

            function p(e) { return e + i * (1.9148 * t(e) + .02 * t(2 * e) + 3e-4 * t(3 * e)) + 102.9372 * i + n }

            function H(n) { var t = p(P(n)); return { dec: v(t, 0), ra: g(t, 0) } } var T = { getPosition: function(n, t, e) { var r = i * -e,
                            a = i * t,
                            u = h(n),
                            o = H(u),
                            c = D(u, r) - o.ra; return { azimuth: w(c, a, o.dec), altitude: m(c, a, o.dec) } }, toJulian: function(n) { return f(n) } },
                b = T.times = [
                    [-.833, "sunrise", "sunset"],
                    [-.3, "sunriseEnd", "sunsetStart"],
                    [-6, "dawn", "dusk"],
                    [-12, "nauticalDawn", "nauticalDusk"],
                    [-18, "nightEnd", "night"],
                    [6, "goldenHourEnd", "goldenHour"]
                ];
            T.addTime = function(n, t, e) { b.push([n, t, e]) }; var E = 9e-4;

            function I(t, e, r) { return E + (t + e) / (2 * n) + r }

            function k(n, e, r) { return d + n + .0053 * t(e) - .0069 * t(2 * r) }

            function q(n, r, a, u, i, c, s) { return k(I(function(n, r, a) { return o((t(n) - t(r) * t(a)) / (e(r) * e(a))) }(n, a, u), r, i), c, s) }

            function x(n) { var r = i * (134.963 + 13.064993 * n),
                    a = i * (93.272 + 13.22935 * n),
                    u = i * (218.316 + 13.176396 * n) + 6.289 * i * t(r),
                    o = 5.128 * i * t(a),
                    c = 385001 - 20905 * e(r); return { ra: g(u, o), dec: v(u, o), dist: c } }

            function y(n, t) { return new Date(n.valueOf() + t * c / 24) } T.getTimes = function(t, e, r, a) { var u, o, c, s, d, f = i * -r,
                    M = i * e,
                    g = function(n) { return -2.076 * Math.sqrt(n) / 60 }(a = a || 0),
                    w = function(t, e) { return Math.round(t - E - e / (2 * n)) }(h(t), f),
                    m = I(0, f, w),
                    D = P(m),
                    H = p(D),
                    T = v(H, 0),
                    x = k(m, D, H),
                    y = { solarNoon: l(x), nadir: l(x - .5) }; for (u = 0, o = b.length; u < o; u += 1) d = x - ((s = q(((c = b[u])[0] + g) * i, f, M, T, w, D, H)) - x), y[c[1]] = l(d), y[c[2]] = l(s); return y }, T.getMoonPosition = function(n, a, o) { var c = i * -o,
                    s = i * a,
                    d = h(n),
                    f = x(d),
                    l = D(d, c) - f.ra,
                    M = m(l, s, f.dec),
                    g = u(t(l), r(s) * e(f.dec) - t(f.dec) * e(l)); return M += function(n) { return n < 0 && (n = 0), 2967e-7 / Math.tan(n + .00312536 / (n + .08901179)) }(M), { azimuth: w(l, s, f.dec), altitude: M, distance: f.dist, parallacticAngle: g } }, T.getMoonIllumination = function(n) { var r = h(n || new Date),
                    a = H(r),
                    i = x(r),
                    c = o(t(a.dec) * t(i.dec) + e(a.dec) * e(i.dec) * e(a.ra - i.ra)),
                    s = u(149598e3 * t(c), i.dist - 149598e3 * e(c)),
                    d = u(e(a.dec) * t(a.ra - i.ra), t(a.dec) * e(i.dec) - e(a.dec) * t(i.dec) * e(a.ra - i.ra)); return { fraction: (1 + e(s)) / 2, phase: .5 + .5 * s * (d < 0 ? -1 : 1) / Math.PI, angle: d } }, T.getMoonTimes = function(n, t, e, r) { var a = new Date(n);
                r ? a.setUTCHours(0, 0, 0, 0) : a.setHours(0, 0, 0, 0); for (var u, o, c, s, d, f, l, h, M, g, v, w, m, D = .133 * i, P = T.getMoonPosition(a, t, e).altitude - D, p = 1; p <= 24 && (u = T.getMoonPosition(y(a, p), t, e).altitude - D, h = ((d = (P + (o = T.getMoonPosition(y(a, p + 1), t, e).altitude - D)) / 2 - u) * (l = -(f = (o - P) / 2) / (2 * d)) + f) * l + u, g = 0, (M = f * f - 4 * d * u) >= 0 && (v = l - (m = Math.sqrt(M) / (2 * Math.abs(d))), w = l + m, Math.abs(v) <= 1 && g++, Math.abs(w) <= 1 && g++, v < -1 && (v = w)), 1 === g ? P < 0 ? c = p + v : s = p + v : 2 === g && (c = p + (h < 0 ? w : v), s = p + (h < 0 ? v : w)), !c || !s); p += 2) P = o; var H = {}; return c && (H.rise = y(a, c)), s && (H.set = y(a, s)), c || s || (H[h > 0 ? "alwaysUp" : "alwaysDown"] = !0), H }, module.exports = exports = T }();

    }, {}],
    27: [function(require, module, exports) {
        var THREE = require("../three.js"),
            Constants = require("./constants.js"),
            validate = require("./validate.js"),
            utils = { prettyPrintMatrix: function(t) { for (var e = 0; e < 4; e++) { var r = [t[e], t[e + 4], t[e + 8], t[e + 12]];
                        console.log(r.map(function(t) { return t.toFixed(4) })) } }, makePerspectiveMatrix: function(t, e, r, n) { var o = new THREE.Matrix4,
                        i = 1 / Math.tan(t / 2),
                        s = 1 / (r - n),
                        u = [i / e, 0, 0, 0, 0, i, 0, 0, 0, 0, (n + r) * s, -1, 0, 0, 2 * n * r * s, 0]; return o.elements = u, o }, makeOrthographicMatrix: function(t, e, r, n, o, i) { var s = new THREE.Matrix4; const u = 1 / (e - t),
                        a = 1 / (r - n),
                        c = 1 / (i - o); var l = [2 * u, 0, 0, 0, 0, 2 * a, 0, 0, 0, 0, -1 * c, 0, -((e + t) * u), -((r + n) * a), -(o * c), 1]; return s.elements = l, s }, radify: function(t) {
                    function e(t) { return t = t || 0, 2 * Math.PI * t / 360 } return "object" == typeof t ? t.length > 0 ? t.map(function(t) { return e(t) }) : [e(t.x), e(t.y), e(t.z)] : e(t) }, degreeify: function(t) {
                    function e(t) { return 360 * (t = t || 0) / (2 * Math.PI) } return "object" == typeof t ? [e(t.x), e(t.y), e(t.z)] : e(t) }, projectToWorld: function(t) { var e = [-Constants.MERCATOR_A * Constants.DEG2RAD * t[0] * Constants.PROJECTION_WORLD_SIZE, -Constants.MERCATOR_A * Math.log(Math.tan(.25 * Math.PI + .5 * Constants.DEG2RAD * t[1])) * Constants.PROJECTION_WORLD_SIZE]; if (t[2]) { var r = this.projectedUnitsPerMeter(t[1]);
                        e.push(t[2] * r) } else e.push(0); return new THREE.Vector3(e[0], e[1], e[2]) }, projectedUnitsPerMeter: function(t) { return Math.abs(Constants.WORLD_SIZE / Math.cos(Constants.DEG2RAD * t) / Constants.EARTH_CIRCUMFERENCE) }, _circumferenceAtLatitude: function(t) { return Constants.EARTH_CIRCUMFERENCE * Math.cos(t * Math.PI / 180) }, mercatorZfromAltitude: function(t, e) { return t / this._circumferenceAtLatitude(e) }, _scaleVerticesToMeters: function(t, e) { for (var r = this.projectedUnitsPerMeter(t[1]), n = (this.projectToWorld(t), 0); n < e.length; n++) e[n].multiplyScalar(r); return e }, projectToScreen: function(t) { console.log("WARNING: Projecting to screen coordinates is not yet implemented") }, unprojectFromScreen: function(t) { console.log("WARNING: unproject is not yet implemented") }, unprojectFromWorld: function(t) { var e = [-t.x / (Constants.MERCATOR_A * Constants.DEG2RAD * Constants.PROJECTION_WORLD_SIZE), 2 * (Math.atan(Math.exp(t.y / (Constants.PROJECTION_WORLD_SIZE * -Constants.MERCATOR_A))) - Math.PI / 4) / Constants.DEG2RAD],
                        r = this.projectedUnitsPerMeter(e[1]),
                        n = t.z || 0; return e.push(n / r), e }, toScreenPosition: function(t, e) { var r = new THREE.Vector3,
                        n = .5 * renderer.context.canvas.width,
                        o = .5 * renderer.context.canvas.height; return t.updateMatrixWorld(), r.setFromMatrixPosition(t.matrixWorld), r.project(e), r.x = r.x * n + n, r.y = -r.y * o + o, { x: r.x, y: r.y } }, getFeatureCenter: function(t, e, r) { let n = [],
                        o = 0,
                        i = 0,
                        s = 0,
                        u = []; return u.push(...t.geometry.coordinates[0]), "Point" === t.geometry.type ? n = u[0] : ("MultiPolygon" === t.geometry.type && (u = u[0]), u.splice(-1, 1), u.forEach(function(t) { o += t[0], i += t[1] }), n = [o / u.length, i / u.length]), s = this.getObjectHeightOnFloor(t, e, r), n.length < 3 ? n.push(s) : n[2] = s, n }, getObjectHeightOnFloor: function(t, e, r = t.properties.level || 0) { let n = r * (t.properties.levelHeight || 0),
                        o = t.properties.base_height || t.properties.min_height || 0; return n + ((e && e.model ? 0 : t.properties.height - o) + o) }, _flipMaterialSides: function(t) {}, normalizeVertices(t) { var e = new THREE.Geometry; for (v3 of t) e.vertices.push(v3);
                    e.computeBoundingSphere(); var r = e.boundingSphere.center;
                    e.boundingSphere.radius; return { vertices: t.map(function(t) { return t.sub(r) }), position: r } }, flattenVectors(t) { var e = []; for (vertex of t) e.push(vertex.x, vertex.y, vertex.z); return e }, lnglatsToWorld: function(t) { return t.map(function(t) { var e = utils.projectToWorld(t); return new THREE.Vector3(e.x, e.y, e.z) }) }, extend: function(t, e) { for (let r in e) t[r] = e[r] }, clone: function(t) { var e = {}; for (let r in t) e[r] = t[r]; return e }, clamp: function(t, e, r) { return Math.min(r, Math.max(e, t)) }, types: { rotation: function(t, e) { t || (t = 0), "number" == typeof t && (t = { z: t }); var r = this.applyDefault([t.x, t.y, t.z], e); return utils.radify(r) }, scale: function(t, e) { return t || (t = 1), "number" == typeof t ? [t, t, t] : this.applyDefault([t.x, t.y, t.z], e) }, applyDefault: function(t, e) { return t.map(function(t, r) { return t = t || e[r] }) } }, toDecimal: function(t, e) { return Number(t.toFixed(e)) }, equal: function(t, e) { const r = Object.keys(t),
                        n = Object.keys(e); if (r.length !== n.length) return !1; if (0 == r.length && 0 == n.length && r !== n) return !1; for (const n of r) { const r = t[n],
                            o = e[n],
                            i = this.isObject(r) && this.isObject(o); if (i && !equal(r, o) || !i && r !== o) return !1 } return !0 }, isObject: function(t) { return null != t && "object" == typeof t }, curveToLine: (t, e) => { let { width: r, color: n } = e, o = (new THREE.BufferGeometry).setFromPoints(t.getPoints(100)), i = new THREE.LineBasicMaterial({ color: n, linewidth: r }); return new THREE.Line(o, i) }, curvesToLines: t => { var e = [16711680, 2031360, 2490623]; return t.map((t, r) => { return curveToLine(t, { width: 3, color: e[r] || "purple" }) }) }, _validate: function(t, e) { t = t || {}; var r = {};
                    utils.extend(r, t); for (let n of Object.keys(e))
                        if (void 0 === t[n]) { if (null === e[n]) return void console.error(n + " is required");
                            r[n] = e[n] } else r[n] = t[n]; return r }, Validator: new validate, exposedMethods: ["projectToWorld", "projectedUnitsPerMeter", "extend", "unprojectFromWorld"] };
        module.exports = exports = utils;

    }, { "../three.js": 23, "./constants.js": 24, "./validate.js": 28 }],
    28: [function(require, module, exports) {
        function Validate() {} Validate.prototype = { Coords: function(r) { if (r.constructor === Array)
                    if (r.length < 2) console.error("Coords length must be at least 2");
                    else { for (const o of r)
                            if (o.constructor !== Number) return void console.error("Coords values must be numbers"); if (!(Math.abs(r[1]) > 90)) return r;
                        console.error("Latitude must be between -90 and 90") } else console.error("Coords must be an array") }, Line: function(r) { if (r.constructor === Array) { for (const o of r)
                        if (!this.Coords(o)) return void console.error("Each coordinate in a line must be a valid Coords type"); return r } console.error("Line must be an array") }, Rotation: function(r) { if (r.constructor === Number) r = { z: r };
                else { if (r.constructor !== Object) return void console.error("Rotation must be an object or a number"); for (const o of Object.keys(r)) { if (!["x", "y", "z"].includes(o)) return void console.error("Rotation parameters must be x, y, or z"); if (r[o].constructor !== Number) return void console.error("Individual rotation values must be numbers") } } return r }, Scale: function(r) { if (r.constructor === Number) r = { x: r, y: r, z: r };
                else { if (r.constructor !== Object) return void console.error("Scale must be an object or a number"); for (const o of Object.keys(r)) { if (!["x", "y", "z"].includes(o)) return void console.error("Scale parameters must be x, y, or z"); if (r[o].constructor !== Number) return void console.error("Individual scale values must be numbers") } } return r } }, module.exports = exports = Validate;

    }, {}]
}, {}, [1]);